unit lockbox;

{$MODE Delphi}{$H+}
{$HINTS OFF}

{$IFDEF UNICODE}
{.$DEFINE LOCKBOXUNICODE}
{$ENDIF}

{$IFDEF UNICODE}
{$HIGHCHARUNICODE OFF}
{$ENDIF}

interface

uses
  ctypes,
  Math,
  Classes,
  SysUtils,
  Types,
  base64;

resourcestring
  sBIBufferUnderflow = 'Buffer UnderFlow';
  sBIBufferNotAssigned = 'Buffer not assigned';
  sBINoNumber = 'No Number';
  sBISubtractErr = 'Subtraction error';
  sBIZeroDivide = 'Division by zero';
  sBIQuotientErr = 'Quotient process error';
  sBIZeroFactor = 'Factor is zero';
  sBIIterationCount = 'Iterations must be more than 50';
  sASNKeyTooLarge = 'ASN key too large';
  sASNKeyBufferOverflow = 'Buffer OverFlow';
  sASNKeyBadModulus = 'Asymmetric key modulus invalid';
  sASNKeyBadExponent = 'Asymmetric key exponent invalid';
  sASNKeyBufferTooSmall = 'Buffer too small for key';
  sASNKeyBadKey = 'Invalid Asymmetric Key';
  sRSAKeyBadKey = 'Invalid RSA Key';
  sModulusStringTooBig = 'Modulus string too big';
  sExponentStringTooBig = 'Exponent string too big';
  sRSAKeyPairErr = 'RSA key pair failure';
  sRSAPublicKeyErr = 'Invalid RSA public key';
  sRSAPrivateKeyErr = 'Invalid RSA private key';
  sRSAEncryptErr = 'RSA encryption failure';
  sRSADecryptErr = 'RSA decryption failure';
  sRSABlockSize128Err = 'Invalid block size for key128';
  sRSABlockSize256Err = 'Invalid block size for key256';
  sRSABlockSize512Err = 'Invalid block size for key512';
  sRSABlockSize768Err = 'Invalid block size for key768';
  sRSABlockSize1024Err = 'Invalid block size for key1024';
  sRSAEncodingErr = 'RSA encoding error: too much data for block';
  sRSADecodingErrBTS = 'RSA decoding error: Block too small';
  sRSADecodingErrBTL = 'RSA decoding error: Block too large';
  sRSADecodingErrIBT = 'RSA decoding error: Invalid block type';
  sRSADecodingErrIBF = 'RSA decoding error: Invalid block format';
  sDSAKeyBadKey = 'Invalid DSA Key';
  sDSAParametersPQGErr = 'DSA PQG parameter failure';
  sDSAParametersXYErr = 'DSA XY parameter failure';
  sDSASignatureZeroR = 'DSA Signature R is zero';
  sDSASignatureZeroS = 'DSA Signature S is zero';
  sDSASignatureErr = 'DSA Signature failure';
  SNoStart = 'Unable to start web browser. Make sure you have it properly ' + 'set-up on your system.';

const
  cBytes128 = 16;
  cBytes160 = 20;
  cBytes192 = 24;
  cBytes256 = 32;
  cBytes512 = 64;
  cBytes768 = 96;
  cBytes1024 = 128;
  cDefIterations = 20;
  ASN1_TYPE_SEQUENCE = $10;
  ASN1_TYPE_Integer = $02;
  ASN1_TAG_NUM_MASK = $1f;
  ASN1_TYPE_HIGH_TAG_NUMBER = $1f;
  HIGH_BIT_MASK = $80;
  BIT_MASK_7F = $7F;
  BFRounds = 16;
  MaxRDLRounds = 14;


const
  bf_P: array[0..(BFRounds + 1)] of DWord = (
    $243F6A88, $85A308D3, $13198A2E, $03707344,
    $A4093822, $299F31D0, $082EFA98, $EC4E6C89,
    $452821E6, $38D01377, $BE5466CF, $34E90C6C,
    $C0AC29B7, $C97C50DD, $3F84D5B5, $B5470917,
    $9216D5D9, $8979FB1B);
  bf_S: array[0..3, 0..255] of DWord =
    (
    ($D1310BA6, $98DFB5AC, $2FFD72DB, $D01ADFB7,
    $B8E1AFED, $6A267E96, $BA7C9045, $F12C7F99,
    $24A19947, $B3916CF7, $0801F2E2, $858EFC16,
    $636920D8, $71574E69, $A458FEA3, $F4933D7E,

    $0D95748F, $728EB658, $718BCD58, $82154AEE,
    $7B54A41D, $C25A59B5, $9C30D539, $2AF26013,
    $C5D1B023, $286085F0, $CA417918, $B8DB38EF,
    $8E79DCB0, $603A180E, $6C9E0E8B, $B01E8A3E,

    $D71577C1, $BD314B27, $78AF2FDA, $55605C60,
    $E65525F3, $AA55AB94, $57489862, $63E81440,
    $55CA396A, $2AAB10B6, $B4CC5C34, $1141E8CE,
    $A15486AF, $7C72E993, $B3EE1411, $636FBC2A,

    $2BA9C55D, $741831F6, $CE5C3E16, $9B87931E,
    $AFD6BA33, $6C24CF5C, $7A325381, $28958677,
    $3B8F4898, $6B4BB9AF, $C4BFE81B, $66282193,
    $61D809CC, $FB21A991, $487CAC60, $5DEC8032,

    $EF845D5D, $E98575B1, $DC262302, $EB651B88,
    $23893E81, $D396ACC5, $0F6D6FF3, $83F44239,
    $2E0B4482, $A4842004, $69C8F04A, $9E1F9B5E,
    $21C66842, $F6E96C9A, $670C9C61, $ABD388F0,

    $6A51A0D2, $D8542F68, $960FA728, $AB5133A3,
    $6EEF0B6C, $137A3BE4, $BA3BF050, $7EFB2A98,
    $A1F1651D, $39AF0176, $66CA593E, $82430E88,
    $8CEE8619, $456F9FB4, $7D84A5C3, $3B8B5EBE,

    $E06F75D8, $85C12073, $401A449F, $56C16AA6,
    $4ED3AA62, $363F7706, $1BFEDF72, $429B023D,
    $37D0D724, $D00A1248, $DB0FEAD3, $49F1C09B,
    $075372C9, $80991B7B, $25D479D8, $F6E8DEF7,

    $E3FE501A, $B6794C3B, $976CE0BD, $04C006BA,
    $C1A94FB6, $409F60C4, $5E5C9EC2, $196A2463,
    $68FB6FAF, $3E6C53B5, $1339B2EB, $3B52EC6F,
    $6DFC511F, $9B30952C, $CC814544, $AF5EBD09,

    $BEE3D004, $DE334AFD, $660F2807, $192E4BB3,
    $C0CBA857, $45C8740F, $D20B5F39, $B9D3FBDB,
    $5579C0BD, $1A60320A, $D6A100C6, $402C7279,
    $679F25FE, $FB1FA3CC, $8EA5E9F8, $DB3222F8,

    $3C7516DF, $FD616B15, $2F501EC8, $AD0552AB,
    $323DB5FA, $FD238760, $53317B48, $3E00DF82,
    $9E5C57BB, $CA6F8CA0, $1A87562E, $DF1769DB,
    $D542A8F6, $287EFFC3, $AC6732C6, $8C4F5573,

    $695B27B0, $BBCA58C8, $E1FFA35D, $B8F011A0,
    $10FA3D98, $FD2183B8, $4AFCB56C, $2DD1D35B,
    $9A53E479, $B6F84565, $D28E49BC, $4BFB9790,
    $E1DDF2DA, $A4CB7E33, $62FB1341, $CEE4C6E8,

    $EF20CADA, $36774C01, $D07E9EFE, $2BF11FB4,
    $95DBDA4D, $AE909198, $EAAD8E71, $6B93D5A0,
    $D08ED1D0, $AFC725E0, $8E3C5B2F, $8E7594B7,
    $8FF6E2FB, $F2122B64, $8888B812, $900DF01C,

    $4FAD5EA0, $688FC31C, $D1CFF191, $B3A8C1AD,
    $2F2F2218, $BE0E1777, $EA752DFE, $8B021FA1,
    $E5A0CC0F, $B56F74E8, $18ACF3D6, $CE89E299,
    $B4A84FE0, $FD13E0B7, $7CC43B81, $D2ADA8D9,

    $165FA266, $80957705, $93CC7314, $211A1477,
    $E6AD2065, $77B5FA86, $C75442F5, $FB9D35CF,
    $EBCDAF0C, $7B3E89A0, $D6411BD3, $AE1E7E49,
    $00250E2D, $2071B35E, $226800BB, $57B8E0AF,

    $2464369B, $F009B91E, $5563911D, $59DFA6AA,
    $78C14389, $D95A537F, $207D5BA2, $02E5B9C5,
    $83260376, $6295CFA9, $11C81968, $4E734A41,
    $B3472DCA, $7B14A94A, $1B510052, $9A532915,

    $D60F573F, $BC9BC6E4, $2B60A476, $81E67400,
    $08BA6FB5, $571BE91F, $F296EC6B, $2A0DD915,
    $B6636521, $E7B9F9B6, $FF34052E, $C5855664,
    $53B02D5D, $A99F8FA1, $08BA4799, $6E85076A),
    {SECOND 256}
    ($4B7A70E9, $B5B32944, $DB75092E, $C4192623,
    $AD6EA6B0, $49A7DF7D, $9CEE60B8, $8FEDB266,
    $ECAA8C71, $699A17FF, $5664526C, $C2B19EE1,
    $193602A5, $75094C29, $A0591340, $E4183A3E,

    $3F54989A, $5B429D65, $6B8FE4D6, $99F73FD6,
    $A1D29C07, $EFE830F5, $4D2D38E6, $F0255DC1,
    $4CDD2086, $8470EB26, $6382E9C6, $021ECC5E,
    $09686B3F, $3EBAEFC9, $3C971814, $6B6A70A1,

    $687F3584, $52A0E286, $B79C5305, $AA500737,
    $3E07841C, $7FDEAE5C, $8E7D44EC, $5716F2B8,
    $B03ADA37, $F0500C0D, $F01C1F04, $0200B3FF,
    $AE0CF51A, $3CB574B2, $25837A58, $DC0921BD,

    $D19113F9, $7CA92FF6, $94324773, $22F54701,
    $3AE5E581, $37C2DADC, $C8B57634, $9AF3DDA7,
    $A9446146, $0FD0030E, $ECC8C73E, $A4751E41,
    $E238CD99, $3BEA0E2F, $3280BBA1, $183EB331,

    $4E548B38, $4F6DB908, $6F420D03, $F60A04BF,
    $2CB81290, $24977C79, $5679B072, $BCAF89AF,
    $DE9A771F, $D9930810, $B38BAE12, $DCCF3F2E,
    $5512721F, $2E6B7124, $501ADDE6, $9F84CD87,

    $7A584718, $7408DA17, $BC9F9ABC, $E94B7D8C,
    $EC7AEC3A, $DB851DFA, $63094366, $C464C3D2,
    $EF1C1847, $3215D908, $DD433B37, $24C2BA16,
    $12A14D43, $2A65C451, $50940002, $133AE4DD,

    $71DFF89E, $10314E55, $81AC77D6, $5F11199B,
    $043556F1, $D7A3C76B, $3C11183B, $5924A509,
    $F28FE6ED, $97F1FBFA, $9EBABF2C, $1E153C6E,
    $86E34570, $EAE96FB1, $860E5E0A, $5A3E2AB3,

    $771FE71C, $4E3D06FA, $2965DCB9, $99E71D0F,
    $803E89D6, $5266C825, $2E4CC978, $9C10B36A,
    $C6150EBA, $94E2EA78, $A5FC3C53, $1E0A2DF4,
    $F2F74EA7, $361D2B3D, $1939260F, $19C27960,

    $5223A708, $F71312B6, $EBADFE6E, $EAC31F66,
    $E3BC4595, $A67BC883, $B17F37D1, $018CFF28,
    $C332DDEF, $BE6C5AA5, $65582185, $68AB9802,
    $EECEA50F, $DB2F953B, $2AEF7DAD, $5B6E2F84,

    $1521B628, $29076170, $ECDD4775, $619F1510,
    $13CCA830, $EB61BD96, $0334FE1E, $AA0363CF,
    $B5735C90, $4C70A239, $D59E9E0B, $CBAADE14,
    $EECC86BC, $60622CA7, $9CAB5CAB, $B2F3846E,

    $648B1EAF, $19BDF0CA, $A02369B9, $655ABB50,
    $40685A32, $3C2AB4B3, $319EE9D5, $C021B8F7,
    $9B540B19, $875FA099, $95F7997E, $623D7DA8,
    $F837889A, $97E32D77, $11ED935F, $16681281,

    $0E358829, $C7E61FD6, $96DEDFA1, $7858BA99,
    $57F584A5, $1B227263, $9B83C3FF, $1AC24696,
    $CDB30AEB, $532E3054, $8FD948E4, $6DBC3128,
    $58EBF2EF, $34C6FFEA, $FE28ED61, $EE7C3C73,

    $5D4A14D9, $E864B7E3, $42105D14, $203E13E0,
    $45EEE2B6, $A3AAABEA, $DB6C4F15, $FACB4FD0,
    $C742F442, $EF6ABBB5, $654F3B1D, $41CD2105,
    $D81E799E, $86854DC7, $E44B476A, $3D816250,

    $CF62A1F2, $5B8D2646, $FC8883A0, $C1C7B6A3,
    $7F1524C3, $69CB7492, $47848A0B, $5692B285,
    $095BBF00, $AD19489D, $1462B174, $23820E00,
    $58428D2A, $0C55F5EA, $1DADF43E, $233F7061,

    $3372F092, $8D937E41, $D65FECF1, $6C223BDB,
    $7CDE3759, $CBEE7460, $4085F2A7, $CE77326E,
    $A6078084, $19F8509E, $E8EFD855, $61D99735,
    $A969A7AA, $C50C06C2, $5A04ABFC, $800BCADC,

    $9E447A2E, $C3453484, $FDD56705, $0E1E9EC9,
    $DB73DBD3, $105588CD, $675FDA79, $E3674340,
    $C5C43465, $713E38D8, $3D28F89E, $F16DFF20,
    $153E21E7, $8FB03D4A, $E6E39F2B, $DB83ADF7),
    {THIRD 256}
    ($E93D5A68, $948140F7, $F64C261C, $94692934,
    $411520F7, $7602D4F7, $BCF46B2E, $D4A20068,
    $D4082471, $3320F46A, $43B7D4B7, $500061AF,
    $1E39F62E, $97244546, $14214F74, $BF8B8840,

    $4D95FC1D, $96B591AF, $70F4DDD3, $66A02F45,
    $BFBC09EC, $03BD9785, $7FAC6DD0, $31CB8504,
    $96EB27B3, $55FD3941, $DA2547E6, $ABCA0A9A,
    $28507825, $530429F4, $0A2C86DA, $E9B66DFB,

    $68DC1462, $D7486900, $680EC0A4, $27A18DEE,
    $4F3FFEA2, $E887AD8C, $B58CE006, $7AF4D6B6,
    $AACE1E7C, $D3375FEC, $CE78A399, $406B2A42,
    $20FE9E35, $D9F385B9, $EE39D7AB, $3B124E8B,

    $1DC9FAF7, $4B6D1856, $26A36631, $EAE397B2,
    $3A6EFA74, $DD5B4332, $6841E7F7, $CA7820FB,
    $FB0AF54E, $D8FEB397, $454056AC, $BA489527,
    $55533A3A, $20838D87, $FE6BA9B7, $D096954B,

    $55A867BC, $A1159A58, $CCA92963, $99E1DB33,
    $A62A4A56, $3F3125F9, $5EF47E1C, $9029317C,
    $FDF8E802, $04272F70, $80BB155C, $05282CE3,
    $95C11548, $E4C66D22, $48C1133F, $C70F86DC,

    $07F9C9EE, $41041F0F, $404779A4, $5D886E17,
    $325F51EB, $D59BC0D1, $F2BCC18F, $41113564,
    $257B7834, $602A9C60, $DFF8E8A3, $1F636C1B,
    $0E12B4C2, $02E1329E, $AF664FD1, $CAD18115,

    $6B2395E0, $333E92E1, $3B240B62, $EEBEB922,
    $85B2A20E, $E6BA0D99, $DE720C8C, $2DA2F728,
    $D0127845, $95B794FD, $647D0862, $E7CCF5F0,
    $5449A36F, $877D48FA, $C39DFD27, $F33E8D1E,

    $0A476341, $992EFF74, $3A6F6EAB, $F4F8FD37,
    $A812DC60, $A1EBDDF8, $991BE14C, $DB6E6B0D,
    $C67B5510, $6D672C37, $2765D43B, $DCD0E804,
    $F1290DC7, $CC00FFA3, $B5390F92, $690FED0B,

    $667B9FFB, $CEDB7D9C, $A091CF0B, $D9155EA3,
    $BB132F88, $515BAD24, $7B9479BF, $763BD6EB,
    $37392EB3, $CC115979, $8026E297, $F42E312D,
    $6842ADA7, $C66A2B3B, $12754CCC, $782EF11C,

    $6A124237, $B79251E7, $06A1BBE6, $4BFB6350,
    $1A6B1018, $11CAEDFA, $3D25BDD8, $E2E1C3C9,
    $44421659, $0A121386, $D90CEC6E, $D5ABEA2A,
    $64AF674E, $DA86A85F, $BEBFE988, $64E4C3FE,

    $9DBC8057, $F0F7C086, $60787BF8, $6003604D,
    $D1FD8346, $F6381FB0, $7745AE04, $D736FCCC,
    $83426B33, $F01EAB71, $B0804187, $3C005E5F,
    $77A057BE, $BDE8AE24, $55464299, $BF582E61,

    $4E58F48F, $F2DDFDA2, $F474EF38, $8789BDC2,
    $5366F9C3, $C8B38E74, $B475F255, $46FCD9B9,
    $7AEB2661, $8B1DDF84, $846A0E79, $915F95E2,
    $466E598E, $20B45770, $8CD55591, $C902DE4C,

    $B90BACE1, $BB8205D0, $11A86248, $7574A99E,
    $B77F19B6, $E0A9DC09, $662D09A1, $C4324633,
    $E85A1F02, $09F0BE8C, $4A99A025, $1D6EFE10,
    $1AB93D1D, $0BA5A4DF, $A186F20F, $2868F169,

    $DCB7DA83, $573906FE, $A1E2CE9B, $4FCD7F52,
    $50115E01, $A70683FA, $A002B5C4, $0DE6D027,
    $9AF88C27, $773F8641, $C3604C06, $61A806B5,
    $F0177A28, $C0F586E0, $006058AA, $30DC7D62,

    $11E69ED7, $2338EA63, $53C2DD94, $C2C21634,
    $BBCBEE56, $90BCB6DE, $EBFC7DA1, $CE591D76,
    $6F05E409, $4B7C0188, $39720A3D, $7C927C24,
    $86E3725F, $724D9DB9, $1AC15BB4, $D39EB8FC,

    $ED545578, $08FCA5B5, $D83D7CD3, $4DAD0FC4,
    $1E50EF5E, $B161E6F8, $A28514D9, $6C51133C,
    $6FD5C7E7, $56E14EC4, $362ABFCE, $DDC6C837,
    $D79A3234, $92638212, $670EFA8E, $406000E0),
    {FOURTH 256}
    ($3A39CE37, $D3FAF5CF, $ABC27737, $5AC52D1B,
    $5CB0679E, $4FA33742, $D3822740, $99BC9BBE,
    $D5118E9D, $BF0F7315, $D62D1C7E, $C700C47B,
    $B78C1B6B, $21A19045, $B26EB1BE, $6A366EB4,

    $5748AB2F, $BC946E79, $C6A376D2, $6549C2C8,
    $530FF8EE, $468DDE7D, $D5730A1D, $4CD04DC6,
    $2939BBDB, $A9BA4650, $AC9526E8, $BE5EE304,
    $A1FAD5F0, $6A2D519A, $63EF8CE2, $9A86EE22,

    $C089C2B8, $43242EF6, $A51E03AA, $9CF2D0A4,
    $83C061BA, $9BE96A4D, $8FE51550, $BA645BD6,
    $2826A2F9, $A73A3AE1, $4BA99586, $EF5562E9,
    $C72FEFD3, $F752F7DA, $3F046F69, $77FA0A59,

    $80E4A915, $87B08601, $9B09E6AD, $3B3EE593,
    $E990FD5A, $9E34D797, $2CF0B7D9, $022B8B51,
    $96D5AC3A, $017DA67D, $D1CF3ED6, $7C7D2D28,
    $1F9F25CF, $ADF2B89B, $5AD6B472, $5A88F54C,

    $E029AC71, $E019A5E6, $47B0ACFD, $ED93FA9B,
    $E8D3C48D, $283B57CC, $F8D56629, $79132E28,
    $785F0191, $ED756055, $F7960E44, $E3D35E8C,
    $15056DD4, $88F46DBA, $03A16125, $0564F0BD,

    $C3EB9E15, $3C9057A2, $97271AEC, $A93A072A,
    $1B3F6D9B, $1E6321F5, $F59C66FB, $26DCF319,
    $7533D928, $B155FDF5, $03563482, $8ABA3CBB,
    $28517711, $C20AD9F8, $ABCC5167, $CCAD925F,

    $4DE81751, $3830DC8E, $379D5862, $9320F991,
    $EA7A90C2, $FB3E7BCE, $5121CE64, $774FBE32,
    $A8B6E37E, $C3293D46, $48DE5369, $6413E680,
    $A2AE0810, $DD6DB224, $69852DFD, $09072166,

    $B39A460A, $6445C0DD, $586CDECF, $1C20C8AE,
    $5BBEF7DD, $1B588D40, $CCD2017F, $6BB4E3BB,
    $DDA26A7E, $3A59FF45, $3E350A44, $BCB4CDD5,
    $72EACEA8, $FA6484BB, $8D6612AE, $BF3C6F47,

    $D29BE463, $542F5D9E, $AEC2771B, $F64E6370,
    $740E0D8D, $E75B1357, $F8721671, $AF537D5D,
    $4040CB08, $4EB4E2CC, $34D2466A, $0115AF84,
    $E1B00428, $95983A1D, $06B89FB4, $CE6EA048,

    $6F3F3B82, $3520AB82, $011A1D4B, $277227F8,
    $611560B1, $E7933FDC, $BB3A792B, $344525BD,
    $A08839E1, $51CE794B, $2F32C9B7, $A01FBAC9,
    $E01CC87E, $BCC7D1F6, $CF0111C3, $A1E8AAC7,

    $1A908749, $D44FBD9A, $D0DADECB, $D50ADA38,
    $0339C32A, $C6913667, $8DF9317C, $E0B12B4F,
    $F79E59B7, $43F5BB3A, $F2D519FF, $27D9459C,
    $BF97222C, $15E6FC2A, $0F91FC71, $9B941525,

    $FAE59361, $CEB69CEB, $C2A86459, $12BAA8D1,
    $B6C1075E, $E3056A0C, $10D25065, $CB03A442,
    $E0EC6E0E, $1698DB3B, $4C98A0BE, $3278E964,
    $9F1F9532, $E0D392DF, $D3A0342B, $8971F21E,

    $1B0A7441, $4BA3348C, $C5BE7120, $C37632D8,
    $DF359F8D, $9B992F2E, $E60B6F47, $0FE3F11D,
    $E54CDA54, $1EDAD891, $CE6279CF, $CD3E7E6F,
    $1618B166, $FD2C1D05, $848FD2C5, $F6FB2299,

    $F523F357, $A6327623, $93A83531, $56CCCD02,
    $ACF08162, $5A75EBB5, $6E163697, $88D273CC,
    $DE966292, $81B949D0, $4C50901B, $71C65614,
    $E6C6C7BD, $327A140A, $45E1D006, $C3F27B9A,

    $C9AA53FD, $62A80F00, $BB25BFE2, $35BDD2F6,
    $71126905, $B2040222, $B6CBCF7C, $CD769C2B,
    $53113EC0, $1640E3D3, $38ABBD60, $2547ADF0,
    $BA38209C, $F746CE76, $77AFA1C5, $20756060,

    $85CBFE4E, $8AE88DD8, $7AAAF9B0, $4CF9AA7E,
    $1948C25C, $02FB8A8C, $01C36AE4, $D6EBE1F9,
    $90D4F869, $A65CDEA0, $3F09252D, $C208E69F,
    $B74E6132, $CE77E25B, $578FDFE3, $3AC372E6));

  RDLSBox: array[$00..$FF] of byte =
    ($63, $7C, $77, $7B, $F2, $6B, $6F, $C5, $30, $01, $67, $2B, $FE, $D7, $AB, $76,
    $CA, $82, $C9, $7D, $FA, $59, $47, $F0, $AD, $D4, $A2, $AF, $9C, $A4, $72, $C0,
    $B7, $FD, $93, $26, $36, $3F, $F7, $CC, $34, $A5, $E5, $F1, $71, $D8, $31, $15,
    $04, $C7, $23, $C3, $18, $96, $05, $9A, $07, $12, $80, $E2, $EB, $27, $B2, $75,
    $09, $83, $2C, $1A, $1B, $6E, $5A, $A0, $52, $3B, $D6, $B3, $29, $E3, $2F, $84,
    $53, $D1, $00, $ED, $20, $FC, $B1, $5B, $6A, $CB, $BE, $39, $4A, $4C, $58, $CF,
    $D0, $EF, $AA, $FB, $43, $4D, $33, $85, $45, $F9, $02, $7F, $50, $3C, $9F, $A8,
    $51, $A3, $40, $8F, $92, $9D, $38, $F5, $BC, $B6, $DA, $21, $10, $FF, $F3, $D2,
    $CD, $0C, $13, $EC, $5F, $97, $44, $17, $C4, $A7, $7E, $3D, $64, $5D, $19, $73,
    $60, $81, $4F, $DC, $22, $2A, $90, $88, $46, $EE, $B8, $14, $DE, $5E, $0B, $DB,
    $E0, $32, $3A, $0A, $49, $06, $24, $5C, $C2, $D3, $AC, $62, $91, $95, $E4, $79,
    $E7, $C8, $37, $6D, $8D, $D5, $4E, $A9, $6C, $56, $F4, $EA, $65, $7A, $AE, $08,
    $BA, $78, $25, $2E, $1C, $A6, $B4, $C6, $E8, $DD, $74, $1F, $4B, $BD, $8B, $8A,
    $70, $3E, $B5, $66, $48, $03, $F6, $0E, $61, $35, $57, $B9, $86, $C1, $1D, $9E,
    $E1, $F8, $98, $11, $69, $D9, $8E, $94, $9B, $1E, $87, $E9, $CE, $55, $28, $DF,
    $8C, $A1, $89, $0D, $BF, $E6, $42, $68, $41, $99, $2D, $0F, $B0, $54, $BB, $16);

  RDLInvSBox: array[$00..$FF] of byte =
    ($52, $09, $6A, $D5, $30, $36, $A5, $38, $BF, $40, $A3, $9E, $81, $F3, $D7, $FB,
    $7C, $E3, $39, $82, $9B, $2F, $FF, $87, $34, $8E, $43, $44, $C4, $DE, $E9, $CB,
    $54, $7B, $94, $32, $A6, $C2, $23, $3D, $EE, $4C, $95, $0B, $42, $FA, $C3, $4E,
    $08, $2E, $A1, $66, $28, $D9, $24, $B2, $76, $5B, $A2, $49, $6D, $8B, $D1, $25,
    $72, $F8, $F6, $64, $86, $68, $98, $16, $D4, $A4, $5C, $CC, $5D, $65, $B6, $92,
    $6C, $70, $48, $50, $FD, $ED, $B9, $DA, $5E, $15, $46, $57, $A7, $8D, $9D, $84,
    $90, $D8, $AB, $00, $8C, $BC, $D3, $0A, $F7, $E4, $58, $05, $B8, $B3, $45, $06,
    $D0, $2C, $1E, $8F, $CA, $3F, $0F, $02, $C1, $AF, $BD, $03, $01, $13, $8A, $6B,
    $3A, $91, $11, $41, $4F, $67, $DC, $EA, $97, $F2, $CF, $CE, $F0, $B4, $E6, $73,
    $96, $AC, $74, $22, $E7, $AD, $35, $85, $E2, $F9, $37, $E8, $1C, $75, $DF, $6E,
    $47, $F1, $1A, $71, $1D, $29, $C5, $89, $6F, $B7, $62, $0E, $AA, $18, $BE, $1B,
    $FC, $56, $3E, $4B, $C6, $D2, $79, $20, $9A, $DB, $C0, $FE, $78, $CD, $5A, $F4,
    $1F, $DD, $A8, $33, $88, $07, $C7, $31, $B1, $12, $10, $59, $27, $80, $EC, $5F,
    $60, $51, $7F, $A9, $19, $B5, $4A, $0D, $2D, $E5, $7A, $9F, $93, $C9, $9C, $EF,
    $A0, $E0, $3B, $4D, $AE, $2A, $F5, $B0, $C8, $EB, $BB, $3C, $83, $53, $99, $61,
    $17, $2B, $04, $7E, $BA, $77, $D6, $26, $E1, $69, $14, $63, $55, $21, $0C, $7D);

  RCon: array[1..MaxRDLRounds] of DWord =
    ($00000001, $00000002, $00000004, $00000008, $00000010, $00000020, $00000040,
    $00000080, $0000001B, $00000036, $0000006C, $000000D8, $000000AB, $0000004D);

  RDL_T0: array[byte] of DWord =
    ($A56363C6, $847C7CF8, $997777EE, $8D7B7BF6, $0DF2F2FF, $BD6B6BD6, $B16F6FDE, $54C5C591,
    $50303060, $03010102, $A96767CE, $7D2B2B56, $19FEFEE7, $62D7D7B5, $E6ABAB4D, $9A7676EC,
    $45CACA8F, $9D82821F, $40C9C989, $877D7DFA, $15FAFAEF, $EB5959B2, $C947478E, $0BF0F0FB,
    $ECADAD41, $67D4D4B3, $FDA2A25F, $EAAFAF45, $BF9C9C23, $F7A4A453, $967272E4, $5BC0C09B,
    $C2B7B775, $1CFDFDE1, $AE93933D, $6A26264C, $5A36366C, $413F3F7E, $02F7F7F5, $4FCCCC83,
    $5C343468, $F4A5A551, $34E5E5D1, $08F1F1F9, $937171E2, $73D8D8AB, $53313162, $3F15152A,
    $0C040408, $52C7C795, $65232346, $5EC3C39D, $28181830, $A1969637, $0F05050A, $B59A9A2F,
    $0907070E, $36121224, $9B80801B, $3DE2E2DF, $26EBEBCD, $6927274E, $CDB2B27F, $9F7575EA,
    $1B090912, $9E83831D, $742C2C58, $2E1A1A34, $2D1B1B36, $B26E6EDC, $EE5A5AB4, $FBA0A05B,
    $F65252A4, $4D3B3B76, $61D6D6B7, $CEB3B37D, $7B292952, $3EE3E3DD, $712F2F5E, $97848413,
    $F55353A6, $68D1D1B9, $00000000, $2CEDEDC1, $60202040, $1FFCFCE3, $C8B1B179, $ED5B5BB6,
    $BE6A6AD4, $46CBCB8D, $D9BEBE67, $4B393972, $DE4A4A94, $D44C4C98, $E85858B0, $4ACFCF85,
    $6BD0D0BB, $2AEFEFC5, $E5AAAA4F, $16FBFBED, $C5434386, $D74D4D9A, $55333366, $94858511,
    $CF45458A, $10F9F9E9, $06020204, $817F7FFE, $F05050A0, $443C3C78, $BA9F9F25, $E3A8A84B,
    $F35151A2, $FEA3A35D, $C0404080, $8A8F8F05, $AD92923F, $BC9D9D21, $48383870, $04F5F5F1,
    $DFBCBC63, $C1B6B677, $75DADAAF, $63212142, $30101020, $1AFFFFE5, $0EF3F3FD, $6DD2D2BF,
    $4CCDCD81, $140C0C18, $35131326, $2FECECC3, $E15F5FBE, $A2979735, $CC444488, $3917172E,
    $57C4C493, $F2A7A755, $827E7EFC, $473D3D7A, $AC6464C8, $E75D5DBA, $2B191932, $957373E6,
    $A06060C0, $98818119, $D14F4F9E, $7FDCDCA3, $66222244, $7E2A2A54, $AB90903B, $8388880B,
    $CA46468C, $29EEEEC7, $D3B8B86B, $3C141428, $79DEDEA7, $E25E5EBC, $1D0B0B16, $76DBDBAD,
    $3BE0E0DB, $56323264, $4E3A3A74, $1E0A0A14, $DB494992, $0A06060C, $6C242448, $E45C5CB8,
    $5DC2C29F, $6ED3D3BD, $EFACAC43, $A66262C4, $A8919139, $A4959531, $37E4E4D3, $8B7979F2,
    $32E7E7D5, $43C8C88B, $5937376E, $B76D6DDA, $8C8D8D01, $64D5D5B1, $D24E4E9C, $E0A9A949,
    $B46C6CD8, $FA5656AC, $07F4F4F3, $25EAEACF, $AF6565CA, $8E7A7AF4, $E9AEAE47, $18080810,
    $D5BABA6F, $887878F0, $6F25254A, $722E2E5C, $241C1C38, $F1A6A657, $C7B4B473, $51C6C697,
    $23E8E8CB, $7CDDDDA1, $9C7474E8, $211F1F3E, $DD4B4B96, $DCBDBD61, $868B8B0D, $858A8A0F,
    $907070E0, $423E3E7C, $C4B5B571, $AA6666CC, $D8484890, $05030306, $01F6F6F7, $120E0E1C,
    $A36161C2, $5F35356A, $F95757AE, $D0B9B969, $91868617, $58C1C199, $271D1D3A, $B99E9E27,
    $38E1E1D9, $13F8F8EB, $B398982B, $33111122, $BB6969D2, $70D9D9A9, $898E8E07, $A7949433,
    $B69B9B2D, $221E1E3C, $92878715, $20E9E9C9, $49CECE87, $FF5555AA, $78282850, $7ADFDFA5,
    $8F8C8C03, $F8A1A159, $80898909, $170D0D1A, $DABFBF65, $31E6E6D7, $C6424284, $B86868D0,
    $C3414182, $B0999929, $772D2D5A, $110F0F1E, $CBB0B07B, $FC5454A8, $D6BBBB6D, $3A16162C);

  RDL_T1: array[byte] of DWord =
    ($6363C6A5, $7C7CF884, $7777EE99, $7B7BF68D, $F2F2FF0D, $6B6BD6BD, $6F6FDEB1, $C5C59154,
    $30306050, $01010203, $6767CEA9, $2B2B567D, $FEFEE719, $D7D7B562, $ABAB4DE6, $7676EC9A,
    $CACA8F45, $82821F9D, $C9C98940, $7D7DFA87, $FAFAEF15, $5959B2EB, $47478EC9, $F0F0FB0B,
    $ADAD41EC, $D4D4B367, $A2A25FFD, $AFAF45EA, $9C9C23BF, $A4A453F7, $7272E496, $C0C09B5B,
    $B7B775C2, $FDFDE11C, $93933DAE, $26264C6A, $36366C5A, $3F3F7E41, $F7F7F502, $CCCC834F,
    $3434685C, $A5A551F4, $E5E5D134, $F1F1F908, $7171E293, $D8D8AB73, $31316253, $15152A3F,
    $0404080C, $C7C79552, $23234665, $C3C39D5E, $18183028, $969637A1, $05050A0F, $9A9A2FB5,
    $07070E09, $12122436, $80801B9B, $E2E2DF3D, $EBEBCD26, $27274E69, $B2B27FCD, $7575EA9F,
    $0909121B, $83831D9E, $2C2C5874, $1A1A342E, $1B1B362D, $6E6EDCB2, $5A5AB4EE, $A0A05BFB,
    $5252A4F6, $3B3B764D, $D6D6B761, $B3B37DCE, $2929527B, $E3E3DD3E, $2F2F5E71, $84841397,
    $5353A6F5, $D1D1B968, $00000000, $EDEDC12C, $20204060, $FCFCE31F, $B1B179C8, $5B5BB6ED,
    $6A6AD4BE, $CBCB8D46, $BEBE67D9, $3939724B, $4A4A94DE, $4C4C98D4, $5858B0E8, $CFCF854A,
    $D0D0BB6B, $EFEFC52A, $AAAA4FE5, $FBFBED16, $434386C5, $4D4D9AD7, $33336655, $85851194,
    $45458ACF, $F9F9E910, $02020406, $7F7FFE81, $5050A0F0, $3C3C7844, $9F9F25BA, $A8A84BE3,
    $5151A2F3, $A3A35DFE, $404080C0, $8F8F058A, $92923FAD, $9D9D21BC, $38387048, $F5F5F104,
    $BCBC63DF, $B6B677C1, $DADAAF75, $21214263, $10102030, $FFFFE51A, $F3F3FD0E, $D2D2BF6D,
    $CDCD814C, $0C0C1814, $13132635, $ECECC32F, $5F5FBEE1, $979735A2, $444488CC, $17172E39,
    $C4C49357, $A7A755F2, $7E7EFC82, $3D3D7A47, $6464C8AC, $5D5DBAE7, $1919322B, $7373E695,
    $6060C0A0, $81811998, $4F4F9ED1, $DCDCA37F, $22224466, $2A2A547E, $90903BAB, $88880B83,
    $46468CCA, $EEEEC729, $B8B86BD3, $1414283C, $DEDEA779, $5E5EBCE2, $0B0B161D, $DBDBAD76,
    $E0E0DB3B, $32326456, $3A3A744E, $0A0A141E, $494992DB, $06060C0A, $2424486C, $5C5CB8E4,
    $C2C29F5D, $D3D3BD6E, $ACAC43EF, $6262C4A6, $919139A8, $959531A4, $E4E4D337, $7979F28B,
    $E7E7D532, $C8C88B43, $37376E59, $6D6DDAB7, $8D8D018C, $D5D5B164, $4E4E9CD2, $A9A949E0,
    $6C6CD8B4, $5656ACFA, $F4F4F307, $EAEACF25, $6565CAAF, $7A7AF48E, $AEAE47E9, $08081018,
    $BABA6FD5, $7878F088, $25254A6F, $2E2E5C72, $1C1C3824, $A6A657F1, $B4B473C7, $C6C69751,
    $E8E8CB23, $DDDDA17C, $7474E89C, $1F1F3E21, $4B4B96DD, $BDBD61DC, $8B8B0D86, $8A8A0F85,
    $7070E090, $3E3E7C42, $B5B571C4, $6666CCAA, $484890D8, $03030605, $F6F6F701, $0E0E1C12,
    $6161C2A3, $35356A5F, $5757AEF9, $B9B969D0, $86861791, $C1C19958, $1D1D3A27, $9E9E27B9,
    $E1E1D938, $F8F8EB13, $98982BB3, $11112233, $6969D2BB, $D9D9A970, $8E8E0789, $949433A7,
    $9B9B2DB6, $1E1E3C22, $87871592, $E9E9C920, $CECE8749, $5555AAFF, $28285078, $DFDFA57A,
    $8C8C038F, $A1A159F8, $89890980, $0D0D1A17, $BFBF65DA, $E6E6D731, $424284C6, $6868D0B8,
    $414182C3, $999929B0, $2D2D5A77, $0F0F1E11, $B0B07BCB, $5454A8FC, $BBBB6DD6, $16162C3A);

  RDL_T2: array[byte] of DWord =
    ($63C6A563, $7CF8847C, $77EE9977, $7BF68D7B, $F2FF0DF2, $6BD6BD6B, $6FDEB16F, $C59154C5,
    $30605030, $01020301, $67CEA967, $2B567D2B, $FEE719FE, $D7B562D7, $AB4DE6AB, $76EC9A76,
    $CA8F45CA, $821F9D82, $C98940C9, $7DFA877D, $FAEF15FA, $59B2EB59, $478EC947, $F0FB0BF0,
    $AD41ECAD, $D4B367D4, $A25FFDA2, $AF45EAAF, $9C23BF9C, $A453F7A4, $72E49672, $C09B5BC0,
    $B775C2B7, $FDE11CFD, $933DAE93, $264C6A26, $366C5A36, $3F7E413F, $F7F502F7, $CC834FCC,
    $34685C34, $A551F4A5, $E5D134E5, $F1F908F1, $71E29371, $D8AB73D8, $31625331, $152A3F15,
    $04080C04, $C79552C7, $23466523, $C39D5EC3, $18302818, $9637A196, $050A0F05, $9A2FB59A,
    $070E0907, $12243612, $801B9B80, $E2DF3DE2, $EBCD26EB, $274E6927, $B27FCDB2, $75EA9F75,
    $09121B09, $831D9E83, $2C58742C, $1A342E1A, $1B362D1B, $6EDCB26E, $5AB4EE5A, $A05BFBA0,
    $52A4F652, $3B764D3B, $D6B761D6, $B37DCEB3, $29527B29, $E3DD3EE3, $2F5E712F, $84139784,
    $53A6F553, $D1B968D1, $00000000, $EDC12CED, $20406020, $FCE31FFC, $B179C8B1, $5BB6ED5B,
    $6AD4BE6A, $CB8D46CB, $BE67D9BE, $39724B39, $4A94DE4A, $4C98D44C, $58B0E858, $CF854ACF,
    $D0BB6BD0, $EFC52AEF, $AA4FE5AA, $FBED16FB, $4386C543, $4D9AD74D, $33665533, $85119485,
    $458ACF45, $F9E910F9, $02040602, $7FFE817F, $50A0F050, $3C78443C, $9F25BA9F, $A84BE3A8,
    $51A2F351, $A35DFEA3, $4080C040, $8F058A8F, $923FAD92, $9D21BC9D, $38704838, $F5F104F5,
    $BC63DFBC, $B677C1B6, $DAAF75DA, $21426321, $10203010, $FFE51AFF, $F3FD0EF3, $D2BF6DD2,
    $CD814CCD, $0C18140C, $13263513, $ECC32FEC, $5FBEE15F, $9735A297, $4488CC44, $172E3917,
    $C49357C4, $A755F2A7, $7EFC827E, $3D7A473D, $64C8AC64, $5DBAE75D, $19322B19, $73E69573,
    $60C0A060, $81199881, $4F9ED14F, $DCA37FDC, $22446622, $2A547E2A, $903BAB90, $880B8388,
    $468CCA46, $EEC729EE, $B86BD3B8, $14283C14, $DEA779DE, $5EBCE25E, $0B161D0B, $DBAD76DB,
    $E0DB3BE0, $32645632, $3A744E3A, $0A141E0A, $4992DB49, $060C0A06, $24486C24, $5CB8E45C,
    $C29F5DC2, $D3BD6ED3, $AC43EFAC, $62C4A662, $9139A891, $9531A495, $E4D337E4, $79F28B79,
    $E7D532E7, $C88B43C8, $376E5937, $6DDAB76D, $8D018C8D, $D5B164D5, $4E9CD24E, $A949E0A9,
    $6CD8B46C, $56ACFA56, $F4F307F4, $EACF25EA, $65CAAF65, $7AF48E7A, $AE47E9AE, $08101808,
    $BA6FD5BA, $78F08878, $254A6F25, $2E5C722E, $1C38241C, $A657F1A6, $B473C7B4, $C69751C6,
    $E8CB23E8, $DDA17CDD, $74E89C74, $1F3E211F, $4B96DD4B, $BD61DCBD, $8B0D868B, $8A0F858A,
    $70E09070, $3E7C423E, $B571C4B5, $66CCAA66, $4890D848, $03060503, $F6F701F6, $0E1C120E,
    $61C2A361, $356A5F35, $57AEF957, $B969D0B9, $86179186, $C19958C1, $1D3A271D, $9E27B99E,
    $E1D938E1, $F8EB13F8, $982BB398, $11223311, $69D2BB69, $D9A970D9, $8E07898E, $9433A794,
    $9B2DB69B, $1E3C221E, $87159287, $E9C920E9, $CE8749CE, $55AAFF55, $28507828, $DFA57ADF,
    $8C038F8C, $A159F8A1, $89098089, $0D1A170D, $BF65DABF, $E6D731E6, $4284C642, $68D0B868,
    $4182C341, $9929B099, $2D5A772D, $0F1E110F, $B07BCBB0, $54A8FC54, $BB6DD6BB, $162C3A16);

  RDL_T3: array[byte] of DWord =
    ($C6A56363, $F8847C7C, $EE997777, $F68D7B7B, $FF0DF2F2, $D6BD6B6B, $DEB16F6F, $9154C5C5,
    $60503030, $02030101, $CEA96767, $567D2B2B, $E719FEFE, $B562D7D7, $4DE6ABAB, $EC9A7676,
    $8F45CACA, $1F9D8282, $8940C9C9, $FA877D7D, $EF15FAFA, $B2EB5959, $8EC94747, $FB0BF0F0,
    $41ECADAD, $B367D4D4, $5FFDA2A2, $45EAAFAF, $23BF9C9C, $53F7A4A4, $E4967272, $9B5BC0C0,
    $75C2B7B7, $E11CFDFD, $3DAE9393, $4C6A2626, $6C5A3636, $7E413F3F, $F502F7F7, $834FCCCC,
    $685C3434, $51F4A5A5, $D134E5E5, $F908F1F1, $E2937171, $AB73D8D8, $62533131, $2A3F1515,
    $080C0404, $9552C7C7, $46652323, $9D5EC3C3, $30281818, $37A19696, $0A0F0505, $2FB59A9A,
    $0E090707, $24361212, $1B9B8080, $DF3DE2E2, $CD26EBEB, $4E692727, $7FCDB2B2, $EA9F7575,
    $121B0909, $1D9E8383, $58742C2C, $342E1A1A, $362D1B1B, $DCB26E6E, $B4EE5A5A, $5BFBA0A0,
    $A4F65252, $764D3B3B, $B761D6D6, $7DCEB3B3, $527B2929, $DD3EE3E3, $5E712F2F, $13978484,
    $A6F55353, $B968D1D1, $00000000, $C12CEDED, $40602020, $E31FFCFC, $79C8B1B1, $B6ED5B5B,
    $D4BE6A6A, $8D46CBCB, $67D9BEBE, $724B3939, $94DE4A4A, $98D44C4C, $B0E85858, $854ACFCF,
    $BB6BD0D0, $C52AEFEF, $4FE5AAAA, $ED16FBFB, $86C54343, $9AD74D4D, $66553333, $11948585,
    $8ACF4545, $E910F9F9, $04060202, $FE817F7F, $A0F05050, $78443C3C, $25BA9F9F, $4BE3A8A8,
    $A2F35151, $5DFEA3A3, $80C04040, $058A8F8F, $3FAD9292, $21BC9D9D, $70483838, $F104F5F5,
    $63DFBCBC, $77C1B6B6, $AF75DADA, $42632121, $20301010, $E51AFFFF, $FD0EF3F3, $BF6DD2D2,
    $814CCDCD, $18140C0C, $26351313, $C32FECEC, $BEE15F5F, $35A29797, $88CC4444, $2E391717,
    $9357C4C4, $55F2A7A7, $FC827E7E, $7A473D3D, $C8AC6464, $BAE75D5D, $322B1919, $E6957373,
    $C0A06060, $19988181, $9ED14F4F, $A37FDCDC, $44662222, $547E2A2A, $3BAB9090, $0B838888,
    $8CCA4646, $C729EEEE, $6BD3B8B8, $283C1414, $A779DEDE, $BCE25E5E, $161D0B0B, $AD76DBDB,
    $DB3BE0E0, $64563232, $744E3A3A, $141E0A0A, $92DB4949, $0C0A0606, $486C2424, $B8E45C5C,
    $9F5DC2C2, $BD6ED3D3, $43EFACAC, $C4A66262, $39A89191, $31A49595, $D337E4E4, $F28B7979,
    $D532E7E7, $8B43C8C8, $6E593737, $DAB76D6D, $018C8D8D, $B164D5D5, $9CD24E4E, $49E0A9A9,
    $D8B46C6C, $ACFA5656, $F307F4F4, $CF25EAEA, $CAAF6565, $F48E7A7A, $47E9AEAE, $10180808,
    $6FD5BABA, $F0887878, $4A6F2525, $5C722E2E, $38241C1C, $57F1A6A6, $73C7B4B4, $9751C6C6,
    $CB23E8E8, $A17CDDDD, $E89C7474, $3E211F1F, $96DD4B4B, $61DCBDBD, $0D868B8B, $0F858A8A,
    $E0907070, $7C423E3E, $71C4B5B5, $CCAA6666, $90D84848, $06050303, $F701F6F6, $1C120E0E,
    $C2A36161, $6A5F3535, $AEF95757, $69D0B9B9, $17918686, $9958C1C1, $3A271D1D, $27B99E9E,
    $D938E1E1, $EB13F8F8, $2BB39898, $22331111, $D2BB6969, $A970D9D9, $07898E8E, $33A79494,
    $2DB69B9B, $3C221E1E, $15928787, $C920E9E9, $8749CECE, $AAFF5555, $50782828, $A57ADFDF,
    $038F8C8C, $59F8A1A1, $09808989, $1A170D0D, $65DABFBF, $D731E6E6, $84C64242, $D0B86868,
    $82C34141, $29B09999, $5A772D2D, $1E110F0F, $7BCBB0B0, $A8FC5454, $6DD6BBBB, $2C3A1616);

  RDL_InvT0: array[byte] of DWord =
    ($00000000, $0B0D090E, $161A121C, $1D171B12, $2C342438, $27392D36, $3A2E3624, $31233F2A,
    $58684870, $5365417E, $4E725A6C, $457F5362, $745C6C48, $7F516546, $62467E54, $694B775A,
    $B0D090E0, $BBDD99EE, $A6CA82FC, $ADC78BF2, $9CE4B4D8, $97E9BDD6, $8AFEA6C4, $81F3AFCA,
    $E8B8D890, $E3B5D19E, $FEA2CA8C, $F5AFC382, $C48CFCA8, $CF81F5A6, $D296EEB4, $D99BE7BA,
    $7BBB3BDB, $70B632D5, $6DA129C7, $66AC20C9, $578F1FE3, $5C8216ED, $41950DFF, $4A9804F1,
    $23D373AB, $28DE7AA5, $35C961B7, $3EC468B9, $0FE75793, $04EA5E9D, $19FD458F, $12F04C81,
    $CB6BAB3B, $C066A235, $DD71B927, $D67CB029, $E75F8F03, $EC52860D, $F1459D1F, $FA489411,
    $9303E34B, $980EEA45, $8519F157, $8E14F859, $BF37C773, $B43ACE7D, $A92DD56F, $A220DC61,
    $F66D76AD, $FD607FA3, $E07764B1, $EB7A6DBF, $DA595295, $D1545B9B, $CC434089, $C74E4987,
    $AE053EDD, $A50837D3, $B81F2CC1, $B31225CF, $82311AE5, $893C13EB, $942B08F9, $9F2601F7,
    $46BDE64D, $4DB0EF43, $50A7F451, $5BAAFD5F, $6A89C275, $6184CB7B, $7C93D069, $779ED967,
    $1ED5AE3D, $15D8A733, $08CFBC21, $03C2B52F, $32E18A05, $39EC830B, $24FB9819, $2FF69117,
    $8DD64D76, $86DB4478, $9BCC5F6A, $90C15664, $A1E2694E, $AAEF6040, $B7F87B52, $BCF5725C,
    $D5BE0506, $DEB30C08, $C3A4171A, $C8A91E14, $F98A213E, $F2872830, $EF903322, $E49D3A2C,
    $3D06DD96, $360BD498, $2B1CCF8A, $2011C684, $1132F9AE, $1A3FF0A0, $0728EBB2, $0C25E2BC,
    $656E95E6, $6E639CE8, $737487FA, $78798EF4, $495AB1DE, $4257B8D0, $5F40A3C2, $544DAACC,
    $F7DAEC41, $FCD7E54F, $E1C0FE5D, $EACDF753, $DBEEC879, $D0E3C177, $CDF4DA65, $C6F9D36B,
    $AFB2A431, $A4BFAD3F, $B9A8B62D, $B2A5BF23, $83868009, $888B8907, $959C9215, $9E919B1B,
    $470A7CA1, $4C0775AF, $51106EBD, $5A1D67B3, $6B3E5899, $60335197, $7D244A85, $7629438B,
    $1F6234D1, $146F3DDF, $097826CD, $02752FC3, $335610E9, $385B19E7, $254C02F5, $2E410BFB,
    $8C61D79A, $876CDE94, $9A7BC586, $9176CC88, $A055F3A2, $AB58FAAC, $B64FE1BE, $BD42E8B0,
    $D4099FEA, $DF0496E4, $C2138DF6, $C91E84F8, $F83DBBD2, $F330B2DC, $EE27A9CE, $E52AA0C0,
    $3CB1477A, $37BC4E74, $2AAB5566, $21A65C68, $10856342, $1B886A4C, $069F715E, $0D927850,
    $64D90F0A, $6FD40604, $72C31D16, $79CE1418, $48ED2B32, $43E0223C, $5EF7392E, $55FA3020,
    $01B79AEC, $0ABA93E2, $17AD88F0, $1CA081FE, $2D83BED4, $268EB7DA, $3B99ACC8, $3094A5C6,
    $59DFD29C, $52D2DB92, $4FC5C080, $44C8C98E, $75EBF6A4, $7EE6FFAA, $63F1E4B8, $68FCEDB6,
    $B1670A0C, $BA6A0302, $A77D1810, $AC70111E, $9D532E34, $965E273A, $8B493C28, $80443526,
    $E90F427C, $E2024B72, $FF155060, $F418596E, $C53B6644, $CE366F4A, $D3217458, $D82C7D56,
    $7A0CA137, $7101A839, $6C16B32B, $671BBA25, $5638850F, $5D358C01, $40229713, $4B2F9E1D,
    $2264E947, $2969E049, $347EFB5B, $3F73F255, $0E50CD7F, $055DC471, $184ADF63, $1347D66D,
    $CADC31D7, $C1D138D9, $DCC623CB, $D7CB2AC5, $E6E815EF, $EDE51CE1, $F0F207F3, $FBFF0EFD,
    $92B479A7, $99B970A9, $84AE6BBB, $8FA362B5, $BE805D9F, $B58D5491, $A89A4F83, $A397468D);

  RDL_InvT1: array[byte] of DWord =
    ($00000000, $0D090E0B, $1A121C16, $171B121D, $3424382C, $392D3627, $2E36243A, $233F2A31,
    $68487058, $65417E53, $725A6C4E, $7F536245, $5C6C4874, $5165467F, $467E5462, $4B775A69,
    $D090E0B0, $DD99EEBB, $CA82FCA6, $C78BF2AD, $E4B4D89C, $E9BDD697, $FEA6C48A, $F3AFCA81,
    $B8D890E8, $B5D19EE3, $A2CA8CFE, $AFC382F5, $8CFCA8C4, $81F5A6CF, $96EEB4D2, $9BE7BAD9,
    $BB3BDB7B, $B632D570, $A129C76D, $AC20C966, $8F1FE357, $8216ED5C, $950DFF41, $9804F14A,
    $D373AB23, $DE7AA528, $C961B735, $C468B93E, $E757930F, $EA5E9D04, $FD458F19, $F04C8112,
    $6BAB3BCB, $66A235C0, $71B927DD, $7CB029D6, $5F8F03E7, $52860DEC, $459D1FF1, $489411FA,
    $03E34B93, $0EEA4598, $19F15785, $14F8598E, $37C773BF, $3ACE7DB4, $2DD56FA9, $20DC61A2,
    $6D76ADF6, $607FA3FD, $7764B1E0, $7A6DBFEB, $595295DA, $545B9BD1, $434089CC, $4E4987C7,
    $053EDDAE, $0837D3A5, $1F2CC1B8, $1225CFB3, $311AE582, $3C13EB89, $2B08F994, $2601F79F,
    $BDE64D46, $B0EF434D, $A7F45150, $AAFD5F5B, $89C2756A, $84CB7B61, $93D0697C, $9ED96777,
    $D5AE3D1E, $D8A73315, $CFBC2108, $C2B52F03, $E18A0532, $EC830B39, $FB981924, $F691172F,
    $D64D768D, $DB447886, $CC5F6A9B, $C1566490, $E2694EA1, $EF6040AA, $F87B52B7, $F5725CBC,
    $BE0506D5, $B30C08DE, $A4171AC3, $A91E14C8, $8A213EF9, $872830F2, $903322EF, $9D3A2CE4,
    $06DD963D, $0BD49836, $1CCF8A2B, $11C68420, $32F9AE11, $3FF0A01A, $28EBB207, $25E2BC0C,
    $6E95E665, $639CE86E, $7487FA73, $798EF478, $5AB1DE49, $57B8D042, $40A3C25F, $4DAACC54,
    $DAEC41F7, $D7E54FFC, $C0FE5DE1, $CDF753EA, $EEC879DB, $E3C177D0, $F4DA65CD, $F9D36BC6,
    $B2A431AF, $BFAD3FA4, $A8B62DB9, $A5BF23B2, $86800983, $8B890788, $9C921595, $919B1B9E,
    $0A7CA147, $0775AF4C, $106EBD51, $1D67B35A, $3E58996B, $33519760, $244A857D, $29438B76,
    $6234D11F, $6F3DDF14, $7826CD09, $752FC302, $5610E933, $5B19E738, $4C02F525, $410BFB2E,
    $61D79A8C, $6CDE9487, $7BC5869A, $76CC8891, $55F3A2A0, $58FAACAB, $4FE1BEB6, $42E8B0BD,
    $099FEAD4, $0496E4DF, $138DF6C2, $1E84F8C9, $3DBBD2F8, $30B2DCF3, $27A9CEEE, $2AA0C0E5,
    $B1477A3C, $BC4E7437, $AB55662A, $A65C6821, $85634210, $886A4C1B, $9F715E06, $9278500D,
    $D90F0A64, $D406046F, $C31D1672, $CE141879, $ED2B3248, $E0223C43, $F7392E5E, $FA302055,
    $B79AEC01, $BA93E20A, $AD88F017, $A081FE1C, $83BED42D, $8EB7DA26, $99ACC83B, $94A5C630,
    $DFD29C59, $D2DB9252, $C5C0804F, $C8C98E44, $EBF6A475, $E6FFAA7E, $F1E4B863, $FCEDB668,
    $670A0CB1, $6A0302BA, $7D1810A7, $70111EAC, $532E349D, $5E273A96, $493C288B, $44352680,
    $0F427CE9, $024B72E2, $155060FF, $18596EF4, $3B6644C5, $366F4ACE, $217458D3, $2C7D56D8,
    $0CA1377A, $01A83971, $16B32B6C, $1BBA2567, $38850F56, $358C015D, $22971340, $2F9E1D4B,
    $64E94722, $69E04929, $7EFB5B34, $73F2553F, $50CD7F0E, $5DC47105, $4ADF6318, $47D66D13,
    $DC31D7CA, $D138D9C1, $C623CBDC, $CB2AC5D7, $E815EFE6, $E51CE1ED, $F207F3F0, $FF0EFDFB,
    $B479A792, $B970A999, $AE6BBB84, $A362B58F, $805D9FBE, $8D5491B5, $9A4F83A8, $97468DA3);

  RDL_InvT2: array[byte] of DWord =
    ($00000000, $090E0B0D, $121C161A, $1B121D17, $24382C34, $2D362739, $36243A2E, $3F2A3123,
    $48705868, $417E5365, $5A6C4E72, $5362457F, $6C48745C, $65467F51, $7E546246, $775A694B,
    $90E0B0D0, $99EEBBDD, $82FCA6CA, $8BF2ADC7, $B4D89CE4, $BDD697E9, $A6C48AFE, $AFCA81F3,
    $D890E8B8, $D19EE3B5, $CA8CFEA2, $C382F5AF, $FCA8C48C, $F5A6CF81, $EEB4D296, $E7BAD99B,
    $3BDB7BBB, $32D570B6, $29C76DA1, $20C966AC, $1FE3578F, $16ED5C82, $0DFF4195, $04F14A98,
    $73AB23D3, $7AA528DE, $61B735C9, $68B93EC4, $57930FE7, $5E9D04EA, $458F19FD, $4C8112F0,
    $AB3BCB6B, $A235C066, $B927DD71, $B029D67C, $8F03E75F, $860DEC52, $9D1FF145, $9411FA48,
    $E34B9303, $EA45980E, $F1578519, $F8598E14, $C773BF37, $CE7DB43A, $D56FA92D, $DC61A220,
    $76ADF66D, $7FA3FD60, $64B1E077, $6DBFEB7A, $5295DA59, $5B9BD154, $4089CC43, $4987C74E,
    $3EDDAE05, $37D3A508, $2CC1B81F, $25CFB312, $1AE58231, $13EB893C, $08F9942B, $01F79F26,
    $E64D46BD, $EF434DB0, $F45150A7, $FD5F5BAA, $C2756A89, $CB7B6184, $D0697C93, $D967779E,
    $AE3D1ED5, $A73315D8, $BC2108CF, $B52F03C2, $8A0532E1, $830B39EC, $981924FB, $91172FF6,
    $4D768DD6, $447886DB, $5F6A9BCC, $566490C1, $694EA1E2, $6040AAEF, $7B52B7F8, $725CBCF5,
    $0506D5BE, $0C08DEB3, $171AC3A4, $1E14C8A9, $213EF98A, $2830F287, $3322EF90, $3A2CE49D,
    $DD963D06, $D498360B, $CF8A2B1C, $C6842011, $F9AE1132, $F0A01A3F, $EBB20728, $E2BC0C25,
    $95E6656E, $9CE86E63, $87FA7374, $8EF47879, $B1DE495A, $B8D04257, $A3C25F40, $AACC544D,
    $EC41F7DA, $E54FFCD7, $FE5DE1C0, $F753EACD, $C879DBEE, $C177D0E3, $DA65CDF4, $D36BC6F9,
    $A431AFB2, $AD3FA4BF, $B62DB9A8, $BF23B2A5, $80098386, $8907888B, $9215959C, $9B1B9E91,
    $7CA1470A, $75AF4C07, $6EBD5110, $67B35A1D, $58996B3E, $51976033, $4A857D24, $438B7629,
    $34D11F62, $3DDF146F, $26CD0978, $2FC30275, $10E93356, $19E7385B, $02F5254C, $0BFB2E41,
    $D79A8C61, $DE94876C, $C5869A7B, $CC889176, $F3A2A055, $FAACAB58, $E1BEB64F, $E8B0BD42,
    $9FEAD409, $96E4DF04, $8DF6C213, $84F8C91E, $BBD2F83D, $B2DCF330, $A9CEEE27, $A0C0E52A,
    $477A3CB1, $4E7437BC, $55662AAB, $5C6821A6, $63421085, $6A4C1B88, $715E069F, $78500D92,
    $0F0A64D9, $06046FD4, $1D1672C3, $141879CE, $2B3248ED, $223C43E0, $392E5EF7, $302055FA,
    $9AEC01B7, $93E20ABA, $88F017AD, $81FE1CA0, $BED42D83, $B7DA268E, $ACC83B99, $A5C63094,
    $D29C59DF, $DB9252D2, $C0804FC5, $C98E44C8, $F6A475EB, $FFAA7EE6, $E4B863F1, $EDB668FC,
    $0A0CB167, $0302BA6A, $1810A77D, $111EAC70, $2E349D53, $273A965E, $3C288B49, $35268044,
    $427CE90F, $4B72E202, $5060FF15, $596EF418, $6644C53B, $6F4ACE36, $7458D321, $7D56D82C,
    $A1377A0C, $A8397101, $B32B6C16, $BA25671B, $850F5638, $8C015D35, $97134022, $9E1D4B2F,
    $E9472264, $E0492969, $FB5B347E, $F2553F73, $CD7F0E50, $C471055D, $DF63184A, $D66D1347,
    $31D7CADC, $38D9C1D1, $23CBDCC6, $2AC5D7CB, $15EFE6E8, $1CE1EDE5, $07F3F0F2, $0EFDFBFF,
    $79A792B4, $70A999B9, $6BBB84AE, $62B58FA3, $5D9FBE80, $5491B58D, $4F83A89A, $468DA397);

  RDL_InvT3: array[byte] of DWord =
    ($00000000, $0E0B0D09, $1C161A12, $121D171B, $382C3424, $3627392D, $243A2E36, $2A31233F,
    $70586848, $7E536541, $6C4E725A, $62457F53, $48745C6C, $467F5165, $5462467E, $5A694B77,
    $E0B0D090, $EEBBDD99, $FCA6CA82, $F2ADC78B, $D89CE4B4, $D697E9BD, $C48AFEA6, $CA81F3AF,
    $90E8B8D8, $9EE3B5D1, $8CFEA2CA, $82F5AFC3, $A8C48CFC, $A6CF81F5, $B4D296EE, $BAD99BE7,
    $DB7BBB3B, $D570B632, $C76DA129, $C966AC20, $E3578F1F, $ED5C8216, $FF41950D, $F14A9804,
    $AB23D373, $A528DE7A, $B735C961, $B93EC468, $930FE757, $9D04EA5E, $8F19FD45, $8112F04C,
    $3BCB6BAB, $35C066A2, $27DD71B9, $29D67CB0, $03E75F8F, $0DEC5286, $1FF1459D, $11FA4894,
    $4B9303E3, $45980EEA, $578519F1, $598E14F8, $73BF37C7, $7DB43ACE, $6FA92DD5, $61A220DC,
    $ADF66D76, $A3FD607F, $B1E07764, $BFEB7A6D, $95DA5952, $9BD1545B, $89CC4340, $87C74E49,
    $DDAE053E, $D3A50837, $C1B81F2C, $CFB31225, $E582311A, $EB893C13, $F9942B08, $F79F2601,
    $4D46BDE6, $434DB0EF, $5150A7F4, $5F5BAAFD, $756A89C2, $7B6184CB, $697C93D0, $67779ED9,
    $3D1ED5AE, $3315D8A7, $2108CFBC, $2F03C2B5, $0532E18A, $0B39EC83, $1924FB98, $172FF691,
    $768DD64D, $7886DB44, $6A9BCC5F, $6490C156, $4EA1E269, $40AAEF60, $52B7F87B, $5CBCF572,
    $06D5BE05, $08DEB30C, $1AC3A417, $14C8A91E, $3EF98A21, $30F28728, $22EF9033, $2CE49D3A,
    $963D06DD, $98360BD4, $8A2B1CCF, $842011C6, $AE1132F9, $A01A3FF0, $B20728EB, $BC0C25E2,
    $E6656E95, $E86E639C, $FA737487, $F478798E, $DE495AB1, $D04257B8, $C25F40A3, $CC544DAA,
    $41F7DAEC, $4FFCD7E5, $5DE1C0FE, $53EACDF7, $79DBEEC8, $77D0E3C1, $65CDF4DA, $6BC6F9D3,
    $31AFB2A4, $3FA4BFAD, $2DB9A8B6, $23B2A5BF, $09838680, $07888B89, $15959C92, $1B9E919B,
    $A1470A7C, $AF4C0775, $BD51106E, $B35A1D67, $996B3E58, $97603351, $857D244A, $8B762943,
    $D11F6234, $DF146F3D, $CD097826, $C302752F, $E9335610, $E7385B19, $F5254C02, $FB2E410B,
    $9A8C61D7, $94876CDE, $869A7BC5, $889176CC, $A2A055F3, $ACAB58FA, $BEB64FE1, $B0BD42E8,
    $EAD4099F, $E4DF0496, $F6C2138D, $F8C91E84, $D2F83DBB, $DCF330B2, $CEEE27A9, $C0E52AA0,
    $7A3CB147, $7437BC4E, $662AAB55, $6821A65C, $42108563, $4C1B886A, $5E069F71, $500D9278,
    $0A64D90F, $046FD406, $1672C31D, $1879CE14, $3248ED2B, $3C43E022, $2E5EF739, $2055FA30,
    $EC01B79A, $E20ABA93, $F017AD88, $FE1CA081, $D42D83BE, $DA268EB7, $C83B99AC, $C63094A5,
    $9C59DFD2, $9252D2DB, $804FC5C0, $8E44C8C9, $A475EBF6, $AA7EE6FF, $B863F1E4, $B668FCED,
    $0CB1670A, $02BA6A03, $10A77D18, $1EAC7011, $349D532E, $3A965E27, $288B493C, $26804435,
    $7CE90F42, $72E2024B, $60FF1550, $6EF41859, $44C53B66, $4ACE366F, $58D32174, $56D82C7D,
    $377A0CA1, $397101A8, $2B6C16B3, $25671BBA, $0F563885, $015D358C, $13402297, $1D4B2F9E,
    $472264E9, $492969E0, $5B347EFB, $553F73F2, $7F0E50CD, $71055DC4, $63184ADF, $6D1347D6,
    $D7CADC31, $D9C1D138, $CBDCC623, $C5D7CB2A, $EFE6E815, $E1EDE51C, $F3F0F207, $FDFBFF0E,
    $A792B479, $A999B970, $BB84AE6B, $B58FA362, $9FBE805D, $91B58D54, $83A89A4F, $8DA39746);

  Pi2048: array [0..255] of byte = (
    $24, $3F, $6A, $88, $85, $A3, $08, $D3, $13, $19, $8A, $2E, $03, $70, $73, $44,
    $A4, $09, $38, $22, $29, $9F, $31, $D0, $08, $2E, $FA, $98, $EC, $4E, $6C, $89,
    $45, $28, $21, $E6, $38, $D0, $13, $77, $BE, $54, $66, $CF, $34, $E9, $0C, $6C,
    $C0, $AC, $29, $B7, $C9, $7C, $50, $DD, $3F, $84, $D5, $B5, $B5, $47, $09, $17,
    $92, $16, $D5, $D9, $89, $79, $FB, $1B, $D1, $31, $0B, $A6, $98, $DF, $B5, $AC,
    $2F, $FD, $72, $DB, $D0, $1A, $DF, $B7, $B8, $E1, $AF, $ED, $6A, $26, $7E, $96,
    $BA, $7C, $90, $45, $F1, $2C, $7F, $99, $24, $A1, $99, $47, $B3, $91, $6C, $F7,
    $08, $01, $F2, $E2, $85, $8E, $FC, $16, $63, $69, $20, $D8, $71, $57, $4E, $69,
    $A4, $58, $FE, $A3, $F4, $93, $3D, $7E, $0D, $95, $74, $8F, $72, $8E, $B6, $58,
    $71, $8B, $CD, $58, $82, $15, $4A, $EE, $7B, $54, $A4, $1D, $C2, $5A, $59, $B5,
    $9C, $30, $D5, $39, $2A, $F2, $60, $13, $C5, $D1, $B0, $23, $28, $60, $85, $F0,
    $CA, $41, $79, $18, $B8, $DB, $38, $EF, $8E, $79, $DC, $B0, $60, $3A, $18, $0E,
    $6C, $9E, $0E, $8B, $B0, $1E, $8A, $3E, $D7, $15, $77, $C1, $BD, $31, $4B, $27,
    $78, $AF, $2F, $DA, $55, $60, $5C, $60, $E6, $55, $25, $F3, $AA, $55, $AB, $94,
    $57, $48, $98, $62, $63, $E8, $14, $40, $55, $CA, $39, $6A, $2A, $AB, $10, $B6,
    $B4, $CC, $5C, $34, $11, $41, $E8, $CE, $A1, $54, $86, $AF, $7C, $72, $E9, $93);

  MaxStructSize = 1024 * 2000000;

  BCSalts: array [0..3] of DWord =
    ($55555555, $AAAAAAAA, $33333333, $CCCCCCCC);

  Lb64Table: array[0..63] of AnsiChar = (#65, #66, #67, #68, #69,
    #70, #71, #72, #73, #74, #75, #76, #77, #78, #79,
    #80, #81, #82, #83, #84, #85, #86, #87, #88, #89,
    #90, #97, #98, #99, #100, #101, #102, #103, #104, #105,
    #106, #107, #108, #109, #110, #111, #112, #113, #114, #115,
    #116, #117, #118, #119, #120, #121, #122, #48, #49, #50,
    #51, #52, #53, #54, #55, #56, #57, #43, #47);

  LbD64Table: array[43..122] of byte = ($3E, $7F, $7F, $7F, $3F, $34,
    $35, $36, $37, $38, $39, $3A, $3B, $3C, $3D, $7F, $7F, $7F, $7F,
    $7F, $7F, $7F, $00, $01, $02, $03, $04, $05, $06, $07, $08, $09,
    $0A, $0B, $0C, $0D, $0E, $0F, $10, $11, $12, $13, $14, $15, $16,
    $17, $18, $19, $7F, $7F, $7F, $7F, $7F, $7F, $1A, $1B, $1C, $1D,
    $1E, $1F, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $2A,
    $2B, $2C, $2D, $2E, $2F, $30, $31, $32, $33);

  { 5 magic numbers }
  SHA1_A = DWORD($67452301);
  SHA1_B = DWORD($EFCDAB89);
  SHA1_C = DWORD($98BADCFE);
  SHA1_D = DWORD($10325476);
  SHA1_E = DWORD($C3D2E1F0);
  { four rounds consts }
  SHA1_K1 = DWORD($5A827999);
  SHA1_K2 = DWORD($6ED9EBA1);
  SHA1_K3 = DWORD($8F1BBCDC);
  SHA1_K4 = DWORD($CA62C1D6);
  { Maskes used in byte swap }
  LBMASK_HI = DWORD($FF0000);
  LBMASK_LO = DWORD($FF00);

  RDLNb128 = 4;      { 128 bit block }
  RDLNb192 = 6;      { 192 bit block (not used) }
  RDLNb256 = 8;      { 256 bit block (not used) }

  RDLNk128 = 4;      { 128 bit key }
  RDLNk192 = 6;      { 192 bit key }
  RDLNk256 = 8;      { 256 bit key }

  tmp = 1;

  cLESS_THAN = shortint(-1);
  cEQUAL_TO = shortint(0);
  cGREATER_THAN = shortint(1);
  cPOSITIVE = True;
  cNEGATIVE = False;

  cBYTE_POSSIBLE_VALUES = 256;
  cDEFAULT_PRECISION = 64;
  cUSE_DEFAULT_PRECISION = 0;
  cDEFAULT_SIGN = cPOSITIVE;
  cDEFAULT_USED = 0;
  cAPPEND_ARRAY = 0;
  cPREPEND_ARRAY = 1;
  cDEFAULT_MAX_PRECISION = 256;

  cTotalSimplePrimes = (258 * 8);
  cTotalSimpleBytePrimes = 53;  { %80 elimination }
  cTotalSimple2KPrimes = 303;

  cMaxBigIntSize = SizeOf(TByteArray);

  SimplePrimes: array[0..pred(cTotalSimplePrimes)] of DWord = (       {!!.01}
    2, 3, 5, 7, 11, 13, 17, 19,   // 1
    23, 29, 31, 37, 41, 43, 47, 53,   // 2
    59, 61, 67, 71, 73, 79, 83, 89,   // 3
    97, 101, 103, 107, 109, 113, 127, 131,   // 4
    137, 139, 149, 151, 157, 163, 167, 173,   // 5
    179, 181, 191, 193, 197, 199, 211, 223,   // 6
    227, 229, 233, 239, 241, 251, 257, 263,   // 7  < 256 = 53
    269, 271, 277, 281, 283, 293, 307, 311,   // 8
    313, 317, 331, 337, 347, 349, 353, 359,   // 9

    367, 373, 379, 383, 389, 397, 401, 409,   // 10
    419, 421, 431, 433, 439, 443, 449, 457,   // 11
    461, 463, 467, 479, 487, 491, 499, 503,   // 12
    509, 521, 523, 541, 547, 557, 563, 569,   // 13
    571, 577, 587, 593, 599, 601, 607, 613,   // 14
    617, 619, 631, 641, 643, 647, 653, 659,   // 15
    661, 673, 677, 683, 691, 701, 709, 719,   // 16
    727, 733, 739, 743, 751, 757, 761, 769,   // 17
    773, 787, 797, 809, 811, 821, 823, 827,   // 18
    829, 839, 853, 857, 859, 863, 877, 881,   // 19

    883, 887, 907, 911, 919, 929, 937, 941,   // 20
    947, 953, 967, 971, 977, 983, 991, 997,   // 21
    1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049,   // 22
    1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097,   // 23
    1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163,   // 24
    1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223,   // 25
    1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283,   // 26
    1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321,   // 27
    1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423,   // 28
    1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459,   // 29

    1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511,   // 30
    1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571,   // 31
    1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619,   // 32
    1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693,   // 33
    1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747,   // 34
    1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811,   // 35
    1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877,   // 36
    1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949,   // 37
    1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003,   // 38 < 2000 = 303
    2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069,   // 39

    2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129,   // 40
    2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203,   // 41
    2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267,   // 42
    2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311,   // 43
    2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377,   // 44
    2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423,   // 45
    2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503,   // 46
    2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579,   // 47
    2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657,   // 48
    2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693,   // 49

    2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741,   // 50
    2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801,   // 51
    2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861,   // 52
    2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939,   // 53
    2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011,   // 54
    3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079,   // 55
    3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167,   // 56
    3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221,   // 57
    3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301,   // 58
    3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347,   // 59

    3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413,   // 60
    3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491,   // 61
    3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541,   // 62
    3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607,   // 63
    3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671,   // 64
    3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727,   // 65
    3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797,   // 66
    3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863,   // 67
    3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923,   // 68
    3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003,   // 69

    4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057,   // 70
    4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129,   // 71
    4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211,   // 72
    4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259,   // 73
    4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337,   // 74
    4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409,   // 75
    4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481,   // 76
    4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547,   // 77
    4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621,   // 78
    4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673,   // 79

    4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751,   // 80
    4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813,   // 81
    4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909,   // 82
    4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967,   // 83
    4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011,   // 84
    5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087,   // 85
    5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167,   // 86
    5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233,   // 87
    5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309,   // 88
    5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399,   // 89

    5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443,   // 90
    5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507,   // 91
    5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573,   // 92
    5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653,   // 93
    5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711,   // 94
    5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791,   // 95
    5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849,   // 96
    5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897,   // 97
    5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007,   // 98
    6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073,   // 99

    6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133,   // 100
    6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211,   // 101
    6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271,   // 102
    6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329,   // 103
    6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379,   // 104
    6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473,   // 105
    6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563,   // 106
    6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637,   // 107
    6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701,   // 108
    6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779,   // 109

    6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833,   // 110
    6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907,   // 111
    6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971,   // 112
    6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027,   // 113
    7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121,   // 114
    7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207,   // 115
    7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253,   // 116
    7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349,   // 117
    7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457,   // 118
    7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517,   // 119

    7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561,   // 120
    7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621,   // 121
    7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691,   // 122
    7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757,   // 123
    7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853,   // 124
    7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919,   // 125
    7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009,   // 126
    8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087,   // 127
    8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161,   // 128
    8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231,   // 129

    8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291,   // 130
    8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369,   // 131
    8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443,   // 132
    8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537,   // 133
    8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609,   // 134
    8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677,   // 135
    8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731,   // 136
    8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803,   // 137
    8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861,   // 138
    8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941,   // 139

    8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011,   // 140
    9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091,   // 141
    9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161,   // 142
    9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227,   // 143
    9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311,   // 144
    9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377,   // 145
    9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433,   // 146
    9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491,   // 147
    9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587,   // 148
    9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649,   // 149

    9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733,   // 150
    9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791,   // 151
    9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857,   // 152
    9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929,   // 153
    9931, 9941, 9949, 9967, 9973, 10007, 10009, 10037,   // 154
    10039, 10061, 10067, 10069, 10079, 10091, 10093, 10099,   // 155
    10103, 10111, 10133, 10139, 10141, 10151, 10159, 10163,   // 156
    10169, 10177, 10181, 10193, 10211, 10223, 10243, 10247,   // 157
    10253, 10259, 10267, 10271, 10273, 10289, 10301, 10303,   // 158
    10313, 10321, 10331, 10333, 10337, 10343, 10357, 10369,   // 159

    10391, 10399, 10427, 10429, 10433, 10453, 10457, 10459,   // 160
    10463, 10477, 10487, 10499, 10501, 10513, 10529, 10531,   // 161
    10559, 10567, 10589, 10597, 10601, 10607, 10613, 10627,   // 162
    10631, 10639, 10651, 10657, 10663, 10667, 10687, 10691,   // 163
    10709, 10711, 10723, 10729, 10733, 10739, 10753, 10771,   // 164
    10781, 10789, 10799, 10831, 10837, 10847, 10853, 10859,   // 165
    10861, 10867, 10883, 10889, 10891, 10903, 10909, 10937,   // 166
    10939, 10949, 10957, 10973, 10979, 10987, 10993, 11003,   // 167
    11027, 11047, 11057, 11059, 11069, 11071, 11083, 11087,   // 168
    11093, 11113, 11117, 11119, 11131, 11149, 11159, 11161,   // 169

    11171, 11173, 11177, 11197, 11213, 11239, 11243, 11251,   // 170
    11257, 11261, 11273, 11279, 11287, 11299, 11311, 11317,   // 171
    11321, 11329, 11351, 11353, 11369, 11383, 11393, 11399,   // 172
    11411, 11423, 11437, 11443, 11447, 11467, 11471, 11483,   // 173
    11489, 11491, 11497, 11503, 11519, 11527, 11549, 11551,   // 174
    11579, 11587, 11593, 11597, 11617, 11621, 11633, 11657,   // 175
    11677, 11681, 11689, 11699, 11701, 11717, 11719, 11731,   // 176
    11743, 11777, 11779, 11783, 11789, 11801, 11807, 11813,   // 177
    11821, 11827, 11831, 11833, 11839, 11863, 11867, 11887,   // 178
    11897, 11903, 11909, 11923, 11927, 11933, 11939, 11941,   // 179

    11953, 11959, 11969, 11971, 11981, 11987, 12007, 12011,   // 180
    12037, 12041, 12043, 12049, 12071, 12073, 12097, 12101,   // 181
    12107, 12109, 12113, 12119, 12143, 12149, 12157, 12161,   // 182
    12163, 12197, 12203, 12211, 12227, 12239, 12241, 12251,   // 183
    12253, 12263, 12269, 12277, 12281, 12289, 12301, 12323,   // 184
    12329, 12343, 12347, 12373, 12377, 12379, 12391, 12401,   // 185
    12409, 12413, 12421, 12433, 12437, 12451, 12457, 12473,   // 186
    12479, 12487, 12491, 12497, 12503, 12511, 12517, 12527,   // 187
    12539, 12541, 12547, 12553, 12569, 12577, 12583, 12589,   // 188
    12601, 12611, 12613, 12619, 12637, 12641, 12647, 12653,   // 189

    12659, 12671, 12689, 12697, 12703, 12713, 12721, 12739,   // 190
    12743, 12757, 12763, 12781, 12791, 12799, 12809, 12821,   // 191
    12823, 12829, 12841, 12853, 12889, 12893, 12899, 12907,   // 192
    12911, 12917, 12919, 12923, 12941, 12953, 12959, 12967,   // 193
    12973, 12979, 12983, 13001, 13003, 13007, 13009, 13033,   // 194
    13037, 13043, 13049, 13063, 13093, 13099, 13103, 13109,   // 195
    13121, 13127, 13147, 13151, 13159, 13163, 13171, 13177,   // 196
    13183, 13187, 13217, 13219, 13229, 13241, 13249, 13259,   // 197
    13267, 13291, 13297, 13309, 13313, 13327, 13331, 13337,   // 198
    13339, 13367, 13381, 13397, 13399, 13411, 13417, 13421,   // 199

    13441, 13451, 13457, 13463, 13469, 13477, 13487, 13499,   // 200
    13513, 13523, 13537, 13553, 13567, 13577, 13591, 13597,   // 201
    13613, 13619, 13627, 13633, 13649, 13669, 13679, 13681,   // 202
    13687, 13691, 13693, 13697, 13709, 13711, 13721, 13723,   // 203
    13729, 13751, 13757, 13759, 13763, 13781, 13789, 13799,   // 204
    13807, 13829, 13831, 13841, 13859, 13873, 13877, 13879,   // 205
    13883, 13901, 13903, 13907, 13913, 13921, 13931, 13933,   // 206
    13963, 13967, 13997, 13999, 14009, 14011, 14029, 14033,   // 207
    14051, 14057, 14071, 14081, 14083, 14087, 14107, 14143,   // 208
    14149, 14153, 14159, 14173, 14177, 14197, 14207, 14221,   // 209

    14243, 14249, 14251, 14281, 14293, 14303, 14321, 14323,   // 210
    14327, 14341, 14347, 14369, 14387, 14389, 14401, 14407,   // 211
    14411, 14419, 14423, 14431, 14437, 14447, 14449, 14461,   // 212
    14479, 14489, 14503, 14519, 14533, 14537, 14543, 14549,   // 213
    14551, 14557, 14561, 14563, 14591, 14593, 14621, 14627,   // 214
    14629, 14633, 14639, 14653, 14657, 14669, 14683, 14699,   // 215
    14713, 14717, 14723, 14731, 14737, 14741, 14747, 14753,   // 216
    14759, 14767, 14771, 14779, 14783, 14797, 14813, 14821,   // 217
    14827, 14831, 14843, 14851, 14867, 14869, 14879, 14887,   // 218
    14891, 14897, 14923, 14929, 14939, 14947, 14951, 14957,   // 219

    14969, 14983, 15013, 15017, 15031, 15053, 15061, 15073,   // 220
    15077, 15083, 15091, 15101, 15107, 15121, 15131, 15137,   // 221
    15139, 15149, 15161, 15173, 15187, 15193, 15199, 15217,   // 222
    15227, 15233, 15241, 15259, 15263, 15269, 15271, 15277,   // 223
    15287, 15289, 15299, 15307, 15313, 15319, 15329, 15331,   // 224
    15349, 15359, 15361, 15373, 15377, 15383, 15391, 15401,   // 225
    15413, 15427, 15439, 15443, 15451, 15461, 15467, 15473,   // 226
    15493, 15497, 15511, 15527, 15541, 15551, 15559, 15569,   // 227
    15581, 15583, 15601, 15607, 15619, 15629, 15641, 15643,   // 228
    15647, 15649, 15661, 15667, 15671, 15679, 15683, 15727,   // 229

    15731, 15733, 15737, 15739, 15749, 15761, 15767, 15773,   // 230
    15787, 15791, 15797, 15803, 15809, 15817, 15823, 15859,   // 231
    15877, 15881, 15887, 15889, 15901, 15907, 15913, 15919,   // 232
    15923, 15937, 15959, 15971, 15973, 15991, 16001, 16007,   // 233
    16033, 16057, 16061, 16063, 16067, 16069, 16073, 16087,   // 234
    16091, 16097, 16103, 16111, 16127, 16139, 16141, 16183,   // 235
    16187, 16189, 16193, 16217, 16223, 16229, 16231, 16249,   // 236
    16253, 16267, 16273, 16301, 16319, 16333, 16339, 16349,   // 237
    16361, 16363, 16369, 16381, 16411, 16417, 16421, 16427,   // 238
    16433, 16447, 16451, 16453, 16477, 16481, 16487, 16493,   // 239

    16519, 16529, 16547, 16553, 16561, 16567, 16573, 16603,   // 240
    16607, 16619, 16631, 16633, 16649, 16651, 16657, 16661,   // 241
    16673, 16691, 16693, 16699, 16703, 16729, 16741, 16747,   // 242
    16759, 16763, 16787, 16811, 16823, 16829, 16831, 16843,   // 243
    16871, 16879, 16883, 16889, 16901, 16903, 16921, 16927,   // 244
    16931, 16937, 16943, 16963, 16979, 16981, 16987, 16993,   // 245
    17011, 17021, 17027, 17029, 17033, 17041, 17047, 17053,   // 246
    17077, 17093, 17099, 17107, 17117, 17123, 17137, 17159,   // 247
    17167, 17183, 17189, 17191, 17203, 17207, 17209, 17231,   // 248
    17239, 17257, 17291, 17293, 17299, 17317, 17321, 17327,   // 249

    17333, 17341, 17351, 17359, 17377, 17383, 17387, 17389,   // 250
    17393, 17401, 17417, 17419, 17431, 17443, 17449, 17467,   // 251
    17471, 17477, 17483, 17489, 17491, 17497, 17509, 17519,   // 252
    17539, 17551, 17569, 17573, 17579, 17581, 17597, 17599,   // 253
    17609, 17623, 17627, 17657, 17659, 17669, 17681, 17683,   // 254
    17707, 17713, 17729, 17737, 17747, 17749, 17761, 17783,   // 255
    17789, 17791, 17807, 17827, 17837, 17839, 17851, 17863,   // 256
    17881, 17891, 17903, 17909, 17911, 17921, 17923, 17929,   // 257
    17939, 17957, 17959, 17971, 17977, 17981, 17987, 17989); // 258  < 18,000

  SInvalidFileFormat = 'Invalid file format';




type
  TLBBase = class(TComponent)
  end;

  TDataBytes = array of Byte;
  pDword = ^dword;

  TDesConverter = record
    case boolean of
      False: (Bytes: array [0..7] of byte);
      True: (DWords: array  [0..1] of dword)
  end;

  pLongIntArray = ^TLongIntArray;
  TLongIntArray = array [0..MaxStructSize div SizeOf(longint) - 1] of longint;

  TLongIntRec = packed record
    case byte of
      1: (Lo: word;
        Hi: word);
      2: (LoLo: byte;
        LoHi: byte;
        HiLo: byte;
        HiHi: byte);
  end;

  TInt64 = packed record
    case byte of
      0: (Lo: longint;
        Hi: longint);
      1: (LoLo: word;
        LoHi: word;
        HiLo: word;
        HiHi: word);
      2: (LoLoLo: byte;
        LoLoHi: byte;
        LoHiLo: byte;
        LoHiHi: byte;
        HiLoLo: byte;
        HiLoHi: byte;
        HiHiLo: byte;
        HiHiHi: byte);
  end;

  TRDLVector = record
    case byte of
      0: (dw: DWord);
      1: (bt: array[0..3] of byte);
  end;

  PKey64 = ^TKey64;                                                 {!!.03}
  TKey64 = array [0..7] of byte;

  PKey128 = ^TKey128;                                                {!!.03}
  TKey128 = array [0..15] of byte;

  PKey192 = ^TKey192;                                                {!!.03}
  TKey192 = array [0..23] of byte;

  PKey256 = ^TKey256;                                                {!!.03}
  TKey256 = array [0..31] of byte;

  PLBCBlock = ^TLBCBlock;
  TLBCBlock = array[0..3] of longint;     { LockBox Cipher }
  TDESBlock = array[0..7] of byte;        { DES }
  TLQCBlock = array[0..1] of longint;     { LockBox Quick Cipher }
  TBFBlock = array[0..1] of longint;     { BlowFish }
  TRDLBlock = array[0..15] of byte;       { Rijndael }

  TBFContext = packed record
    PBox: array[0..(BFRounds + 1)] of longint;
    SBox: array[0..3, 0..255] of longint;
  end;

  TDESContext = packed record
    TransformedKey: array [0..31] of longint;
    Encrypt: boolean;
  end;

  TTripleDESContext = array [0..1] of TDESContext;
  TTripleDESContext3Key = array [0..2] of TDESContext;               {!!.01}

  TLBCContext = packed record
    Encrypt: boolean;
    Dummy: array[0..2] of byte; {filler}
    Rounds: longint;
    case byte of
      0: (SubKeys64: array [0..15] of TKey64);
      1: (SubKeysInts: array [0..3, 0..7] of longint);
  end;

  TRDLContext = packed record
    Encrypt: boolean;
    Dummy: array[0..2] of byte; {filler}
    Rounds: DWord;
    case byte of
      0: (W: array[0..(MaxRDLRounds * 4)] of TRDLVector);
      1: (Rk: array[0..MaxRDLRounds] of TRDLBlock);
  end;

  TLSCContext = packed record
    Index: longint;
    Accumulator: longint;
    SBox: array [0..255] of byte;
  end;

  TRNG32Context = array [0..3] of byte;
  TRNG64Context = array [0..7] of byte;

  TMD5Digest = array [0..15] of byte;         { 128 bits - MD5 }
  TSHA1Digest = array [0..19] of byte;         { 160 bits - SHA-1 }

  TLMDContext = array [0..279] of byte;       { LockBox message digest }
  TMD5Context = array [0..87] of byte;        { MD5 }

  TSHA1Context = record                        { SHA-1 }
    sdHi: DWord;
    sdLo: DWord;
    sdIndex: DWord;
    sdHash: array [0..4] of DWord;
    sdBuf: array [0..63] of byte;
  end;

  pMD5ContextEx = ^TMD5ContextEx;

  TMD5ContextEx = packed record
    Count: array [0..1] of DWord;  {number of bits handled mod 2^64}
    State: array [0..3] of DWord;  {scratch buffer}
    Buf: array [0..63] of byte;    {input buffer}
  end;

  TLMDContextEx = packed record
    DigestIndex: longint;
    Digest: array [0..255] of byte;
    KeyIndex: longint;
    case byte of
      0: (KeyInts: array [0..3] of longint);
      1: (Key: TKey128);
  end;
  TBlock2048 = array [0..255] of byte;

  T128Bit = array [0..3] of DWord;
  T256Bit = array [0..7] of DWord;

  TBCHalfBlock = array [0..1] of longint;

  TBFBlockEx = packed record
    Xl: array[0..3] of byte;
    Xr: array[0..3] of byte;
  end;

  TRDLVectors = array[0..(RDLNb128 - 1)] of TRDLVector;
  TRDLMixColMatrix = array[0..3, 0..3] of byte;

  TLbRandomGenerator = class
  private
    RandCount: integer;
    Seed: TMD5Digest;
    procedure ChurnSeed;
  public
    constructor Create;
    destructor Destroy; override;
    procedure RandomBytes(var buff; len: DWORD);
  end;

  TLbRanLFS = class
  private
    ShiftRegister: DWORD;
    procedure SetSeed;
    function LFS: byte;
  public
    constructor Create;
    destructor Destroy; override;
    procedure FillBuf(var buff; len: DWORD);
  end;

  LbIntBuf = packed record
    dwLen: integer;                                                      {!!03}
    pBuf: pByte;
  end;

  LbInteger = packed record
    bSign: boolean;
    dwUsed: integer;                                                     {!!03}
    IntBuf: LbIntBuf;
  end;

  pBiByteArray = ^TBiByteArray;
  pBiWordArray = ^TBiWordArray;
  TBiByteArray = array[0..pred(maxint)] of byte;
  TBiWordArray = array[0..pred(maxint div 2)] of word;

  TLbBigInt = class
  protected {private}
    FI: LbInteger;
    procedure setSign(Value: boolean);
    function getSign: boolean;
    function GetSize: integer;                                         {!!03}
    function GetIntStr: string;
    function GetIntBuf: pByte;
  public
    constructor Create(ALen: integer);
    destructor Destroy; override;

    procedure Add(I2: TLbBigInt);
    procedure Subtract(I2: TLbBigInt);
    procedure Multiply(I2: TLbBigInt);
    procedure Divide(I2: TLbBigInt);
    procedure Modulus(I2: TLbBigInt);
    function ModInv(Modulus: TLbBigInt): boolean;
    procedure PowerAndMod(Exponent: TLbBigInt; modulus: TLbBigInt);

    procedure AddByte(b: byte);
    procedure SubtractByte(b: byte);
    procedure MultiplyByte(b: byte);
    procedure DivideByte(b: byte);
    procedure ModByte(b: byte);

    procedure Clear;
    procedure Trim;
    function Compare(I2: TLbBigInt): shortint;
    function IsZero: boolean;
    function IsOne: boolean;
    function IsOdd: boolean;
    function IsEven: boolean;
    function IsComposite(Iterations: cardinal): boolean;
    function Abs(I2: TLbBigInt): shortint;
    procedure ReverseBits;
    procedure ReverseBytes;
    function GetBit(bit: integer): boolean;
    procedure Shr_(_shr: integer);
    procedure Shl_(_shl: integer);
    procedure OR_(I2: TLbBigInt);
    procedure XOR_(I2: TLbBigInt);

    procedure RandomBytes(Count: cardinal);
    procedure RandomPrime(Iterations: byte);
    procedure RandomSimplePrime;

    procedure Copy(I2: TLbBigInt);
    procedure CopyLen(I2: TLbBigInt; Len: integer);
    procedure CopyByte(b: byte);
    procedure CopyWord(w: word);
    procedure CopyDWord(d: dword);
    procedure CopyBuffer(const Buf; BufLen: integer);

    procedure Append(I: TLbBigInt);
    procedure AppendByte(b: byte);
    procedure AppendWord(w: word);
    procedure AppendDWord(d: dword);
    procedure AppendBuffer(const Buf; BufLen: integer);

    procedure Prepend(I: TLbBigInt);
    procedure PrependByte(b: byte);
    procedure PrependWord(w: word);
    procedure PrependDWord(d: dword);
    procedure PrependBuffer(const Buf; BufLen: integer);

    function ToBuffer(var Buf; BufLen: integer): integer;
    function GetByteValue(place: integer): byte;

    property Sign: boolean read getSign write setSign;
    property Int: LbInteger read FI;
    property IntBuf: pByte read GetIntBuf;
    property IntStr: string read GetIntStr;
    property Size: integer read GetSize;
  end;

  ECipherException = class(Exception);

  TProgressProc = procedure(CurPostion, TotalSize: longint);

  TLBBaseComponent = class(TLBBase)
  protected
  published
  end;

  TLbCipherMode = (cmECB, cmCBC);

  TLbCipher = class(TLbBaseComponent)
  public {methods}
    constructor Create(AOwner : TComponent); override;
    destructor Destroy; override;

    function DecryptBuffer(const InBuf; InBufSize : Cardinal; var OutBuf) : Cardinal;
    function EncryptBuffer(const InBuf; InBufSize : Cardinal; var OutBuf) : Cardinal;

    procedure DecryptFile(const InFile, OutFile : string); virtual; abstract;
    procedure DecryptStream(InStream , OutStream : TStream); virtual; abstract;
    function  DecryptString(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF}) : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
    function  DecryptStringA(const InString : AnsiString) : AnsiString; virtual; abstract;
    {$IFDEF UNICODE}function  DecryptStringW(const InString : UnicodeString) : UnicodeString; virtual; abstract;{$ENDIF}
    procedure EncryptFile(const InFile, OutFile : string); virtual; abstract;
    procedure EncryptStream(InStream, OutStream : TStream); virtual; abstract;
    function  EncryptString(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF}) : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
    function  EncryptStringA(const InString: AnsiString): AnsiString; virtual; abstract;
    {$IFDEF UNICODE}function  EncryptStringW(const InString: UnicodeString): UnicodeString; virtual; abstract;{$ENDIF}

    function OutBufSizeNeeded(InBufSize : Cardinal) : Cardinal; virtual; abstract;
  end;

  TLbSymmetricCipher = class(TLbCipher)
  protected {private}
    FCipherMode : TLbCipherMode;
  public {methods}
    constructor Create(AOwner : TComponent); override;
    destructor Destroy; override;

    procedure GenerateKey(const Passphrase : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF});
    procedure GenerateKeyA(const Passphrase : AnsiString); virtual; abstract;
    {$IFDEF UNICODE}
    procedure GenerateKeyW(const Passphrase : UnicodeString); virtual; abstract;
    {$ENDIF}
    procedure GenerateRandomKey; virtual; abstract;
  public {properties}
    property CipherMode : TLbCipherMode read FCipherMode write FCipherMode;
  end;

  TLbBlowfish = class(TLbSymmetricCipher)
  protected {private}
    FKey : TKey128;
  public {methods}
    constructor Create(AOwner : TComponent); override;
    destructor Destroy; override;

    procedure DecryptFile(const InFile, OutFile : string); override;
    procedure DecryptStream(InStream , OutStream : TStream); override;
    function  DecryptStringA(const InString : AnsiString) : AnsiString; override;
    {$IFDEF UNICODE}function  DecryptStringW(const InString : UnicodeString) : UnicodeString; override;{$ENDIF}

    procedure EncryptFile(const InFile, OutFile : string); override;
    procedure EncryptStream(InStream, OutStream : TStream); override;
    function  EncryptStringA(const InString : AnsiString) : AnsiString; override;
    {$IFDEF UNICODE}
    function  EncryptStringW(const InString : UnicodeString) : UnicodeString; override;
    {$ENDIF}

    procedure GenerateKeyA(const Passphrase : AnsiString); override;
    {$IFDEF UNICODE}
    procedure GenerateKeyW(const Passphrase : UnicodeString); override;
    {$ENDIF}
    procedure GenerateRandomKey; override;

    procedure GetKey(var Key : TKey128);
    procedure SetKey(const Key : TKey128);

    function OutBufSizeNeeded(InBufSize : Cardinal) : Cardinal; override;

  published {properties}
    property CipherMode;
  end;

  TLbDES = class(TLbSymmetricCipher)
  protected {private}
    FKey : TKey64;
  public {methods}
    constructor Create(AOwner : TComponent); override;
    destructor Destroy; override;

    procedure DecryptFile(const InFile, OutFile : string); override;
    procedure DecryptStream(InStream , OutStream : TStream); override;
    function  DecryptStringA(const InString : AnsiString) : AnsiString; override;
    {$IFDEF UNICODE}
    function  DecryptStringW(const InString : UnicodeString) : UnicodeString; override;
    {$ENDIF}

    procedure EncryptFile(const InFile, OutFile : string); override;
    procedure EncryptStream(InStream, OutStream : TStream); override;
    function  EncryptStringA(const InString : AnsiString) : AnsiString; override;
    {$IFDEF UNICODE}
    function  EncryptStringW(const InString : UnicodeString) : UnicodeString; override;
    {$ENDIF}

    procedure GenerateKeyA(const Passphrase : AnsiString); override;
    {$IFDEF UNICODE}
    procedure GenerateKeyW(const Passphrase : UnicodeString); override;
    {$ENDIF}
    procedure GenerateRandomKey; override;

    procedure GetKey(var Key : TKey64);
    procedure SetKey(const Key : TKey64);

    function OutBufSizeNeeded(InBufSize : Cardinal) : Cardinal; override;

  published {properties}
    property CipherMode;
  end;

  TLb3DES = class(TLbSymmetricCipher)
  protected {private}
    FKey : TKey128;
  public {methods}
    constructor Create(AOwner : TComponent); override;
    destructor Destroy; override;

    procedure DecryptFile(const InFile, OutFile : string); override;
    procedure DecryptStream(InStream , OutStream : TStream); override;
    function  DecryptStringA(const InString : AnsiString) : AnsiString; override;
    {$IFDEF UNICODE}
    function  DecryptStringW(const InString : UnicodeString) : UnicodeString; override;
    {$ENDIF}

    procedure EncryptFile(const InFile, OutFile : string); override;
    procedure EncryptStream(InStream, OutStream : TStream); override;
    function  EncryptStringA(const InString : AnsiString) : AnsiString; override;
    {$IFDEF UNICODE}
    function  EncryptStringW(const InString : UnicodeString) : UnicodeString; override;
    {$ENDIF}

    procedure GenerateKeyA(const Passphrase : AnsiString); override;
    {$IFDEF UNICODE}
    procedure GenerateKeyW(const Passphrase : UnicodeString); override;
    {$ENDIF}
    procedure GenerateRandomKey; override;

    procedure GetKey(var Key : TKey128);
    procedure SetKey(const Key : TKey128);

    function OutBufSizeNeeded(InBufSize : Cardinal) : Cardinal; override;

  published {properties}
    property CipherMode;
  end;

  TLbKeySizeRDL = (ks128, ks192, ks256);

  TLbRijndael = class(TLbSymmetricCipher)
  protected {private}
    FKey     : TKey256;
    FKeySize : TLbKeySizeRDL;
    FKeySizeBytes : Integer;
    procedure SetKeySize(Value : TLbKeySizeRDL);
  public {methods}
    constructor Create(AOwner : TComponent); override;
    destructor Destroy; override;

    procedure DecryptFile(const InFile, OutFile : string); override;
    procedure DecryptStream(InStream , OutStream : TStream); override;
    function  DecryptStringA(const InString : AnsiString) : AnsiString; override;
    {$IFDEF UNICODE}
    function  DecryptStringW(const InString : UnicodeString) : UnicodeString; override;
    {$ENDIF}

    procedure EncryptFile(const InFile, OutFile : string); override;
    procedure EncryptStream(InStream, OutStream : TStream); override;
    function  EncryptStringA(const InString : AnsiString) : AnsiString; override;
    {$IFDEF UNICODE}
    function  EncryptStringW(const InString : UnicodeString) : UnicodeString; override;
    {$ENDIF}

    procedure GenerateKeyA(const Passphrase : AnsiString); override;
    {$IFDEF UNICODE}
    procedure GenerateKeyW(const Passphrase : UnicodeString); override;
    {$ENDIF}
    procedure GenerateRandomKey; override;

    procedure GetKey(var Key);
    procedure SetKey(const Key);

    function OutBufSizeNeeded(InBufSize : Cardinal) : Cardinal; override;

  published {properties}
    property CipherMode;
    property KeySize : TLbKeySizeRDL read FKeySize write SetKeySize;
  end;

  TLbHash = class(TLbBaseComponent)
    protected {private}
      FBuf : array[0..1023] of Byte;
    public {methods}
      constructor Create(AOwner : TComponent); override;
      destructor Destroy; override;
      procedure HashBuffer(const Buf; BufSize : Cardinal); virtual; abstract;
      procedure HashFile(const AFileName : string); virtual; abstract;
      procedure HashStream(AStream: TStream); virtual; abstract;
      procedure HashString(const AStr : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF});
      procedure HashStringA(const AStr : AnsiString); virtual; abstract;
      {$IFDEF UNICODE}
      procedure HashStringW(const AStr : UnicodeString); virtual; abstract;
      {$ENDIF}
    end;

  TLbMD5 = class(TLbHash)
    protected {private}
      FDigest : TMD5Digest;
    public {methods}
      constructor Create(AOwner : TComponent); override;
      destructor Destroy; override;

      procedure GetDigest(var Digest : TMD5Digest);

      procedure HashBuffer(const Buf; BufSize : Cardinal); override;
      procedure HashFile(const AFileName : string); override;
      procedure HashStream(AStream: TStream); override;
      procedure HashStringA(const AStr : AnsiString); override;
      {$IFDEF UNICODE}
      procedure HashStringW(const AStr : UnicodeString); override;
      {$ENDIF}
    end;

  TLbSHA1 = class(TLbHash)
    protected {private}
      FDigest : TSHA1Digest;
    public {methods}
      constructor Create(AOwner : TComponent); override;
      destructor Destroy; override;

      procedure GetDigest(var Digest : TSHA1Digest);

      procedure HashBuffer(const Buf; BufSize : Cardinal); override;
      procedure HashFile(const AFileName : string); override;
      procedure HashStream(AStream: TStream); override;
      procedure HashStringA(const AStr : AnsiString); override;
      {$IFDEF UNICODE}
      procedure HashStringW(const AStr : UnicodeString); override;
      {$ENDIF}
    end;

  TLbSCStream = class(TMemoryStream)
  protected {private}
    FContext : TLSCContext;
  public {methods}
    constructor Create(const Key; KeySize : Integer);
    procedure Reinitialize(const Key; KeySize : Integer); dynamic;
    procedure ChangeKey(const Key; KeySize : Integer); dynamic;
    function Read(var Buffer; Count : Longint) : Longint; override;
    function Write(const Buffer; Count : Longint) : Longint; override;
  end;

  TLbSCFileStream = class(TFileStream)
  protected {private}
    FContext : TLSCContext;
  public {methods}
    constructor Create(const FileName : string; Mode : Word; const Key; KeySize : Integer);
    procedure Reinitialize(const Key; KeySize : Integer); dynamic;
    procedure ChangeKey(const Key; KeySize : Integer); dynamic;
    function Read(var Buffer; Count : Longint) : Longint; override;
    function Write(const Buffer; Count : Longint) : Longint; override;
  end;

  TLbRNG32Stream = class(TMemoryStream)
  protected {private}
    FContext : TRNG32Context;
  public {methods}
    constructor Create(const Key : LongInt);
    procedure Reinitialize(const Key : LongInt); dynamic;
    procedure ChangeKey(const Key : LongInt); dynamic;
    function Read(var Buffer; Count : LongInt) : LongInt; override;
    function Write(const Buffer; Count : LongInt) : LongInt; override;
  end;

  TLbRNG32FileStream = class(TFileStream)
  protected {private}
    FContext : TRNG32Context;
  public {methods}
    constructor Create(const FileName : string; Mode : Word; const Key : LongInt);
    procedure Reinitialize(const Key : LongInt); dynamic;
    procedure ChangeKey(const Key : LongInt); dynamic;
    function Read(var Buffer; Count : LongInt) : LongInt; override;
    function Write(const Buffer; Count : LongInt) : LongInt; override;
  end;


{ TLbRNG64Stream }
  TLbRNG64Stream = class(TMemoryStream)
  protected {private}
    FContext : TRNG64Context;
  public {methods}
    constructor Create(const KeyHi, KeyLo : LongInt);
    procedure Reinitialize(const KeyHi, KeyLo : LongInt); dynamic;
    procedure ChangeKey(const KeyHi, KeyLo : LongInt); dynamic;
    function Read(var Buffer; Count : LongInt) : LongInt; override;
    function Write(const Buffer; Count : LongInt) : LongInt; override;
  end;

  TLbRNG64FileStream = class(TFileStream)
  protected {private}
    FContext : TRNG64Context;
  public {methods}
    constructor Create(const FileName : string; Mode : Word; const KeyHi, KeyLo : LongInt);
    procedure Reinitialize(const KeyHi, KeyLo : LongInt); dynamic;
    procedure ChangeKey(const KeyHi, KeyLo : LongInt); dynamic;
    function Read(var Buffer; Count : LongInt) : LongInt; override;
    function Write(const Buffer; Count : LongInt) : LongInt; override;
  end;

const
  RDLKeySizeMap : array[TLbKeySizeRDL] of Integer = (16, 24, 32);

type
  TLbAsymKeySize = (aks128, aks256, aks512, aks768, aks1024);

const
  cLbDefAsymKeySize = aks512;
  cLbAsymKeyBytes : array[TLbAsymKeySize] of Word =
    (cBytes128, cBytes256, cBytes512, cBytes768, cBytes1024);

type
  TLbProgressEvent = procedure(Sender : TObject; var Abort : Boolean) of object;

  TLbAsymmetricKey = class
  protected
      FKeySize  : TLbAsymKeySize;
      FPassphrase : AnsiString;
      procedure SetKeySize(Value : TLbAsymKeySize); virtual;
      procedure MovePtr(var Ptr : PByte; var Max : Integer );
      procedure MovePtrCount(var Ptr : PByte; var Max : Integer; Count : Integer);
      function GetASN1StructLen( var input : pByte; var len : Integer ) : Integer;
      function GetASN1StructNum ( var input : pByte; var len : Integer ) : Integer;
      procedure CreateASN1(var Buf; var BufLen : Integer; Tag : Byte);
      procedure ParseASN1(var input : pByte; var length : Integer; biValue : TLbBigInt);
      function EncodeASN1(biValue : TLbBigInt; var pBuf : PByteArray; var MaxLen : Integer) : Integer;
      function  CreateASNKey(Input : pByteArray; Length : Integer) : Integer; virtual; abstract;
      function ParseASNKey(Input : pByte; Length : Integer) : boolean; virtual; abstract;
  public
      constructor Create(aKeySize : TLbAsymKeySize); virtual;
      destructor Destroy; override;
      procedure Assign(aKey : TLbAsymmetricKey); virtual;
      procedure LoadFromStream(aStream : TStream); virtual; { as ASN.1 set }
      procedure StoreToStream(aStream : TStream); virtual; { as ASN.1 set }
      procedure LoadFromFile(aFileName : string); virtual; { as ASN.1 set }
      procedure StoreToFile(aFileName : string); virtual; { as ASN.1 set }
  public
      property KeySize : TLbAsymKeySize read FKeySize write SetKeySize;
      property Passphrase : AnsiString read FPassphrase write FPassphrase;
  end;

  TLbAsymmetricCipher = class(TLbCipher)
  protected
      FKeySize    : TLbAsymKeySize;
      FOnProgress : TLbProgressEvent;
      procedure SetKeySize(Value : TLbAsymKeySize); virtual;
  public
      constructor Create(AOwner : TComponent); override;
      destructor Destroy; override;
      procedure GenerateKeyPair; virtual; abstract;
  public
      property KeySize : TLbAsymKeySize read FKeySize write SetKeySize;
      property OnProgress : TLbProgressEvent read FOnProgress write FOnProgress;
  end;

  TLbSignature = class(TLbBaseComponent)
  protected
      FKeySize : TLbAsymKeySize;
      FOnProgress : TLbProgressEvent;
      procedure SetKeySize(Value : TLbAsymKeySize); virtual;
  public
      constructor Create(AOwner : TComponent); override;
      destructor Destroy; override;
      procedure GenerateKeyPair; virtual; abstract;
      procedure SignBuffer(const Buf; BufLen : Cardinal); virtual; abstract;
      procedure SignFile(const AFileName : string); virtual; abstract;
      procedure SignStream(AStream : TStream); virtual; abstract;
      procedure SignString(const AStr : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF});
      procedure SignStringA(const AStr : AnsiString); virtual; abstract;
      {$IFDEF UNICODE}
      procedure SignStringW(const AStr : UnicodeString); virtual; abstract;
      {$ENDIF}
      function  VerifyBuffer(const Buf; BufLen : Cardinal) : Boolean; virtual; abstract;
      function  VerifyFile(const AFileName : string) : Boolean; virtual; abstract;
      function  VerifyStream(AStream : TStream) : Boolean; virtual; abstract;
      function  VerifyString(const AStr : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF}) : Boolean;
      function  VerifyStringA(const AStr : AnsiString) : Boolean; virtual; abstract;
      {$IFDEF UNICODE}
      function  VerifyStringW(const AStr : UnicodeString) : Boolean; virtual; abstract;
      {$ENDIF}
  public {properties}
      property KeySize : TLbAsymKeySize read FKeySize write SetKeySize;
      property OnProgress : TLbProgressEvent read FOnProgress write FOnProgress;
  end;

const
  cRSAMinPadBytes = 11;
  cRSACipherBlockSize : array[TLbAsymKeySize] of Word = (cBytes128, cBytes256, cBytes512, cBytes768, cBytes1024);
  cRSAPlainBlockSize : array[TLbAsymKeySize] of Word = (cBytes128-cRSAMinPadBytes, cBytes256-cRSAMinPadBytes, cBytes512-cRSAMinPadBytes, cBytes768-cRSAMinPadBytes, cBytes1024-cRSAMinPadBytes);

type
  PRSACipherBlock128 = ^TRSACipherBlock128;
  TRSACipherBlock128 = array[0..cBytes128-1] of Byte;
  PRSACipherBlock256 = ^TRSACipherBlock256;
  TRSACipherBlock256 = array[0..cBytes256-1] of Byte;
  PRSACipherBlock512 = ^TRSACipherBlock512;
  TRSACipherBlock512 = array[0..cBytes512-1] of Byte;
  PRSACipherBlock768 = ^TRSACipherBlock768;
  TRSACipherBlock768 = array[0..cBytes768-1] of Byte;
  PRSACipherBlock1024 = ^TRSACipherBlock1024;
  TRSACipherBlock1024 = array[0..cBytes1024-1] of Byte;
  PRSAPlainBlock128 = ^TRSAPlainBlock128;
  TRSAPlainBlock128 = array[0..cBytes128-12] of Byte;
  PRSAPlainBlock256 = ^TRSAPlainBlock256;
  TRSAPlainBlock256 = array[0..cBytes256-12] of Byte;
  PRSAPlainBlock512 = ^TRSAPlainBlock512;
  TRSAPlainBlock512 = array[0..cBytes512-12] of Byte;
  PRSAPlainBlock768 = ^TRSAPlainBlock768;
  TRSAPlainBlock768 = array[0..cBytes768-12] of Byte;
  PRSAPlainBlock1024 = ^TRSAPlainBlock1024;
  TRSAPlainBlock1024 = array[0..cBytes1024-12] of Byte;
  TRSAPlainBlock  = TRSAPlainBlock512;
  TRSACipherBlock = TRSACipherBlock512;
  TRSASignatureBlock = array[0..cBytes1024-1] of Byte;
  TRSAHashMethod  = (hmMD5, hmSHA1);
  TLbRSAGetSignatureEvent = procedure(Sender : TObject; var Sig : TRSASignatureBlock) of object;
  TLbRSACallback = procedure(var Abort : Boolean) of object;

  TLbRSAKey = class(TLbAsymmetricKey)
  protected {private}
      FModulus  : TLbBigInt;
      FExponent : TLbBigInt;
      function ParseASNKey(Input : pByte; Length : Integer) : boolean; override;
      function  CreateASNKey(Input : pByteArray; Length : Integer) : Integer; override;
      function GetModulusAsString : string;
      procedure SetModulusAsString(Value : string);
      function GetExponentAsString : string;
      procedure SetExponentAsString(Value : string);
  public
      constructor Create(aKeySize : TLbAsymKeySize); override;
      destructor Destroy; override;
      procedure Assign(aKey : TLbAsymmetricKey); override;
      procedure Clear;
      property Modulus : TLbBigInt read FModulus;
      property ModulusAsString : string read GetModulusAsString write SetModulusAsString;
      property Exponent : TLbBigInt read FExponent;
      property ExponentAsString : string read GetExponentAsString write SetExponentAsString;
      property Passphrase : AnsiString read FPassphrase write FPassphrase;
  end;

  TLbRSA = class(TLbAsymmetricCipher)
  protected
      FPrivateKey : TLbRSAKey;
      FPublicKey : TLbRSAKey;
      FPrimeTestIterations : Byte;
      procedure SetKeySize(Value : TLbAsymKeySize); override;
  public
      constructor Create(AOwner : TComponent); override;
      destructor Destroy; override;
      procedure DecryptFile(const InFile, OutFile : string); override;
      procedure DecryptStream(InStream , OutStream : TStream); override;
      function  DecryptStringA(const InString : AnsiString) : AnsiString; override;
      {$IFDEF UNICODE}
      function  DecryptStringW(const InString : UnicodeString) : UnicodeString; override;
      {$ENDIF}
      procedure EncryptFile(const InFile, OutFile : string); override;
      procedure EncryptStream(InStream, OutStream : TStream); override;
      function  EncryptStringA(const InString : AnsiString) : AnsiString; override;
      {$IFDEF UNICODE}
      function  EncryptStringW(const InString : UnicodeString) : UnicodeString; override;
      {$ENDIF}
      procedure GenerateKeyPair; override;
      function  OutBufSizeNeeded(InBufSize : Cardinal) : Cardinal; override;
      procedure RSACallback(var Abort : Boolean);
    public
      property PrivateKey : TLbRSAKey read FPrivateKey;
      property PublicKey : TLbRSAKey read FPublicKey;
    published
      property PrimeTestIterations : Byte read FPrimeTestIterations write FPrimeTestIterations;
      property KeySize;
    published
      property OnProgress;
  end;

  TLbRSASSA = class(TLbSignature)
  protected
      FPrivateKey : TLbRSAKey;
      FPublicKey : TLbRSAKey;
      FHashMethod : TRSAHashMethod;
      FPrimeTestIterations : Byte;
      FSignature  : TLbBigInt;
      FOnGetSignature : TLbRSAGetSignatureEvent;
      procedure DoGetSignature;
      procedure EncryptHash(const HashDigest; DigestLen : Cardinal);
      procedure DecryptHash(var HashDigest; DigestLen : Cardinal);
      procedure RSACallback(var Abort : Boolean);
      procedure SetKeySize(Value : TLbAsymKeySize); override;

  public
      constructor Create(AOwner : TComponent); override;
      destructor Destroy; override;
      procedure GenerateKeyPair; override;
      procedure SignBuffer(const Buf; BufLen : Cardinal); override;
      procedure SignFile(const AFileName : string);  override;
      procedure SignStream(AStream : TStream); override;
      procedure SignStringA(const AStr : AnsiString); override;
      {$IFDEF UNICODE}
      procedure SignStringW(const AStr : UnicodeString); override;
      {$ENDIF}
      function  VerifyBuffer(const Buf; BufLen : Cardinal) : Boolean; override;
      function  VerifyFile(const AFileName : string) : Boolean; override;
      function  VerifyStream(AStream : TStream) : Boolean; override;
      function  VerifyStringA(const AStr : AnsiString) : Boolean; override;
      {$IFDEF UNICODE}
      function  VerifyStringW(const AStr : UnicodeString) : Boolean; override;
      {$ENDIF}
  public
      property PrivateKey : TLbRSAKey read FPrivateKey;
      property PublicKey : TLbRSAKey read FPublicKey;
      property Signature : TLbBigInt read FSignature;
  published
      property HashMethod : TRSAHashMethod read FHashMethod write FHashMethod;
      property PrimeTestIterations : Byte read FPrimeTestIterations write FPrimeTestIterations;
      property KeySize;
  published
      property OnGetSignature : TLbRSAGetSignatureEvent read FOnGetSignature write FOnGetSignature;
      property OnProgress;
  end;

  TRSABlockType = (bt00, bt01, bt02);

const
  cDefHashMethod  = hmMD5;

type
  TLbDSABlock = array[0..cBytes160-1] of Byte;
  TLbGetDSABlockEvent = procedure(Sender : TObject; var Block : TLbDSABlock) of object;
  TLbDSACallback = procedure(var Abort : Boolean) of object;

  TLbDSAParameters = class(TLbAsymmetricKey)
  protected
      FP : TLbBigInt;
      FQ : TLbBigInt;
      FG : TLbBigInt;
      F2Tog : TLbBigInt;
      FMostLeast : TLbBigInt;
      FPrimeTestIterations : Byte;
      FCallback : TLbDSACallback;
      function GenerateP(const ASeed : TLbDSABlock) : Boolean;
      function GenerateQ(const ASeed : TLbDSABlock) : Boolean;
      function GenerateG : Boolean;
      function GetPAsString : string;
      procedure SetPAsString(const Value : string);
      function GetQAsString : string;
      procedure SetQAsString(const Value : string);
      function GetGAsString : string;
      procedure SetGAsString(const Value : string);
      procedure SetKeySize(Value : TLbAsymKeySize); override;
  public
      constructor Create(aKeySize : TLbAsymKeySize); override;
      destructor Destroy; override;
      procedure Clear; virtual;
      procedure CopyDSAParameters(AKey : TLbDSAParameters);
      function GenerateDSAParameters(const ASeed : TLbDSABlock) : Boolean;
  public
      property P : TLbBigInt read FP;
      property Q : TLbBigInt read FQ;
      property G : TLbBigInt read FG;
      property PAsString : string read GetPAsString write SetPAsString;
      property QAsString : string read GetQAsString write SetQAsString;
      property GAsString : string read GetGAsString write SetGAsString;
      property PrimeTestIterations : Byte read FPrimeTestIterations write FPrimeTestIterations;
      property Callback : TLbDSACallback read FCallback write FCallback;
  end;

  TLbDSAPrivateKey = class(TLbDSAParameters)
  protected
      FX    : TLbBigInt;
      FXKey : TLbDSABlock;
      function GetXAsString : string;
      procedure SetXAsString(const Value : string);
      function  CreateASNKey(Input : pByteArray; Length : Integer) : Integer; override;
      function ParseASNKey(Input : pByte; Length : Integer) : boolean; override;
  public
      constructor Create(aKeySize : TLbAsymKeySize); override;
      destructor Destroy; override;
      procedure Clear; override;
      procedure GenerateX(const AXKey : TLbDSABlock);
  public
      property X : TLbBigInt read FX;
      property XAsString : string read GetXAsString write SetXAsString;
  end;

  TLbDSAPublicKey = class(TLbDSAParameters)
  protected
      FY : TLbBigInt;
      function GetYAsString : string;
      procedure SetYAsString(const Value : string);
      function  CreateASNKey(Input : pByteArray; Length : Integer) : Integer; override;
      function ParseASNKey(Input : pByte; Length : Integer) : boolean; override;
  public
      constructor Create(aKeySize : TLbAsymKeySize); override;
      destructor Destroy; override;
      procedure Clear; override;
      procedure GenerateY(aX : TLbBigInt);
  public
      property Y : TLbBigInt read FY;
      property YAsString : string read GetYAsString write SetYAsString;
  end;

  TLbDSA = class(TLbSignature)
  protected
      FPrivateKey : TLbDSAPrivateKey;
      FPublicKey : TLbDSAPublicKey;
      FPrimeTestIterations : Byte;
      FSignatureR : TLbBigInt;
      FSignatureS : TLbBigInt;
      FOnGetR     : TLbGetDSABlockEvent;
      FOnGetS     : TLbGetDSABlockEvent;
      FOnGetSeed  : TLbGetDSABlockEvent;
      FOnGetXKey  : TLbGetDSABlockEvent;
      FOnGetKKey  : TLbGetDSABlockEvent;
      FRandomSeed : Boolean;
      procedure SignHash(const ADigest : TSHA1Digest);
      function VerifyHash(const ADigest : TSHA1Digest) : Boolean;
      procedure SHA1KKey(var AKKey : TLbDSABlock);
      procedure RandomBlock(var ABlock : TLbDSABlock);
      procedure DoGetR;
      procedure DoGetS;
      procedure DoGetSeed(var ASeed : TLbDSABlock);
      procedure DoGetXKey(var AXKey : TLbDSABlock);
      procedure DoGetKKey(var AKKey : TLbDSABlock);
      procedure SetKeySize(Value : TLbAsymKeySize); override;
      procedure SetPrimeTestIterations(Value : Byte);
      procedure DSAParameterCallback(var Abort : Boolean);
  public
      constructor Create(AOwner : TComponent); override;
      destructor Destroy; override;
      procedure GenerateKeyPair; override;
      procedure SignBuffer(const Buf; BufLen : Cardinal); override;
      procedure SignFile(const AFileName : string);  override;
      procedure SignStream(AStream : TStream); override;
      procedure SignStringA(const AStr : AnsiString); override;
      {$IFDEF UNICODE}
      procedure SignStringW(const AStr : UnicodeString); override;
      {$ENDIF}
      function  VerifyBuffer(const Buf; BufLen : Cardinal) : Boolean; override;
      function  VerifyFile(const AFileName : string) : Boolean; override;
      function  VerifyStream(AStream : TStream) : Boolean; override;
      function  VerifyStringA(const AStr : AnsiString) : Boolean; override;
      {$IFDEF UNICODE}
      function  VerifyStringW(const AStr : UnicodeString) : Boolean; override;
      {$ENDIF}
      procedure Clear;
      function GeneratePQG : Boolean;
      procedure GenerateXY;
  public
      property PrivateKey : TLbDSAPrivateKey read FPrivateKey;
      property PublicKey : TLbDSAPublicKey read FPublicKey;
      property SignatureR : TLbBigInt read FSignatureR;
      property SignatureS : TLbBigInt read FSignatureS;
  published
      property PrimeTestIterations : Byte read FPrimeTestIterations write SetPrimeTestIterations;
      property KeySize;
  published
      property OnGetR : TLbGetDSABlockEvent read FOnGetR write FOnGetR;
      property OnGetS : TLbGetDSABlockEvent read FOnGetS write FOnGetS;
      property OnGetSeed : TLbGetDSABlockEvent read FOnGetSeed write FOnGetSeed;
      property OnGetXKey : TLbGetDSABlockEvent read FOnGetXKey write FOnGetXKey;
      property OnGetKKey : TLbGetDSABlockEvent read FOnGetKKey write FOnGetKKey;
      property OnProgress : TLbProgressEvent read FOnProgress write FOnProgress;
  end;

const
  cZeroBlock : TLbDSABlock = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

var
  LbOnProgress : TProgressProc = nil;
  LbProgressSize: Longint = 64;


function BufferToHex(const Buf; BufSize : Cardinal) : string;
function HexToBuffer(const Hex : string; var Buf; BufSize : Cardinal) : Boolean;
function Min(A, B : LongInt) : LongInt;
function Max(A, B : LongInt) : LongInt;
function CompareBuffers(const Buf1, Buf2; BufSize : Cardinal) : Boolean;
function Ran0Prim(var Seed : LongInt; IA, IQ, IR : LongInt) : LongInt;
function Ran01(var Seed : LongInt) : LongInt;
function Ran02(var Seed : LongInt) : LongInt;
function Ran03(var Seed : LongInt) : LongInt;
function Random32Byte(var Seed : LongInt) : Byte;
function Random64(var Seed : TInt64) : LongInt;
function Random64Byte(var Seed : TInt64) : Byte;
procedure EncryptLBC(const Context : TLBCContext; var Block : TLBCBlock);
procedure XorMemPrim(var Mem1; const Mem2; Count : Cardinal);
procedure XorMem(var Mem1;  const Mem2;  Count : Cardinal);
procedure EncryptLBCCBC(const Context : TLBCContext; const Prev : TLBCBlock; var Block : TLBCBlock);
procedure InitEncryptDES(const Key : TKey64; var Context : TDESContext;  Encrypt : Boolean);
procedure InitEncryptLBC(const Key : TKey128; var Context : TLBCContext; Rounds: LongInt; Encrypt : Boolean);
procedure EncryptDES(const Context : TDESContext;  var Block : TDESBlock);
procedure EncryptDESCBC(const Context : TDESContext;  const Prev : TDESBlock;  var Block : TDESBlock);
procedure InitEncryptTripleDES(const Key : TKey128;  var Context : TTripleDESContext; Encrypt : Boolean);
procedure EncryptTripleDES(const Context : TTripleDESContext;  var Block : TDESBlock);
procedure EncryptTripleDESCBC(const Context : TTripleDESContext;  const Prev : TDESBlock; var Block : TDESBlock);
procedure InitEncryptTripleDES3Key(const Key1, Key2, Key3 : TKey64; var Context : TTripleDESContext3Key; Encrypt : Boolean);
procedure EncryptTripleDES3Key(const Context : TTripleDESContext3Key; var Block : TDESBlock);
procedure EncryptTripleDESCBC3Key(const Context : TTripleDESContext3Key; const Prev : TDESBlock; var Block : TDESBlock);
procedure EncryptLQC(const Key : TKey128; var Block : TLQCBlock; Encrypt : Boolean);
procedure EncryptLQCCBC(const Key : TKey128; const Prev : TLQCBlock; var Block : TLQCBlock; Encrypt : Boolean);
procedure EncryptBF(const Context : TBFContext; var Block : TBFBlock; Encrypt : Boolean);
procedure InitEncryptBF(Key : TKey128; var Context : TBFContext);
procedure EncryptBFCBC(const Context : TBFContext; const Prev : TBFBlock; var Block : TBFBlock; Encrypt : Boolean);
procedure InitEncryptLSC(const Key; KeySize : Integer; var Context : TLSCContext);
procedure EncryptLSC(var Context : TLSCContext; var Buf; BufSize : LongInt);
procedure InitEncryptRNG32(Key : LongInt; var Context : TRNG32Context);
procedure EncryptRNG32(var Context : TRNG32Context; var Buf; BufSize : LongInt);
procedure InitEncryptRNG64(KeyHi, KeyLo : LongInt; var Context : TRNG64Context);
procedure EncryptRNG64(var Context : TRNG64Context; var Buf; BufSize : LongInt);
procedure GenerateRandomKey(var Key; KeySize : Integer);
procedure InitLMD(var Context : TLMDContext);
procedure UpdateLMD(var Context : TLMDContext; const Buf; BufSize : LongInt);
procedure FinalizeLMD(var Context : TLMDContext; var Digest; DigestSize : LongInt);
procedure HashLMD(var Digest; DigestSize : LongInt; const Buf; BufSize : LongInt);
procedure GenerateLMDKeyA(var Key; KeySize : Integer; const Str : Ansistring);
procedure GenerateLMDKey(var Key; KeySize : Integer; const Str : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF});
{$IFDEF UNICODE}
procedure GenerateLMDKeyW(var Key; KeySize : Integer; const Str : UnicodeString);
{$ENDIF}
procedure InitMD5(var Context : TMD5Context);
function RolX(I, C : DWord): DWord;
procedure Transform(var Buffer : array of DWord;  const InBuf : array of DWord);
procedure UpdateMD5(var Context : TMD5Context;  const Buf;  BufSize : LongInt);
procedure FinalizeMD5(var Context : TMD5Context; var Digest : TMD5Digest);
procedure HashMD5(var Digest : TMD5Digest; const Buf;  BufSize : LongInt);
procedure GenerateMD5KeyA(var Key : TKey128; const Str : AnsiString);
procedure GenerateMD5Key(var Key : TKey128; const Str : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF});
{$IFDEF UNICODE}
procedure GenerateMD5KeyW(var Key : TKey128; const Str : UnicodeString);
{$ENDIF}
procedure  ShrinkDESKey(var Key : TKey64);
procedure Mix128(var X : T128Bit);
procedure HashELF(var Digest : LongInt; const Buf;  BufSize : LongInt);
{$IFDEF UNICODE}
procedure StringHashELFW(var Digest : LongInt; const Str : UnicodeString);
{$ENDIF}
procedure StringHashELFA(var Digest : LongInt; const Str : AnsiString);
procedure HashMix128(var Digest : LongInt; const Buf;  BufSize : LongInt);
{$IFDEF UNICODE}
procedure StringHashMix128W(var Digest : LongInt; const Str : Unicodestring);
{$ENDIF}
procedure StringHashMix128A(var Digest : LongInt; const Str : AnsiString);
{$IFDEF UNICODE}
procedure StringHashMD5W(var Digest : TMD5Digest; const Str : UnicodeString);
{$ENDIF}
procedure StringHashMD5A(var Digest : TMD5Digest; const Str : AnsiString);
{$IFDEF UNICODE}
procedure StringHashLMDW(var Digest; DigestSize : LongInt; const Str : UnicodeString);
{$ENDIF}
procedure StringHashLMDA(var Digest; DigestSize : LongInt; const Str : AnsiString);
procedure SHA1Clear( var Context : TSHA1Context );
function SHA1SwapByteOrder( n : DWORD ) : DWORD;
{$IFDEF UNICODE}
procedure StringHashSHA1W(var Digest : TSHA1Digest; const Str : UnicodeString);
{$ENDIF}
procedure SHA1Hash( var Context : TSHA1Context );
procedure SHA1UpdateLen( var Context : TSHA1Context; Len : DWord );
procedure InitSHA1( var Context : TSHA1Context );
procedure UpdateSHA1( var Context : TSHA1Context; const Buf; BufSize: Longint );
procedure FinalizeSHA1( var Context : TSHA1Context; var Digest : TSHA1Digest );
procedure HashSHA1( var Digest : TSHA1Digest; const Buf; BufSize : Longint );
procedure StringHashSHA1A(var Digest : TSHA1Digest; const Str : AnsiString);
function RdlSubVector(v : TRDLVector) : TRDLVector;
function RdlRotateVector(v : TRDLVector; Count : Byte) : TRDLVector;
procedure RdlRound(const RoundKey : TRDLBlock; var State : TRDLBlock; Final : Boolean);
procedure RdlInvRound(const RoundKey : TRDLBlock; var State : TRDLBlock; First : Boolean);
procedure EncryptRDL(const Context : TRDLContext; var Block : TRDLBlock);
procedure EncryptRDLCBC(const Context : TRDLContext; const Prev : TRDLBlock; var Block : TRDLBlock);
procedure InitEncryptRDL(const Key; KeySize : Longint; var Context : TRDLContext; Encrypt : Boolean);
procedure StringHashELF(var Digest : LongInt; const Str : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF});
procedure StringHashLMD(var Digest; DigestSize : LongInt; const Str : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF});
procedure StringHashMD5(var Digest : TMD5Digest; const Str : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF});
procedure StringHashMix128(var Digest : LongInt; const Str : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF});
procedure StringHashSHA1(var Digest : TSHA1Digest; const Str : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF});
procedure LbBiInit(var N1 : LbInteger; Precision : Integer);
procedure LbBiRealloc(var N1 : LbInteger; Len : integer);
procedure LbBiFree(var N1 : LbInteger);
procedure LbBiClear(var N1 : LbInteger);
function LbBiGetByteValue (N1 : LbInteger; place : integer): byte;
procedure LbBiTrimSigZeros(var N1 : LbInteger);
procedure LbBiVerify(var N1 : LbInteger);
procedure LbBiFindLargestUsed(N1 : LbInteger; N2 : LbInteger; var count : integer);
function LbBiFindFactor(B1 : byte) : byte;
procedure LbBiPrepare(N1 : LbInteger; N2 : LbInteger; var N3 : LbInteger);
procedure LbBiCopy(var dest : LbInteger; src : LbInteger; len : Integer);
function LbBiGetBit(N1 : LbInteger; bit : Integer) : Boolean;
procedure LbBiAddByte(var N1 : LbInteger; place : integer; _byte : byte);
function  LbBiCompare(N1 : LbInteger; N2 : LbInteger): Shortint;
function  LbBiAbs(N1 : LbInteger; N2 : LbInteger): Shortint;
function LbBiIsZero(N1 : LbInteger) : Boolean;
function LbBiIsOne(N1 : LbInteger) : Boolean;
function LbBiIsOdd(N1 : LbInteger): Boolean;
function LbBiIsEven(N1 : LbInteger): Boolean;
procedure LbBiSwap(var N1 : LbInteger; var N2 : LbInteger);
function LbBiReverseBits(byt : Byte) : Byte;
procedure LbBiShr(var N1 : LbInteger; _shr : Integer);
procedure LbBiShl(var N1 : LbInteger; _shl : Integer);
procedure LbBiOR(N1 : LbInteger; N2 : LbInteger; var NOR : LbInteger);
procedure LbBiORInPlace(var N1 : LbInteger; N2 : LbInteger);
procedure LbBiXOR(N1 : LbInteger; N2 : LbInteger; var NXOR : LbInteger);
procedure LbBiXORInPlace(var N1 : LbInteger; N2 : LbInteger);
procedure LbBiMove(var dest : LbInteger; src : LbInteger; place : integer; len : Integer);
procedure LbBiAddBase(N1 : LbInteger; N2 : LbInteger; var Sum : LbInteger);
procedure LbBiSubBase(N1 : LbInteger; N2 : LbInteger; var Diff : LbInteger);
procedure LbBiAdd(N1 : LbInteger; N2 : LbInteger; var Sum : LbInteger);
procedure LbBiSub(N1 : LbInteger; N2 : LbInteger; var diff : LbInteger);
procedure LbBiAddInPlace(var N1 : LbInteger; N2 : LbInteger);
procedure LbBiSubInPlace(var N1 : LbInteger;  N2 : LbInteger);
function MultSpecialCase(N1 : LbInteger; N2 : LbInteger; var Product : LbInteger) : Boolean;
procedure LbBiMultBase(N1 : LbInteger; N2 : LbInteger; var Product : LbInteger);
procedure LbBiMult(N1 : LbInteger; N2 : LbInteger; var Product : LbInteger);
procedure LbBiMultInPlace(var N1 : LbInteger; N2 : LbInteger);
procedure LbBiMulByDigitBase(N1 : LbInteger; N2 : byte; var product : LbInteger);
procedure LbBiMulByDigit(N1 : LbInteger; N2 : byte; var product : LbInteger);
procedure LbBiMulByDigitInPlace(var N1 : LbInteger; N2 : byte);
procedure LbBiDivByDigitBase(N1 : LbInteger; N2 : byte; var quotient : LbInteger; var remainder : byte);
procedure LbBiDivByDigit(N1 : LbInteger; N2 : byte; var quotient : LbInteger; var remainder : byte);
procedure LbBiDivByDigitInPlace(var N1 : LbInteger; N2 : byte; var remainder : byte);
procedure LbBiDivBase(N1 : LbInteger; N2 : LbInteger; var quotient : LbInteger; var remainder : LbInteger);
procedure LbBiDiv(N1 : LbInteger; N2 : LbInteger; var quotient : LbInteger; var remainder : LbInteger);
procedure LbBiDivInPlace(var N1 : LbInteger; N2 : LbInteger; var remainder : LbInteger);
procedure LbBiMod(N1 : LbInteger; N2 : LbInteger; var remainder : LbInteger);
procedure LbBiModInPlace(var N1 : LbInteger; Modulas : LbInteger);
procedure LbBiPowerAndMod(I1 : LbInteger; exponent : LbInteger; modulus : LbInteger; var _Result : LbInteger);
procedure LbBiPowerAndModInPLace(var I1 : LbInteger; exponent : LbInteger; modulus : LbInteger);
procedure LbBiAddByDigit(N1 : LbInteger; N2 : byte; var Sum : LbInteger);
procedure LbBiSubByDigit(N1 : LbInteger; N2 : byte; var Sum : LbInteger);
procedure LbBiAddByDigitInPlace(var N1 : LbInteger; N2 : byte);
procedure LbBiSubByDigitInPlace(var N1 : LbInteger; N2 : byte);
procedure LbBiReverseBytes(N1 : LbInteger; var N2 : LbInteger);
procedure LbBiReverseBytesInPlace(var N1 : LbInteger);
procedure LbBiReverseAllBits(N1 : LbInteger; var N2 : LbInteger);
procedure LbBiReverseBitsInPlace(var N1 : LbInteger);
procedure LbBiAddBuf(var N1 : LbInteger; place : integer; buf : pByte; length : Integer);
procedure LbBiAddWord(var N1 : LbInteger; place : integer; N2 : word);
procedure LbBiAddDWord(var N1 : LbInteger; place : integer; N2 : integer);
procedure LbBiCopyBigInt2Buf(N1 : LbInteger; place : integer; buf : pByte; length : Integer);
function LbBiCheckSimplePrimes(N1 : LbInteger) : Boolean;
function LbBiIsCompositFast(N1 : LbInteger; n : Integer) : Boolean;
procedure LbBiRandomPrime(var N1 : LbInteger; Iterations : Byte);
procedure LbBiRandomSimplePrime(var N1 : LbInteger);
procedure LbBiRandomBytes(var N1 : LbInteger; Count : Cardinal);
procedure LbBiExtendedEuclid(var u : LbInteger; var v : LbInteger; var u1 : LbInteger; var u2 : LbInteger; var GCD : LbInteger);
function LbBiModInv(e : LbInteger; _mod : LbInteger; var d : LbInteger) : Boolean;
procedure BFEncryptStream(InStream, OutStream : TStream; const Key : TKey128; Encrypt : Boolean);
procedure BFEncryptStreamCBC(InStream, OutStream : TStream;  const Key : TKey128; Encrypt : Boolean);
procedure BFEncryptFile(const InFile, OutFile : string; const Key : TKey128; Encrypt : Boolean);
procedure BFEncryptFileCBC(const InFile, OutFile : string; const Key : TKey128; Encrypt : Boolean);
procedure DESEncryptStream(InStream, OutStream : TStream; const Key : TKey64; Encrypt : Boolean);
procedure DESEncryptStreamCBC(InStream, OutStream : TStream; const Key : TKey64; Encrypt : Boolean);
procedure DESEncryptFile(const InFile, OutFile : string; const Key : TKey64; Encrypt : Boolean);
procedure DESEncryptFileCBC(const InFile, OutFile : string; const Key : TKey64; Encrypt : Boolean);
procedure LBCEncryptStream(InStream, OutStream : TStream; const Key : TKey128; Rounds : LongInt; Encrypt : Boolean);
procedure LBCEncryptStreamCBC(InStream, OutStream : TStream; const Key : TKey128; Rounds : LongInt; Encrypt : Boolean);
procedure LQCEncryptStream(InStream, OutStream : TStream; const Key : TKey128; Encrypt : Boolean);
procedure LQCEncryptStreamCBC(InStream, OutStream : TStream;  const Key : TKey128; Encrypt : Boolean);
procedure LQCEncryptFile(const InFile, OutFile : string; const Key : TKey128; Encrypt : Boolean);
procedure LQCEncryptFileCBC(const InFile, OutFile : string; const Key : TKey128; Encrypt : Boolean);
procedure LBCEncryptFile(const InFile, OutFile : string; const Key : TKey128; Rounds : LongInt; Encrypt : Boolean);
procedure LBCEncryptFileCBC(const InFile, OutFile : string; const Key : TKey128; Rounds : LongInt; Encrypt : Boolean);
procedure LSCEncryptFile(const InFile, OutFile : string; const Key; KeySize : Integer);
procedure RNG32EncryptFile(const InFile, OutFile : string; Key : LongInt);
procedure RNG64EncryptFile(const InFile, OutFile : string; KeyHi, KeyLo : LongInt);
procedure TripleDESEncryptStream(InStream, OutStream : TStream; const Key : TKey128; Encrypt : Boolean);
procedure TripleDESEncryptStreamCBC(InStream, OutStream : TStream; const Key : TKey128; Encrypt : Boolean);
procedure TripleDESEncryptFile(const InFile, OutFile : string; const Key : TKey128; Encrypt : Boolean);
procedure TripleDESEncryptFileCBC(const InFile, OutFile : string; const Key : TKey128; Encrypt : Boolean);
procedure RDLEncryptStream(InStream, OutStream : TStream; const Key; KeySize : Longint; Encrypt : Boolean);
procedure RDLEncryptStreamCBC(InStream, OutStream : TStream;  const Key; KeySize : Longint; Encrypt : Boolean);
procedure RDLEncryptFile(const InFile, OutFile : string; const Key; KeySize : Longint; Encrypt : Boolean);
procedure RDLEncryptFileCBC(const InFile, OutFile : string; const Key; KeySize : Longint; Encrypt : Boolean);
procedure StreamHashMD5(var Digest : TMD5Digest; AStream : TStream);
procedure FileHashMD5(var Digest : TMD5Digest; const AFileName : string);
procedure StreamHashSHA1(var Digest : TSHA1Digest; AStream : TStream);
procedure FileHashSHA1(var Digest : TSHA1Digest; const AFileName : string);
procedure LbDecodeBase64A(InStream, OutStream : TStream);
procedure LbDecodeBase64W(InStream, OutStream : TStream);
procedure LbEncodeBase64A(InStream, OutStream : TStream);
procedure LbEncodeBase64W(InStream, OutStream : TStream);
function BFEncryptStringExA(const InString : AnsiString; const Key : TKey128; Encrypt : Boolean) : AnsiString;
function BFEncryptStringEx(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey128; Encrypt : Boolean) : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
{$IFDEF UNICODE}
function BFEncryptStringExW(const InString : UnicodeString; const Key : TKey128; Encrypt : Boolean) : UnicodeString;
{$ENDIF}
function BFEncryptStringCBCExA(const InString : AnsiString; const Key : TKey128; Encrypt : Boolean) : AnsiString;
function BFEncryptStringCBCEx(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey128; Encrypt : Boolean) : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
{$IFDEF UNICODE}
function BFEncryptStringCBCExW(const InString : UnicodeString; const Key : TKey128; Encrypt : Boolean) : UnicodeString;
{$ENDIF}
procedure BFEncryptString(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF}; var OutString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey128; Encrypt : Boolean);
procedure BFEncryptStringA(const InString : AnsiString; var OutString : AnsiString; const Key : TKey128; Encrypt : Boolean);
{$IFDEF UNICODE}
procedure BFEncryptStringW(const InString : UnicodeString; var OutString : UnicodeString; const Key : TKey128; Encrypt : Boolean);
{$ENDIF}
procedure BFEncryptStringCBC(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF}; var OutString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey128; Encrypt : Boolean);
procedure BFEncryptStringCBCA(const InString : AnsiString; var OutString : AnsiString; const Key : TKey128; Encrypt : Boolean);
{$IFDEF UNICODE}
procedure BFEncryptStringCBCW(const InString : UnicodeString; var OutString : UnicodeString; const Key : TKey128; Encrypt : Boolean);
{$ENDIF}
{$IFDEF UNICODE}
function DESEncryptStringExW(const InString : UnicodeString; const Key : TKey64; Encrypt : Boolean) : UnicodeString;
{$ENDIF}
function DESEncryptStringExA(const InString : AnsiString; const Key : TKey64; Encrypt : Boolean) : AnsiString;
function DESEncryptStringEx(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey64; Encrypt : Boolean) : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
{$IFDEF UNICODE}
function DESEncryptStringCBCExW(const InString : UnicodeString; const Key : TKey64; Encrypt : Boolean) : UnicodeString;
{$ENDIF}
function DESEncryptStringCBCExA(const InString : AnsiString; const Key : TKey64; Encrypt : Boolean) : AnsiString;
function DESEncryptStringCBCEx(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey64; Encrypt : Boolean) : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
procedure DESEncryptString(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF}; var OutString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey64; Encrypt : Boolean);
procedure DESEncryptStringA(const InString : AnsiString; var OutString : AnsiString; const Key : TKey64; Encrypt : Boolean);
{$IFDEF UNICODE}
procedure DESEncryptStringW(const InString : UnicodeString; var OutString : UnicodeString; const Key : TKey64; Encrypt : Boolean);
{$ENDIF}
procedure DESEncryptStringCBC(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF}; var OutString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey64; Encrypt : Boolean);
procedure DESEncryptStringCBCA(const InString : AnsiString; var OutString : AnsiString; const Key : TKey64; Encrypt : Boolean);
{$IFDEF UNICODE}
procedure DESEncryptStringCBCW(const InString : UnicodeString; var OutString : UnicodeString; const Key : TKey64; Encrypt : Boolean);
{$ENDIF}
{$IFDEF UNICODE}
function TripleDESEncryptStringExW(const InString : UnicodeString; const Key : TKey128; Encrypt : Boolean) : UnicodeString;
{$ENDIF}
function TripleDESEncryptStringExA(const InString : AnsiString; const Key : TKey128; Encrypt : Boolean) : AnsiString;
function TripleDESEncryptStringEx(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey128; Encrypt : Boolean) : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
{$IFDEF UNICODE}
function TripleDESEncryptStringCBCExW(const InString : UnicodeString; const Key : TKey128; Encrypt : Boolean) : UnicodeString;
{$ENDIF}
function TripleDESEncryptStringCBCExA(const InString : AnsiString; const Key : TKey128; Encrypt : Boolean) : AnsiString;
function TripleDESEncryptStringCBCEx(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey128; Encrypt : Boolean) : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
procedure TripleDESEncryptString(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF}; var OutString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey128; Encrypt : Boolean);
procedure TripleDESEncryptStringA(const InString : AnsiString; var OutString : AnsiString; const Key : TKey128; Encrypt : Boolean);
{$IFDEF UNICODE}
procedure TripleDESEncryptStringW(const InString : UnicodeString; var OutString : UnicodeString; const Key : TKey128; Encrypt : Boolean);
{$ENDIF}
procedure TripleDESEncryptStringCBC(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF}; var OutString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey128; Encrypt : Boolean);
procedure TripleDESEncryptStringCBCA(const InString : AnsiString; var OutString : AnsiString; const Key : TKey128; Encrypt : Boolean);
{$IFDEF UNICODE}
procedure TripleDESEncryptStringCBCW(const InString : UnicodeString; var OutString : UnicodeString; const Key : TKey128; Encrypt : Boolean);
{$ENDIF}
{$IFDEF UNICODE}
function RDLEncryptStringExW(const InString : UnicodeString; const Key; KeySize : Longint; Encrypt : Boolean) : UnicodeString;
{$ENDIF}
function RDLEncryptStringExA(const InString : AnsiString; const Key; KeySize : Longint; Encrypt : Boolean) : AnsiString;
function RDLEncryptStringEx(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key; KeySize : Longint; Encrypt : Boolean) : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
{$IFDEF UNICODE}
function RDLEncryptStringCBCExW(const InString : UnicodeString; const Key; KeySize : Longint; Encrypt : Boolean) : UnicodeString;
{$ENDIF}
function RDLEncryptStringCBCExA(const InString : AnsiString; const Key; KeySize : Longint; Encrypt : Boolean) : AnsiString;
function RDLEncryptStringCBCEx(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key; KeySize : Longint; Encrypt : Boolean) : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
procedure RDLEncryptString(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF}; var OutString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key; KeySize : Longint; Encrypt : Boolean);
procedure RDLEncryptStringA(const InString : AnsiString; var OutString : AnsiString; const Key; KeySize : Longint; Encrypt : Boolean);
{$IFDEF UNICODE}
procedure RDLEncryptStringW(const InString : UnicodeString; var OutString : UnicodeString; const Key; KeySize : Longint; Encrypt : Boolean);
{$ENDIF}
procedure RDLEncryptStringCBC(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF}; var OutString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key; KeySize : Longint; Encrypt : Boolean);
procedure RDLEncryptStringCBCA(const InString : AnsiString; var OutString : AnsiString; const Key; KeySize : Longint; Encrypt : Boolean);
{$IFDEF UNICODE}
procedure RDLEncryptStringCBCW(const InString : UnicodeString; var OutString : UnicodeString; const Key; KeySize : Longint; Encrypt : Boolean);
{$ENDIF}
procedure RSADecodeBlock(biBlock : TLbBigInt);
procedure RSAFormatBlock(biBlock : TLbBigInt; BlockType : TRSABlockType);
procedure RSAEncryptBigInt(biBlock : TLbBigInt; Key : TLbRSAKey; BlockType : TRSABlockType; Encrypt : Boolean);
procedure GenerateRSAKeysEx(var PrivateKey, PublicKey : TLbRSAKey; KeySize : TLbAsymKeySize; PrimeTestIterations : Byte; Callback : TLbRSACallback);
procedure GenerateRSAKeys(var PrivateKey, PublicKey : TLbRSAKey);
function EncryptRSAEx(PublicKey : TLbRSAKey; pInBlock, pOutBlock : PByteArray; InDataSize : Integer) : Longint;
function DecryptRSAEx(PrivateKey : TLbRSAKey; pInBlock, pOutBlock : PByteArray) : Longint;
function  EncryptRSA128(PublicKey : TLbRSAKey; const InBlock : TRSAPlainBlock128; var OutBlock : TRSACipherBlock128) : Longint;
function  DecryptRSA128(PrivateKey : TLbRSAKey; const InBlock : TRSACipherBlock128; var OutBlock : TRSAPlainBlock128) : Longint;
function  EncryptRSA256(PublicKey : TLbRSAKey; const InBlock : TRSAPlainBlock256; var OutBlock : TRSACipherBlock256) : Longint;
function  DecryptRSA256(PrivateKey : TLbRSAKey; const InBlock : TRSACipherBlock256; var OutBlock : TRSAPlainBlock256) : Longint;
function  EncryptRSA512(PublicKey : TLbRSAKey; const InBlock : TRSAPlainBlock512; var OutBlock : TRSACipherBlock512) : Longint;
function  DecryptRSA512(PrivateKey : TLbRSAKey; const InBlock : TRSACipherBlock512; var OutBlock : TRSAPlainBlock512) : Longint;
function  EncryptRSA768(PublicKey : TLbRSAKey; const InBlock : TRSAPlainBlock768; var OutBlock : TRSACipherBlock768) : Longint;
function  DecryptRSA768(PrivateKey : TLbRSAKey; const InBlock : TRSACipherBlock768; var OutBlock : TRSAPlainBlock768) : Longint;
function  EncryptRSA1024(PublicKey : TLbRSAKey; const InBlock : TRSAPlainBlock1024; var OutBlock : TRSACipherBlock1024) : Longint;
function  DecryptRSA1024(PrivateKey : TLbRSAKey; const InBlock : TRSACipherBlock1024; var OutBlock : TRSAPlainBlock1024) : Longint;
function EncryptRSA(PublicKey : TLbRSAKey; const InBlock : TRSAPlainBlock; var OutBlock : TRSACipherBlock) : Longint;
function DecryptRSA(PrivateKey : TLbRSAKey; const InBlock : TRSACipherBlock; var OutBlock : TRSAPlainBlock) : Longint;
procedure RSAEncryptStream(InStream, OutStream : TStream; Key : TLbRSAKey; Encrypt : Boolean);
procedure RSAEncryptFile(const InFile, OutFile : string; Key : TLbRSAKey; Encrypt : Boolean);
function RSAEncryptStringA(const InString : AnsiString; Key : TLbRSAKey; Encrypt : Boolean) : AnsiString;
function RSAEncryptString(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            Key : TLbRSAKey; Encrypt : Boolean) : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
{$IFDEF UNICODE}
function RSAEncryptStringW(const InString : UnicodeString; Key : TLbRSAKey; Encrypt : Boolean) : UnicodeString;
{$ENDIF}




implementation

{$IFDEF UNICODE}
function RSAEncryptStringW(const InString : UnicodeString; Key : TLbRSAKey; Encrypt : Boolean) : UnicodeString;
var
  InStream  : TMemoryStream;
  OutStream : TMemoryStream;
  WorkStream : TMemoryStream;
begin
  InStream := TMemoryStream.Create;
  OutStream := TMemoryStream.Create;
  WorkStream := TMemoryStream.Create;
  InStream.Write(InString[1], Length(InString) * SizeOf(WideChar));
  InStream.Position := 0;

  if Encrypt then begin
    RSAEncryptStream(InStream, WorkStream, Key, True);
    WorkStream.Position := 0;
    LbEncodeBase64W(WorkStream, OutStream);
  end else begin
    LbDecodeBase64W(InStream, WorkStream);
    WorkStream.Position := 0;
    RSAEncryptStream(WorkStream, OutStream, Key, False);
  end;
  OutStream.Position := 0;
  SetLength(Result, OutStream.Size div SizeOf(Char));
  OutStream.Read(Result[1], OutStream.Size);

  InStream.Free;
  OutStream.Free;
  WorkStream.Free;
end;
{$ENDIF}

function RSAEncryptString(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            Key : TLbRSAKey; Encrypt : Boolean) : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
begin
  {$IFDEF LOCKBOXUNICODE}
  Result := RSAEncryptStringW(InString, Key, Encrypt);
  {$ELSE}
  Result := RSAEncryptStringA(InString, Key, Encrypt);
  {$ENDIF}
end;

function RSAEncryptStringA(const InString : AnsiString; Key : TLbRSAKey; Encrypt : Boolean) : AnsiString;
var
  InStream  : TMemoryStream;
  OutStream : TMemoryStream;
  WorkStream : TMemoryStream;
begin
  InStream := TMemoryStream.Create;
  OutStream := TMemoryStream.Create;
  WorkStream := TMemoryStream.Create;
  InStream.Write(InString[1], Length(InString) * SizeOf(AnsiChar));
  InStream.Position := 0;

  if Encrypt then begin
    RSAEncryptStream(InStream, WorkStream, Key, True);
    WorkStream.Position := 0;
    LbEncodeBase64A(WorkStream, OutStream);
  end else begin
    LbDecodeBase64A(InStream, WorkStream);
    WorkStream.Position := 0;
    RSAEncryptStream(WorkStream, OutStream, Key, False);
  end;
  OutStream.Position := 0;
  SetLength(Result, OutStream.Size div SizeOf(AnsiChar));
  OutStream.Read(Result[1], OutStream.Size);

  InStream.Free;
  OutStream.Free;
  WorkStream.Free;
end;


procedure RSAEncryptFile(const InFile, OutFile : string; Key : TLbRSAKey; Encrypt : Boolean);
var
  InStream, OutStream : TStream;
begin
  InStream := TFileStream.Create(InFile, fmOpenRead or fmShareDenyWrite);
  try
    OutStream := TFileStream.Create(OutFile, fmCreate);
    try
      RSAEncryptStream(InStream, OutStream, Key, Encrypt);
    finally
      OutStream.Free;
    end;
  finally
    InStream.Free;
  end;
end;

procedure RSAEncryptStream(InStream, OutStream : TStream; Key : TLbRSAKey; Encrypt : Boolean);
var
  InBlkCount  : Integer;
  InBlkSize, OutBlkSize : Integer;
  PlainBlockSize, CipherBlockSize : Integer;
  i : Integer;
  pInBlk, pOutBlk       : Pointer;
  PlainBlock, CipherBlock : TRSACipherBlock1024;
begin
  PlainBlockSize := cRSAPlainBlockSize[Key.KeySize];
  CipherBlockSize := cRSACipherBlockSize[Key.KeySize];
  if Encrypt then begin
    pInBlk := @PlainBlock;
    pOutBlk := @CipherBlock;
    InBlkSize := PlainBlockSize;
    OutBlkSize := CipherBlockSize;
  end else begin
    pInBlk := @CipherBlock;
    pOutBlk := @PlainBlock;
    InBlkSize := CipherBlockSize;
    OutBlkSize := PlainBlockSize;
  end;

  InBlkCount := InStream.Size div InBlkSize;
  if (InStream.Size mod InBlkSize) > 0 then
    Inc(InBlkCount);
  for i := 1 to (InBlkCount - 1) do begin
    InStream.Read(pInBlk^, InBlkSize);
    if Encrypt then
      EncryptRSAEx(Key, pInBlk, pOutBlk, InBlkSize)
    else
      DecryptRSAEx(Key, pInBlk, pOutBlk);
    OutStream.Write(pOutBlk^, OutBlkSize);
  end;

  i := InStream.Read(pInBlk^, InBlkSize);
  if Encrypt then
    i := EncryptRSAEx(Key, pInBlk, pOutBlk, i)
  else
    i := DecryptRSAEx(Key, pInBlk, pOutBlk);
  OutStream.Write(pOutBlk^, i);
end;

function DecryptRSA(PrivateKey : TLbRSAKey; const InBlock : TRSACipherBlock; var OutBlock : TRSAPlainBlock) : Longint;
begin
  Result := DecryptRSA512(PrivateKey, InBlock, OutBlock);
end;

function EncryptRSA(PublicKey : TLbRSAKey; const InBlock : TRSAPlainBlock; var OutBlock : TRSACipherBlock) : Longint;
begin
  Result := EncryptRSA512(PublicKey, InBlock, OutBlock);
end;

function  DecryptRSA1024(PrivateKey : TLbRSAKey; const InBlock : TRSACipherBlock1024; var OutBlock : TRSAPlainBlock1024) : Longint;
begin
  if (PrivateKey.KeySize <> aks1024) then
    raise Exception.Create(sRSABlockSize1024Err);
  Result := DecryptRSAEx(PrivateKey, @InBlock, @OutBlock);
end;

function  EncryptRSA1024(PublicKey : TLbRSAKey; const InBlock : TRSAPlainBlock1024; var OutBlock : TRSACipherBlock1024) : Longint;
begin
  if (PublicKey.KeySize <> aks1024) then
    raise Exception.Create(sRSABlockSize1024Err);
  Result := EncryptRSAEx(PublicKey, @InBlock, @OutBlock, SizeOf(InBlock));
end;

function  DecryptRSA768(PrivateKey : TLbRSAKey; const InBlock : TRSACipherBlock768; var OutBlock : TRSAPlainBlock768) : Longint;
begin
  if (PrivateKey.KeySize <> aks768) then
    raise Exception.Create(sRSABlockSize768Err);
  Result := DecryptRSAEx(PrivateKey, @InBlock, @OutBlock);
end;

function  EncryptRSA768(PublicKey : TLbRSAKey; const InBlock : TRSAPlainBlock768; var OutBlock : TRSACipherBlock768) : Longint;
begin
  if (PublicKey.KeySize <> aks768) then
    raise Exception.Create(sRSABlockSize768Err);
  Result := EncryptRSAEx(PublicKey, @InBlock, @OutBlock, SizeOf(InBlock));
end;

function  DecryptRSA512(PrivateKey : TLbRSAKey; const InBlock : TRSACipherBlock512; var OutBlock : TRSAPlainBlock512) : Longint;
begin
  if (PrivateKey.KeySize <> aks512) then
    raise Exception.Create(sRSABlockSize512Err);
  Result := DecryptRSAEx(PrivateKey, @InBlock, @OutBlock);
end;

function  EncryptRSA512(PublicKey : TLbRSAKey; const InBlock : TRSAPlainBlock512; var OutBlock : TRSACipherBlock512) : Longint;
begin
  if (PublicKey.KeySize <> aks512) then
    raise Exception.Create(sRSABlockSize512Err);
  Result := EncryptRSAEx(PublicKey, @InBlock, @OutBlock, SizeOf(InBlock));
end;

function  DecryptRSA256(PrivateKey : TLbRSAKey; const InBlock : TRSACipherBlock256; var OutBlock : TRSAPlainBlock256) : Longint;
begin
  if (PrivateKey.KeySize <> aks256) then
    raise Exception.Create(sRSABlockSize256Err);
  Result := DecryptRSAEx(PrivateKey, @InBlock, @OutBlock);
end;

function  EncryptRSA256(PublicKey : TLbRSAKey; const InBlock : TRSAPlainBlock256; var OutBlock : TRSACipherBlock256) : Longint;
begin
  if (PublicKey.KeySize <> aks256) then
    raise Exception.Create(sRSABlockSize256Err);
  Result := EncryptRSAEx(PublicKey, @InBlock, @OutBlock, SizeOf(InBlock));
end;

function  DecryptRSA128(PrivateKey : TLbRSAKey; const InBlock : TRSACipherBlock128; var OutBlock : TRSAPlainBlock128) : Longint;
begin
  if (PrivateKey.KeySize <> aks128) then
    raise Exception.Create(sRSABlockSize128Err);
  Result := DecryptRSAEx(PrivateKey, @InBlock, @OutBlock);
end;

function  EncryptRSA128(PublicKey : TLbRSAKey; const InBlock : TRSAPlainBlock128; var OutBlock : TRSACipherBlock128) : Longint;
begin
  if (PublicKey.KeySize <> aks128) then
    raise Exception.Create(sRSABlockSize128Err);
  Result := EncryptRSAEx(PublicKey, @InBlock, @OutBlock, SizeOf(InBlock));
end;

function DecryptRSAEx(PrivateKey : TLbRSAKey; pInBlock, pOutBlock : PByteArray) : Longint;
var
  biBlock : TLbBigInt;
  InSize, OutSize : DWord;
begin
  InSize := cRSACipherBlockSize[PrivateKey.KeySize];
  OutSize := cRSAPlainBlockSize[PrivateKey.KeySize];
  biBlock := TLbBigInt.Create(InSize);
  try
    biBlock.CopyBuffer(pInBlock^, InSize);
    RSAEncryptBigInt(biBlock, PrivateKey, bt02, False);
    if Integer(OutSize) < biBlock.Size then
      raise Exception.Create('OutBlock size too small');

    biBlock.ToBuffer(pOutBlock^, biBlock.Size);
  finally
    Result := biBlock.Size;
    biBlock.Free;
  end;
end;

function EncryptRSAEx(PublicKey : TLbRSAKey; pInBlock, pOutBlock : PByteArray; InDataSize : Integer) : Longint;
var
  biBlock : TLbBigInt;
  OutSize : DWord;
begin
  OutSize := cRSACipherBlockSize[PublicKey.KeySize];
  biBlock := TLbBigInt.Create(OutSize);
  try
    biBlock.CopyBuffer(pInBlock^, InDataSize);
    RSAEncryptBigInt(biBlock, PublicKey, bt02, True);
    if Integer(OutSize) < biBlock.Size then
      raise Exception.Create('OutBlock size too small');

    biBlock.ToBuffer(pOutBlock^, biBlock.Size);
  finally
    Result := biBlock.Size;
    biBlock.Free;
  end;
end;

procedure GenerateRSAKeys(var PrivateKey, PublicKey : TLbRSAKey);
begin
  GenerateRSAKeysEx(PrivateKey, PublicKey, cLbDefAsymKeySize, cDefIterations, nil);
end;

procedure GenerateRSAKeysEx(var PrivateKey, PublicKey : TLbRSAKey; KeySize : TLbAsymKeySize; PrimeTestIterations : Byte; Callback : TLbRSACallback);
var
  q : TLbBigInt;
  p : TLbBigInt;
  p1q1 : TLbBigInt;
  d : TLbBigInt;
  e : TLbBigInt;
  n : TLbBigInt;
  Abort : Boolean;
begin
  PrivateKey := TLbRSAKey.Create(KeySize);
  PublicKey := TLbRSAKey.Create(KeySize);
  p1q1 := TLbBigInt.Create(cLbAsymKeyBytes[KeySize]);
  d := TLbBigInt.Create(cLbAsymKeyBytes[KeySize]);
  e := TLbBigInt.Create(cLbAsymKeyBytes[KeySize]);
  n := TLbBigInt.Create(cLbAsymKeyBytes[KeySize]);
  p := TLbBigInt.Create(cLbAsymKeyBytes[KeySize] div 2);
  q := TLbBigInt.Create(cLbAsymKeyBytes[KeySize] div 2);

  try
    Abort := False;
    repeat
      repeat
        p.RandomPrime(PrimeTestIterations);
        if Assigned(Callback) then
          Callback(Abort);
        if Abort then
          Exit;
        q.RandomPrime(PrimeTestIterations);
        if Assigned(Callback) then
          Callback(Abort);
        if Abort then
          Exit;
      until (p.Compare(q) <> 0);
      { n = pq }
      n.Copy(p);
      n.Multiply(q);
      { p1q1 = (p-1)(q-1) }
      p.SubtractByte($01);
      q.SubtractByte($01);
      p1q1.Copy(p);
      p1q1.Multiply(q);
      { e = randomly chosen simple prime > 3 }
      e.RandomSimplePrime;
      { d = inverse(e) mod (p-1)(q-1) }
      d.Copy(e);
    until d.ModInv(p1q1);
    { assign n and d to private key }
    PrivateKey.Modulus.Copy(n);
    PrivateKey.Exponent.Copy(d);
    { assign n and e to public key }
    PublicKey.Modulus.Copy(n);
    PublicKey.Exponent.Copy(e);
  finally
    p1q1.Free;
    d.Free;
    e.Free;
    n.Free;
    p.Free;
    q.Free;
  end;
end;

procedure RSAEncryptBigInt(biBlock : TLbBigInt; Key : TLbRSAKey; BlockType : TRSABlockType; Encrypt : Boolean);
var
  dwSize, dwLen : DWORD;
  tmp1, tmp2 : TLbBigInt;
begin
  tmp1 := TLbBigInt.Create(cLbAsymKeyBytes[Key.KeySize]);
  tmp2 := TLbBigInt.Create(cLbAsymKeyBytes[Key.KeySize]);
  try
    if Encrypt then
      RSAFormatBlock(biBlock, BlockType);
    tmp1.Copy(biBlock);
    dwSize := tmp1.Size;
    biBlock.Clear;
    repeat
      dwLen := Min(dwSize, Key.Modulus.Size);
      tmp2.CopyLen(tmp1, dwLen);
      tmp2.PowerAndMod(Key.Exponent, Key.Modulus);

      biBlock.Append(tmp2);
      tmp1.Shr_(dwLen * 8);
      dwSize := dwSize - dwLen;
    until (dwSize <= 0);

    if Encrypt then
      while (biBlock.Size < cLbAsymKeyBytes[Key.KeySize]) do
        biBlock.AppendByte($00)
    else
      RSADecodeBlock(biBlock);
  finally
    tmp1.Free;
    tmp2.Free;
  end;
end;

procedure RSAFormatBlock(biBlock : TLbBigInt; BlockType : TRSABlockType);
begin
  if (biBlock.Int.IntBuf.dwLen - biBlock.Int.dwUsed) < 11 then
    raise Exception.Create(sRSAEncodingErr);
  biBlock.AppendByte($00);
  while (biBlock.Int.IntBuf.dwLen - biBlock.Int.dwUsed) > 2 do begin
    if (BlockType = bt01) then
      biBlock.AppendByte(Byte($FF))
    else
      biBlock.AppendByte(Byte(Random($FD) + 1));
  end;
  if (BlockType = bt01) then
    biBlock.AppendByte($01)
  else
    biBlock.AppendByte($02);
  biBlock.AppendByte($00);
end;

procedure RSADecodeBlock(biBlock : TLbBigInt);
var
  i : DWord;
  Buf : TRSAPlainBlock1024;
begin
  i := biBlock.Size;
  if (i < cRSAMinPadBytes) then
    raise Exception.Create(sRSADecodingErrBTS);
  if (i > cBytes1024) then
    raise Exception.Create(sRSADecodingErrBTL);
  if (biBlock.GetByteValue(i) <> Byte(bt01)) and (biBlock.GetByteValue(i) <> Byte(bt02)) then
    raise Exception.Create(sRSADecodingErrIBT);
  Dec(i);
  while (biBlock.GetByteValue(i) <> 0) do begin
    Dec(i);
    if (i <= 0) then
    raise Exception.Create(sRSADecodingErrIBF);
  end;
  biBlock.ToBuffer(Buf, i-1);
  biBlock.CopyBuffer(Buf, i-1);
end;

{$IFDEF UNICODE}
procedure RDLEncryptStringCBCW(const InString : UnicodeString; var OutString : UnicodeString; const Key; KeySize : Longint; Encrypt : Boolean);
begin
  OutString := RDLEncryptStringCBCExW(InString, Key, KeySize, Encrypt);
end;
{$ENDIF}

procedure RDLEncryptStringCBCA(const InString : AnsiString; var OutString : AnsiString; const Key; KeySize : Longint; Encrypt : Boolean);
begin
  OutString := RDLEncryptStringCBCExA(InString, Key, KeySize, Encrypt);
end;

procedure RDLEncryptStringCBC(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF}; var OutString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key; KeySize : Longint; Encrypt : Boolean);
begin
  OutString := RDLEncryptStringCBCEx(InString, Key, KeySize, Encrypt);
end;

{$IFDEF UNICODE}
procedure RDLEncryptStringW(const InString : UnicodeString; var OutString : UnicodeString;
            const Key; KeySize : Longint; Encrypt : Boolean);
begin
  OutString := RDLEncryptStringExW(InString, Key, KeySize, Encrypt);
end;
{$ENDIF}


procedure RDLEncryptStringA(const InString : AnsiString; var OutString : AnsiString; const Key; KeySize : Longint; Encrypt : Boolean);
begin
  OutString := RDLEncryptStringExA(InString, Key, KeySize, Encrypt);
end;

procedure RDLEncryptString(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF}; var OutString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key; KeySize : Longint; Encrypt : Boolean);
begin
  OutString := RDLEncryptStringEx(InString, Key, KeySize, Encrypt);
end;

function RDLEncryptStringCBCEx(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key; KeySize : Longint; Encrypt : Boolean) : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
begin
  {$IFDEF LOCKBOXUNICODE}
  Result := RDLEncryptStringCBCExW(InString, Key, KeySize, Encrypt);
  {$ELSE}
  Result := RDLEncryptStringCBCExA(InString, Key, KeySize, Encrypt);
  {$ENDIF}
end;

function RDLEncryptStringCBCExA(const InString : AnsiString; const Key; KeySize : Longint; Encrypt : Boolean) : AnsiString;
var
  InStream  : TMemoryStream;
  OutStream : TMemoryStream;
  WorkStream : TMemoryStream;
begin
  InStream := TMemoryStream.Create;
  OutStream := TMemoryStream.Create;
  WorkStream := TMemoryStream.Create;
  InStream.Write(InString[1], Length(InString) * SizeOf(AnsiChar));
  InStream.Position := 0;

  if Encrypt then begin
    RDLEncryptStreamCBC(InStream, WorkStream, Key, KeySize, True);
    WorkStream.Position := 0;
    LbEncodeBase64A(WorkStream, OutStream);
  end else begin
    LbDecodeBase64A(InStream, WorkStream);
    WorkStream.Position := 0;
    RDLEncryptStreamCBC(WorkStream, OutStream, Key, KeySize, False);
  end;
  OutStream.Position := 0;
  SetLength(Result, OutStream.Size div SizeOf(AnsiChar));
  OutStream.Read(Result[1], OutStream.Size);

  InStream.Free;
  OutStream.Free;
  WorkStream.Free;
end;

{$IFDEF UNICODE}
function RDLEncryptStringCBCExW(const InString : UnicodeString; const Key; KeySize : Longint; Encrypt : Boolean) : UnicodeString;
var
  InStream  : TMemoryStream;
  OutStream : TMemoryStream;
  WorkStream : TMemoryStream;
begin
  InStream := TMemoryStream.Create;
  OutStream := TMemoryStream.Create;
  WorkStream := TMemoryStream.Create;
  InStream.Write(InString[1], Length(InString) * SizeOf(WideChar));
  InStream.Position := 0;

  if Encrypt then begin
    RDLEncryptStreamCBC(InStream, WorkStream, Key, KeySize, True);
    WorkStream.Position := 0;
    LbEncodeBase64W(WorkStream, OutStream);
  end else begin
    LbDecodeBase64W(InStream, WorkStream);
    WorkStream.Position := 0;
    RDLEncryptStreamCBC(WorkStream, OutStream, Key, KeySize, False);
  end;
  OutStream.Position := 0;
  SetLength(Result, OutStream.Size div SizeOf(WideChar));
  OutStream.Read(Result[1], OutStream.Size);

  InStream.Free;
  OutStream.Free;
  WorkStream.Free;
end;
{$ENDIF}

function RDLEncryptStringEx(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key; KeySize : Longint; Encrypt : Boolean) : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
begin
  {$IFDEF LOCKBOXUNICODE}
  Result := RDLEncryptStringExW(InString, Key, KeySize, Encrypt);
  {$ELSE}
  Result := RDLEncryptStringExA(InString, Key, KeySize, Encrypt);
  {$ENDIF}
end;

function RDLEncryptStringExA(const InString : AnsiString; const Key; KeySize : Longint; Encrypt : Boolean) : AnsiString;
var
  InStream  : TMemoryStream;
  OutStream : TMemoryStream;
  WorkStream : TMemoryStream;
begin
  InStream := TMemoryStream.Create;
  OutStream := TMemoryStream.Create;
  WorkStream := TMemoryStream.Create;
  InStream.Write(InString[1], Length(InString) * SizeOf(AnsiChar));
  InStream.Position := 0;

  if Encrypt then begin
    RDLEncryptStream(InStream, WorkStream, Key, KeySize, True);
    WorkStream.Position := 0;
    LbEncodeBase64A(WorkStream, OutStream);
  end else begin
    LbDecodeBase64A(InStream, WorkStream);
    WorkStream.Position := 0;
    RDLEncryptStream(WorkStream, OutStream, Key, KeySize, False);
  end;
  OutStream.Position := 0;
  SetLength(Result, OutStream.Size div SizeOf(AnsiChar));
  OutStream.Read(Result[1], OutStream.Size);

  InStream.Free;
  OutStream.Free;
  WorkStream.Free;
end;

{$IFDEF UNICODE}
function RDLEncryptStringExW(const InString : UnicodeString; const Key; KeySize : Longint; Encrypt : Boolean) : UnicodeString;
var
  InStream  : TMemoryStream;
  OutStream : TMemoryStream;
  WorkStream : TMemoryStream;
begin
  InStream := TMemoryStream.Create;
  OutStream := TMemoryStream.Create;
  WorkStream := TMemoryStream.Create;
  InStream.Write(InString[1], Length(InString) * SizeOf(WideChar));
  InStream.Position := 0;

  if Encrypt then begin
    RDLEncryptStream(InStream, WorkStream, Key, KeySize, True);
    WorkStream.Position := 0;
    LbEncodeBase64W(WorkStream, OutStream);
  end else begin
    LbDecodeBase64W(InStream, WorkStream);
    WorkStream.Position := 0;
    RDLEncryptStream(WorkStream, OutStream, Key, KeySize, False);
  end;
  OutStream.Position := 0;
  SetLength(Result, OutStream.Size div SizeOf(WideChar));
  OutStream.Read(Result[1], OutStream.Size);

  InStream.Free;
  OutStream.Free;
  WorkStream.Free;
end;
{$ENDIF}

{$IFDEF UNICODE}
procedure TripleDESEncryptStringCBCW(const InString : UnicodeString; var OutString : UnicodeString; const Key : TKey128; Encrypt : Boolean);
begin
  OutString := TripleDESEncryptStringCBCExW(InString, Key, Encrypt);
end;
{$ENDIF}

procedure TripleDESEncryptStringCBCA(const InString : AnsiString; var OutString : AnsiString; const Key : TKey128; Encrypt : Boolean);
begin
  OutString := TripleDESEncryptStringCBCExA(InString, Key, Encrypt);
end;

procedure TripleDESEncryptStringCBC(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF}; var OutString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey128; Encrypt : Boolean);
begin
  OutString := TripleDESEncryptStringCBCEx(InString, Key, Encrypt);
end;

{$IFDEF UNICODE}
procedure TripleDESEncryptStringW(const InString : UnicodeString; var OutString : UnicodeString; const Key : TKey128; Encrypt : Boolean);
begin
  OutString := TripleDESEncryptStringExW(InString, Key, Encrypt);
end;
{$ENDIF}

procedure TripleDESEncryptStringA(const InString : AnsiString; var OutString : AnsiString; const Key : TKey128; Encrypt : Boolean);
begin
  OutString := TripleDESEncryptStringExA(InString, Key, Encrypt);
end;

procedure TripleDESEncryptString(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF}; var OutString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey128; Encrypt : Boolean);
begin
  OutString := TripleDESEncryptStringEx(InString, Key, Encrypt);
end;

function TripleDESEncryptStringCBCEx(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey128; Encrypt : Boolean) : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
begin
  {$IFDEF LOCKBOXUNICODE}
  Result := TripleDESEncryptStringCBCExW(InString, Key, Encrypt);
  {$ELSE}
  Result := TripleDESEncryptStringCBCExA(InString, Key, Encrypt);
  {$ENDIF}
end;

function TripleDESEncryptStringCBCExA(const InString : AnsiString; const Key : TKey128; Encrypt : Boolean) : AnsiString;
var
  InStream  : TMemoryStream;
  OutStream : TMemoryStream;
  WorkStream : TMemoryStream;
begin
  InStream := TMemoryStream.Create;
  OutStream := TMemoryStream.Create;
  WorkStream := TMemoryStream.Create;
  InStream.Write(InString[1], Length(InString) * SizeOf(AnsiChar));
  InStream.Position := 0;

  if Encrypt then begin
    TripleDESEncryptStreamCBC(InStream, WorkStream, Key, True);
    WorkStream.Position := 0;
    LbEncodeBase64A(WorkStream, OutStream);
  end else begin
    LbDecodeBase64A(InStream, WorkStream);
    WorkStream.Position := 0;
    TripleDESEncryptStreamCBC(WorkStream, OutStream, Key, False);
  end;
  OutStream.Position := 0;
  SetLength(Result, OutStream.Size div SizeOf(AnsiChar));
  OutStream.Read(Result[1], OutStream.Size);

  InStream.Free;
  OutStream.Free;
  WorkStream.Free;
end;

{$IFDEF UNICODE}
function TripleDESEncryptStringCBCExW(const InString : UnicodeString; const Key : TKey128; Encrypt : Boolean) : UnicodeString;
var
  InStream  : TMemoryStream;
  OutStream : TMemoryStream;
  WorkStream : TMemoryStream;
begin
  InStream := TMemoryStream.Create;
  OutStream := TMemoryStream.Create;
  WorkStream := TMemoryStream.Create;
  InStream.Write(InString[1], Length(InString) * SizeOf(WideChar));
  InStream.Position := 0;

  if Encrypt then begin
    TripleDESEncryptStreamCBC(InStream, WorkStream, Key, True);
    WorkStream.Position := 0;
    LbEncodeBase64W(WorkStream, OutStream);
  end else begin
    LbDecodeBase64W(InStream, WorkStream);
    WorkStream.Position := 0;
    TripleDESEncryptStreamCBC(WorkStream, OutStream, Key, False);
  end;
  OutStream.Position := 0;
  SetLength(Result, OutStream.Size div SizeOf(WideChar));
  OutStream.Read(Result[1], OutStream.Size);

  InStream.Free;
  OutStream.Free;
  WorkStream.Free;
end;
{$ENDIF}

function TripleDESEncryptStringEx(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey128; Encrypt : Boolean) : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
begin
  {$IFDEF LOCKBOXUNICODE}
  Result := TripleDESEncryptStringExW(InString, Key, Encrypt);
  {$ELSE}
  Result := TripleDESEncryptStringExA(InString, Key, Encrypt);
  {$ENDIF}
end;

function TripleDESEncryptStringExA(const InString : AnsiString; const Key : TKey128; Encrypt : Boolean) : AnsiString;
var
  InStream  : TMemoryStream;
  OutStream : TMemoryStream;
  WorkStream : TMemoryStream;
begin
  InStream := TMemoryStream.Create;
  OutStream := TMemoryStream.Create;
  WorkStream := TMemoryStream.Create;
  InStream.Write(InString[1], Length(InString) * SizeOf(AnsiChar));
  InStream.Position := 0;

  if Encrypt then begin
    TripleDESEncryptStream(InStream, WorkStream, Key, True);
    WorkStream.Position := 0;
    LbEncodeBase64A(WorkStream, OutStream);
  end else begin
    LbDecodeBase64A(InStream, WorkStream);
    WorkStream.Position := 0;
    TripleDESEncryptStream(WorkStream, OutStream, Key, False);
  end;
  OutStream.Position := 0;
  SetLength(Result, OutStream.Size div SizeOf(AnsiChar));
  OutStream.Read(Result[1], OutStream.Size);

  InStream.Free;
  OutStream.Free;
  WorkStream.Free;
end;

{$IFDEF UNICODE}
function TripleDESEncryptStringExW(const InString : UnicodeString; const Key : TKey128; Encrypt : Boolean) : UnicodeString;
var
  InStream  : TMemoryStream;
  OutStream : TMemoryStream;
  WorkStream : TMemoryStream;
begin
  InStream := TMemoryStream.Create;
  OutStream := TMemoryStream.Create;
  WorkStream := TMemoryStream.Create;
  InStream.Write(InString[1], Length(InString) * SizeOf(WideChar));
  InStream.Position := 0;

  if Encrypt then begin
    TripleDESEncryptStream(InStream, WorkStream, Key, True);
    WorkStream.Position := 0;
    LbEncodeBase64W(WorkStream, OutStream);
  end else begin
    LbDecodeBase64W(InStream, WorkStream);
    WorkStream.Position := 0;
    TripleDESEncryptStream(WorkStream, OutStream, Key, False);
  end;
  OutStream.Position := 0;
  SetLength(Result, OutStream.Size div SizeOf(WideChar));
  OutStream.Read(Result[1], OutStream.Size);

  InStream.Free;
  OutStream.Free;
  WorkStream.Free;
end;
{$ENDIF}

{$IFDEF UNICODE}
procedure DESEncryptStringCBCW(const InString : UnicodeString; var OutString : UnicodeString; const Key : TKey64; Encrypt : Boolean);
begin
  OutString := DESEncryptStringCBCExW(InString, Key, Encrypt);
end;
{$ENDIF}

procedure DESEncryptStringCBCA(const InString : AnsiString; var OutString : AnsiString; const Key : TKey64; Encrypt : Boolean);
begin
  OutString := DESEncryptStringCBCExA(InString, Key, Encrypt);
end;

procedure DESEncryptStringCBC(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF}; var OutString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey64; Encrypt : Boolean);
begin
  OutString := DESEncryptStringCBCEx(InString, Key, Encrypt);
end;

{$IFDEF UNICODE}
procedure DESEncryptStringW(const InString : UnicodeString; var OutString : UnicodeString; const Key : TKey64; Encrypt : Boolean);
begin
  OutString := DESEncryptStringExW(InString, Key, Encrypt);
end;
{$ENDIF}

procedure DESEncryptStringA(const InString : AnsiString; var OutString : AnsiString; const Key : TKey64; Encrypt : Boolean);
begin
  OutString := DESEncryptStringExA(InString, Key, Encrypt);
end;

procedure DESEncryptString(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF}; var OutString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey64; Encrypt : Boolean);
begin
  OutString := DESEncryptStringEx(InString, Key, Encrypt);
end;

function DESEncryptStringCBCEx(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey64; Encrypt : Boolean) : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
begin
  {$IFDEF LOCKBOXUNICODE}
  Result := DESEncryptStringCBCExW(InString, Key, Encrypt);
  {$ELSE}
  Result := DESEncryptStringCBCExA(InString, Key, Encrypt);
  {$ENDIF}
end;

function DESEncryptStringCBCExA(const InString : AnsiString; const Key : TKey64; Encrypt : Boolean) : AnsiString;
var
  InStream  : TMemoryStream;
  OutStream : TMemoryStream;
  WorkStream : TMemoryStream;
begin
  InStream := TMemoryStream.Create;
  OutStream := TMemoryStream.Create;
  WorkStream := TMemoryStream.Create;
  InStream.Write(InString[1], Length(InString) * SizeOf(AnsiChar));
  InStream.Position := 0;

  if Encrypt then begin
    DESEncryptStreamCBC(InStream, WorkStream, Key, True);
    WorkStream.Position := 0;
    LbEncodeBase64A(WorkStream, OutStream);
  end else begin
    LbDecodeBase64A(InStream, WorkStream);
    WorkStream.Position := 0;
    DESEncryptStreamCBC(WorkStream, OutStream, Key, False);
  end;
  OutStream.Position := 0;
  SetLength(Result, OutStream.Size div SizeOf(AnsiChar));
  OutStream.Read(Result[1], OutStream.Size);

  InStream.Free;
  OutStream.Free;
  WorkStream.Free;
end;

{$IFDEF UNICODE}
function DESEncryptStringCBCExW(const InString : UnicodeString; const Key : TKey64; Encrypt : Boolean) : UnicodeString;
var
  InStream  : TMemoryStream;
  OutStream : TMemoryStream;
  WorkStream : TMemoryStream;
begin
  InStream := TMemoryStream.Create;
  OutStream := TMemoryStream.Create;
  WorkStream := TMemoryStream.Create;
  InStream.Write(InString[1], Length(InString) * SizeOf(WideChar));
  InStream.Position := 0;

  if Encrypt then begin
    DESEncryptStreamCBC(InStream, WorkStream, Key, True);
    WorkStream.Position := 0;
    LbEncodeBase64W(WorkStream, OutStream);
  end else begin
    LbDecodeBase64W(InStream, WorkStream);
    WorkStream.Position := 0;
    DESEncryptStreamCBC(WorkStream, OutStream, Key, False);
  end;
  OutStream.Position := 0;
  SetLength(Result, OutStream.Size div SizeOf(WideChar));
  OutStream.Read(Result[1], OutStream.Size);

  InStream.Free;
  OutStream.Free;
  WorkStream.Free;
end;
{$ENDIF}

function DESEncryptStringEx(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey64; Encrypt : Boolean) : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
begin
  {$IFDEF LOCKBOXUNICODE}
  Result := DESEncryptStringExW(InString, Key, Encrypt);
  {$ELSE}
  Result := DESEncryptStringExA(InString, Key, Encrypt);
  {$ENDIF}
end;

function DESEncryptStringExA(const InString : AnsiString; const Key : TKey64; Encrypt : Boolean) : AnsiString;
var
  InStream  : TMemoryStream;
  OutStream : TMemoryStream;
  WorkStream : TMemoryStream;
begin
  InStream := TMemoryStream.Create;
  OutStream := TMemoryStream.Create;
  WorkStream := TMemoryStream.Create;
  InStream.Write(InString[1], Length(InString) * SizeOf(AnsiChar));
  InStream.Position := 0;

  if Encrypt then begin
    DESEncryptStream(InStream, WorkStream, Key, True);
    WorkStream.Position := 0;
    LbEncodeBase64A(WorkStream, OutStream);
  end else begin
    LbDecodeBase64A(InStream, WorkStream);
    WorkStream.Position := 0;
    DESEncryptStream(WorkStream, OutStream, Key, False);
  end;
  OutStream.Position := 0;
  SetLength(Result, OutStream.Size div SizeOf(AnsiChar));
  OutStream.Read(Result[1], OutStream.Size);

  InStream.Free;
  OutStream.Free;
  WorkStream.Free;
end;

{$IFDEF UNICODE}
function DESEncryptStringExW(const InString : UnicodeString;
            const Key : TKey64; Encrypt : Boolean) : UnicodeString;
var
  InStream  : TMemoryStream;
  OutStream : TMemoryStream;
  WorkStream : TMemoryStream;
begin
  InStream := TMemoryStream.Create;
  OutStream := TMemoryStream.Create;
  WorkStream := TMemoryStream.Create;
  InStream.Write(InString[1], Length(InString) * SizeOf(WideChar));
  InStream.Position := 0;

  if Encrypt then begin
    DESEncryptStream(InStream, WorkStream, Key, True);
    WorkStream.Position := 0;
    LbEncodeBase64W(WorkStream, OutStream);
  end else begin
    LbDecodeBase64W(InStream, WorkStream);
    WorkStream.Position := 0;
    DESEncryptStream(WorkStream, OutStream, Key, False);
  end;
  OutStream.Position := 0;
  SetLength(Result, OutStream.Size div SizeOf(WideChar));
  OutStream.Read(Result[1], OutStream.Size);

  InStream.Free;
  OutStream.Free;
  WorkStream.Free;
end;
{$ENDIF}

{$IFDEF UNICODE}
procedure BFEncryptStringCBCW(const InString : UnicodeString; var OutString : UnicodeString; const Key : TKey128; Encrypt : Boolean);
begin
  OutString := BFEncryptStringCBCExW(InString, Key, Encrypt);
end;
{$ENDIF}


procedure BFEncryptStringCBCA(const InString : AnsiString; var OutString : AnsiString; const Key : TKey128; Encrypt : Boolean);
begin
  OutString := BFEncryptStringCBCExA(InString, Key, Encrypt);
end;

procedure BFEncryptStringCBC(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF}; var OutString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey128; Encrypt : Boolean);
begin
  OutString := BFEncryptStringCBCEx(InString, Key, Encrypt);
end;

{$IFDEF UNICODE}
procedure BFEncryptStringW(const InString : UnicodeString; var OutString : UnicodeString; const Key : TKey128; Encrypt : Boolean);
begin
  OutString := BFEncryptStringExW(InString, Key, Encrypt);
end;
{$ENDIF}

procedure BFEncryptStringA(const InString : AnsiString; var OutString : AnsiString; const Key : TKey128; Encrypt : Boolean);
begin
  OutString := BFEncryptStringExA(InString, Key, Encrypt);
end;

procedure BFEncryptString(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF}; var OutString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey128; Encrypt : Boolean);
begin
  OutString := BFEncryptStringEx(InString, Key, Encrypt);
end;

{$IFDEF UNICODE}
function BFEncryptStringCBCExW(const InString : UnicodeString;
            const Key : TKey128; Encrypt : Boolean) : UnicodeString;
var
  InStream  : TMemoryStream;
  OutStream : TMemoryStream;
  WorkStream : TMemoryStream;
begin
  InStream := TMemoryStream.Create;
  OutStream := TMemoryStream.Create;
  WorkStream := TMemoryStream.Create;
  InStream.Write(InString[1], Length(InString) * SizeOf(WideChar));
  InStream.Position := 0;

  if Encrypt then begin
    BFEncryptStreamCBC(InStream, WorkStream, Key, True);
    WorkStream.Position := 0;
    LbEncodeBase64W(WorkStream, OutStream);
  end else begin
    LbDecodeBase64W(InStream, WorkStream);
    WorkStream.Position := 0;
    BFEncryptStreamCBC(WorkStream, OutStream, Key, False);
  end;
  OutStream.Position := 0;
  SetLength(Result, OutStream.Size div SizeOf(WideChar));
  OutStream.Read(Result[1], OutStream.Size);

  InStream.Free;
  OutStream.Free;
  WorkStream.Free;
end;
{$ENDIF}

function BFEncryptStringCBCEx(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey128; Encrypt : Boolean) : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
begin
  {$IFDEF LOCKBOXUNICODE}
  Result := BFEncryptStringCBCExW(InString, Key, Encrypt);
  {$ELSE}
  Result := BFEncryptStringCBCExA(InString, Key, Encrypt);
  {$ENDIF}
end;

function BFEncryptStringCBCExA(const InString : AnsiString; const Key : TKey128; Encrypt : Boolean) : AnsiString;
var
  InStream  : TMemoryStream;
  OutStream : TMemoryStream;
  WorkStream : TMemoryStream;
begin
  InStream := TMemoryStream.Create;
  OutStream := TMemoryStream.Create;
  WorkStream := TMemoryStream.Create;
  InStream.Write(InString[1], Length(InString) * SizeOf(AnsiChar));
  InStream.Position := 0;

  if Encrypt then begin
    BFEncryptStreamCBC(InStream, WorkStream, Key, True);
    WorkStream.Position := 0;
    LbEncodeBase64A(WorkStream, OutStream);
  end else begin
    LbDecodeBase64A(InStream, WorkStream);
    WorkStream.Position := 0;
    BFEncryptStreamCBC(WorkStream, OutStream, Key, False);
  end;
  OutStream.Position := 0;
  SetLength(Result, OutStream.Size div SizeOf(AnsiChar));
  OutStream.Read(Result[1], OutStream.Size);

  InStream.Free;
  OutStream.Free;
  WorkStream.Free;
end;

{$IFDEF UNICODE}
function BFEncryptStringExW(const InString : UnicodeString; const Key : TKey128; Encrypt : Boolean) : UnicodeString;
var
  InStream  : TMemoryStream;
  OutStream : TMemoryStream;
  WorkStream : TMemoryStream;
begin
  InStream := TMemoryStream.Create;
  OutStream := TMemoryStream.Create;
  WorkStream := TMemoryStream.Create;
  InStream.Write(InString[1], Length(InString) * SizeOf(WideChar));
  InStream.Position := 0;

  if Encrypt then begin
    BFEncryptStream(InStream, WorkStream, Key, True);
    WorkStream.Position := 0;
    LbEncodeBase64W(WorkStream, OutStream);
  end else begin
    LbDecodeBase64W(InStream, WorkStream);
    WorkStream.Position := 0;
    BFEncryptStream(WorkStream, OutStream, Key, False);
  end;
  OutStream.Position := 0;
  SetLength(Result, OutStream.Size div SizeOf(WideChar));
  OutStream.Read(Result[1], OutStream.Size);

  InStream.Free;
  OutStream.Free;
  WorkStream.Free;
end;
{$ENDIF}

function BFEncryptStringEx(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
            const Key : TKey128; Encrypt : Boolean) : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
begin
  {$IFDEF LOCKBOXUNICODE}
  Result := BFEncryptStringExW(InString, Key, Encrypt);
  {$ELSE}
  Result := BFEncryptStringExA(InString, Key, Encrypt);
  {$ENDIF}
end;

function BFEncryptStringExA(const InString : AnsiString; const Key : TKey128; Encrypt : Boolean) : AnsiString;
var
  InStream  : TMemoryStream;
  OutStream : TMemoryStream;
  WorkStream : TMemoryStream;
begin
  InStream := TMemoryStream.Create;
  OutStream := TMemoryStream.Create;
  WorkStream := TMemoryStream.Create;
  InStream.Write(InString[1], Length(InString) * SizeOf(AnsiChar));
  InStream.Position := 0;

  if Encrypt then begin
    BFEncryptStream(InStream, WorkStream, Key, True);
    WorkStream.Position := 0;
    LbEncodeBase64A(WorkStream, OutStream);
  end else begin
    LbDecodeBase64A(InStream, WorkStream);
    WorkStream.Position := 0;
    BFEncryptStream(WorkStream, OutStream, Key, False);
  end;
  OutStream.Position := 0;
  SetLength(Result, OutStream.Size div SizeOf(AnsiChar));
  OutStream.Read(Result[1], OutStream.Size);

  InStream.Free;
  OutStream.Free;
  WorkStream.Free;
end;

procedure LbEncodeBase64W(InStream, OutStream : TStream);
var
  I, O, Count : Integer;
  InBuf  : array[1..45] of Byte;
  OutBuf : array[0..62] of WideChar;
  Temp : Byte;
begin
  FillChar(OutBuf, Sizeof(OutBuf), #0);

  repeat
    Count := InStream.Read(InBuf, SizeOf(InBuf));
    if Count = 0 then Break;
    I := 1;
    O := 0;
    while I <= (Count-2) do begin
      Temp := (InBuf[I] shr 2);
      OutBuf[O] := WideChar(Lb64Table[Temp and $3F]);
      Temp := (InBuf[I] shl 4) or (InBuf[I+1] shr 4);
      OutBuf[O+1] := WideChar(Lb64Table[Temp and $3F]);
      Temp := (InBuf[I+1] shl 2) or (InBuf[I+2] shr 6);
      OutBuf[O+2] := WideChar(Lb64Table[Temp and $3F]);
      Temp := (InBuf[I+2] and $3F);
      OutBuf[O+3] := WideChar(Lb64Table[Temp]);

      Inc(I, 3);
      Inc(O, 4);
    end;
    if (I <= Count) then begin
      Temp := (InBuf[I] shr 2);
      OutBuf[O] := WideChar(Lb64Table[Temp and $3F]);
      if I = Count then begin
        Temp := (InBuf[I] shl 4) and $30;
        OutBuf[O+1] := WideChar(Lb64Table[Temp and $3F]);
        OutBuf[O+2] := '=';
      end else begin
        Temp := ((InBuf[I] shl 4) and $30) or ((InBuf[I+1] shr 4) and $0F);
        OutBuf[O+1] := WideChar(Lb64Table[Temp and $3F]);
        Temp := (InBuf[I+1] shl 2) and $3C;
        OutBuf[O+2] := WideChar(Lb64Table[Temp and $3F]);
      end;
      OutBuf[O+3] := '=';
      Inc(O, 4);
    end;
    OutStream.Write(OutBuf, O * SizeOf(Char));
  until Count < SizeOf(InBuf);
end;

procedure LbEncodeBase64A(InStream, OutStream : TStream);
var
  I, O, Count : Integer;
  InBuf  : array[1..45] of Byte;
  OutBuf : array[0..62] of AnsiChar;
  Temp : Byte;
begin
  FillChar(OutBuf, Sizeof(OutBuf), #0);

  repeat
    Count := InStream.Read(InBuf, SizeOf(InBuf));
    if Count = 0 then Break;
    I := 1;
    O := 0;
    while I <= (Count-2) do begin
      Temp := (InBuf[I] shr 2);
      OutBuf[O] := AnsiChar(Lb64Table[Temp and $3F]);
      Temp := (InBuf[I] shl 4) or (InBuf[I+1] shr 4);
      OutBuf[O+1] := AnsiChar(Lb64Table[Temp and $3F]);
      Temp := (InBuf[I+1] shl 2) or (InBuf[I+2] shr 6);
      OutBuf[O+2] := AnsiChar(Lb64Table[Temp and $3F]);
      Temp := (InBuf[I+2] and $3F);
      OutBuf[O+3] := AnsiChar(Lb64Table[Temp]);

      Inc(I, 3);
      Inc(O, 4);
    end;
    if (I <= Count) then begin
      Temp := (InBuf[I] shr 2);
      OutBuf[O] := AnsiChar(Lb64Table[Temp and $3F]);
      if I = Count then begin
        Temp := (InBuf[I] shl 4) and $30;
        OutBuf[O+1] := AnsiChar(Lb64Table[Temp and $3F]);
        OutBuf[O+2] := '=';
      end else begin
        Temp := ((InBuf[I] shl 4) and $30) or ((InBuf[I+1] shr 4) and $0F);
        OutBuf[O+1] := AnsiChar(Lb64Table[Temp and $3F]);
        Temp := (InBuf[I+1] shl 2) and $3C;
        OutBuf[O+2] := AnsiChar(Lb64Table[Temp and $3F]);
      end;
      OutBuf[O+3] := '=';
      Inc(O, 4);
    end;
    OutStream.Write(OutBuf, O * SizeOf(AnsiChar));
  until Count < SizeOf(InBuf);
end;

procedure LbDecodeBase64W(InStream, OutStream : TStream);
var
  I, O, Count, c1, c2, c3 : Byte;
  InBuf  : array[0..87] of Word;
  OutBuf : array[0..65] of Byte;
begin
  repeat
    O := 0;
    I := 0;

    Count := InStream.Read(InBuf, SizeOf(InBuf)) div 2;
    if (Count = 0) then
      Break;
    while I < Count do begin
      if (InBuf[I] < 43) or (InBuf[I] > 122) or
         (InBuf[I+1] < 43) or (InBuf[I+1] > 122) or
         (InBuf[I+2] < 43) or (InBuf[I+2] > 122) or
         (InBuf[I+3] < 43) or (InBuf[I+3] > 122) then
        raise Exception.Create('Invalid Base64 Character');

      c1 := LbD64Table[InBuf[I]];
      c2 := LbD64Table[InBuf[I+1]];
      c3 := LbD64Table[InBuf[I+2]];
      OutBuf[O] := ((c1 shl 2) or (c2 shr 4));
      Inc(O);
      if Char(InBuf[I+2]) <> '=' then begin
        OutBuf[O] := ((c2 shl 4) or (c3 shr 2));
        Inc(O);
        if Char(InBuf[I+3]) <> '=' then begin
          OutBuf[O] := ((c3 shl 6) or LbD64Table[InBuf[I+3]]);
          Inc(O);
        end;
      end;
      Inc(I, 4);
    end;
    OutStream.Write(OutBuf, O);
  until Count < SizeOf(InBuf) div SizeOf(Char);
end;

procedure LbDecodeBase64A(InStream, OutStream : TStream);
var
  I, O, Count, c1, c2, c3 : Byte;
  InBuf  : array[0..87] of Byte;
  OutBuf : array[0..65] of Byte;
begin
  repeat
    O := 0;
    I := 0;
    Count := InStream.Read(InBuf, SizeOf(InBuf));
    if (Count = 0) then
      Break;
    while I < Count do begin
      if (InBuf[I] < 43) or (InBuf[I] > 122) or
         (InBuf[I+1] < 43) or (InBuf[I+1] > 122) or
         (InBuf[I+2] < 43) or (InBuf[I+2] > 122) or
         (InBuf[I+3] < 43) or (InBuf[I+3] > 122) then
        raise Exception.Create('Invalid Base64 Character');

      c1 := LbD64Table[InBuf[I]];
      c2 := LbD64Table[InBuf[I+1]];
      c3 := LbD64Table[InBuf[I+2]];
      OutBuf[O] := ((c1 shl 2) or (c2 shr 4));
      Inc(O);
      if Char(InBuf[I+2]) <> '=' then begin
        OutBuf[O] := ((c2 shl 4) or (c3 shr 2));
        Inc(O);
        if Char(InBuf[I+3]) <> '=' then begin
          OutBuf[O] := ((c3 shl 6) or LbD64Table[InBuf[I+3]]);
          Inc(O);
        end;
      end;
      Inc(I, 4);
    end;
    OutStream.Write(OutBuf, O);
  until Count < SizeOf(InBuf) div SizeOf(AnsiChar);
end;

procedure FileHashSHA1(var Digest : TSHA1Digest; const AFileName : string);
var
  FS : TFileStream;
begin
  FS := TFileStream.Create(AFileName, fmOpenRead);
  try
    StreamHashSHA1(Digest, FS);
  finally
    FS.Free;
  end;
end;

procedure StreamHashSHA1(var Digest : TSHA1Digest; AStream : TStream);
var
  BufSize : Cardinal;
  Buf : array[0..1023] of Byte;
  Context : TSHA1Context;
begin
  InitSHA1(Context);
  BufSize := AStream.Read(Buf, SizeOf(Buf));
  while (BufSize > 0) do begin
    UpdateSHA1(Context, Buf, BufSize);
    BufSize := AStream.Read(Buf, SizeOf(Buf));
  end;
  FinalizeSHA1(Context, Digest);
end;

procedure FileHashMD5(var Digest : TMD5Digest; const AFileName : string);
var
  FS : TFileStream;
begin
  FS := TFileStream.Create(AFileName, fmOpenRead);
  try
    StreamHashMD5(Digest, FS);
  finally
    FS.Free;
  end;
end;

procedure StreamHashMD5(var Digest : TMD5Digest; AStream : TStream);
var
  BufSize : Cardinal;
  Buf : array[0..1023] of Byte;
  Context : TMD5Context;
begin
  InitMD5(Context);
  BufSize := AStream.Read(Buf, SizeOf(Buf));
  while (BufSize > 0) do begin
    UpdateMD5(Context, Buf, BufSize);
    BufSize := AStream.Read(Buf, SizeOf(Buf));
  end;
  FinalizeMD5(Context, Digest);
end;

procedure RDLEncryptFileCBC(const InFile, OutFile : string; const Key; KeySize : Longint; Encrypt : Boolean);
var
  InStream, OutStream : TStream;
begin
  InStream := TFileStream.Create(InFile, fmOpenRead or fmShareDenyWrite);
  try
    OutStream := TFileStream.Create(OutFile, fmCreate);
    try
      RDLEncryptStreamCBC(InStream, OutStream, Key, KeySize, Encrypt);
    finally
      OutStream.Free;
    end;
  finally
    InStream.Free;
  end;
end;

procedure RDLEncryptFile(const InFile, OutFile : string; const Key; KeySize : Longint; Encrypt : Boolean);
var
  InStream, OutStream : TStream;
begin
  InStream := TFileStream.Create(InFile, fmOpenRead or fmShareDenyWrite);
  try
    OutStream := TFileStream.Create(OutFile, fmCreate);
    try
      RDLEncryptStream(InStream, OutStream, Key, KeySize, Encrypt);
    finally
      OutStream.Free;
    end;
  finally
    InStream.Free;
  end;
end;

procedure RDLEncryptStreamCBC(InStream, OutStream : TStream;  const Key; KeySize : Longint; Encrypt : Boolean);
var
  I          : LongInt;
  Block      : TRDLBlock;
  IV         : TRDLBlock;
  Work       : TRDLBlock;
  Context    : TRDLContext;
  BlockCount : LongInt;

begin
  InitEncryptRDL(Key, KeySize, Context, Encrypt);
  BlockCount := (InStream.Size div SizeOf(Block));

  if Encrypt then begin
    Block[0] := DateTimeToFileDate(now);
    Block[1] := DateTimeToFileDate(now);
    EncryptRDL(Context, Block);
    OutStream.Write(Block, SizeOf(Block));
    IV := Block;
  end else begin
    InStream.Read(Block, SizeOf(Block));
    Dec(BlockCount);
    IV := Block;
  end;
  if Encrypt then begin
    Inc(BlockCount);
  end;

  for I := 1 to BlockCount - 1 do begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);

    if Encrypt then begin
      EncryptRDLCBC(Context, IV, Block);
      IV := Block;
    end else begin
      Work := Block;
      EncryptRDLCBC(Context, IV, Block);
      IV := Work;
    end;

    OutStream.Write(Block, SizeOf(Block));

    if Assigned(LbOnProgress) then begin
      if InStream.Position mod LbProgressSize = 0 then begin
        LbOnProgress (InStream.Position, InStream.Size);
      end;
    end;
  end;

  if Encrypt then begin
    FillChar(Block, SizeOf(Block), #0);
    I := (InStream.Size mod SizeOf(Block));
    if InStream.Read(Block, I) <> I then
      raise ECipherException.Create(SInvalidFileFormat);
    PByteArray(@Block)^[SizeOf(Block)-1] := I;
    EncryptRDLCBC(Context, IV, Block);
    OutStream.Write(Block, SizeOf(Block));
  end else begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);
    EncryptRDLCBC(Context, IV, Block);
    I := PByteArray(@Block)^[SizeOf(Block)-1];
    OutStream.Write(Block, I);
  end;
  if Assigned(LbOnProgress) then begin
    LbOnProgress (InStream.Position, InStream.Size);
  end;
end;

procedure RDLEncryptStream(InStream, OutStream : TStream; const Key; KeySize : Longint; Encrypt : Boolean);
var
  I          : LongInt;
  Block      : TRDLBlock;
  Context    : TRDLContext;
  BlockCount : LongInt;
begin
  InitEncryptRDL(Key, KeySize, Context, Encrypt);
  BlockCount := (InStream.Size div SizeOf(Block));
  if Encrypt then begin
    Inc(BlockCount);
  end;

  for I := 1 to BlockCount - 1 do begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);
    EncryptRDL(Context, Block);
    OutStream.Write(Block, SizeOf(Block));

    if Assigned(LbOnProgress) then begin
      if InStream.Position mod LbProgressSize = 0 then begin
        LbOnProgress (InStream.Position, InStream.Size);
      end;
    end;
  end;

  if Encrypt then begin
    FillChar(Block, SizeOf(Block), #0);
    I := (InStream.Size mod SizeOf(Block));
    if InStream.Read(Block, I) <> I then
      raise ECipherException.Create(SInvalidFileFormat);
    PByteArray(@Block)^[SizeOf(Block)-1] := I;
    EncryptRDL(Context, Block);
    OutStream.Write(Block, SizeOf(Block));
  end else begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);
    EncryptRDL(Context, Block);
    I := PByteArray(@Block)^[SizeOf(Block)-1];
    OutStream.Write(Block, I);
  end;
  if Assigned(LbOnProgress) then begin
    LbOnProgress (InStream.Position, InStream.Size);
  end;
end;

procedure TripleDESEncryptFileCBC(const InFile, OutFile : string; const Key : TKey128; Encrypt : Boolean);
var
  InStream, OutStream : TStream;
begin
  InStream := TFileStream.Create(InFile, fmOpenRead or fmShareDenyWrite);
  try
    OutStream := TFileStream.Create(OutFile, fmCreate);
    try
      TripleDESEncryptStreamCBC(InStream, OutStream, Key, Encrypt);
    finally
      OutStream.Free;
    end;
  finally
    InStream.Free;
  end;
end;

procedure TripleDESEncryptFile(const InFile, OutFile : string; const Key : TKey128; Encrypt : Boolean);
var
  InStream, OutStream : TStream;
begin
  InStream := TFileStream.Create(InFile, fmOpenRead or fmShareDenyWrite);
  try
    OutStream := TFileStream.Create(OutFile, fmCreate);
    try
      TripleDESEncryptStream(InStream, OutStream, Key, Encrypt);
    finally
      OutStream.Free;
    end;
  finally
    InStream.Free;
  end;
end;

procedure TripleDESEncryptStreamCBC(InStream, OutStream : TStream; const Key : TKey128; Encrypt : Boolean);
var
  I          : LongInt;
  Block      : TDESBlock;
  IV         : TDESBlock;
  Work       : TDESBlock;
  Context    : TTripleDESContext;
  BlockCount : LongInt;

begin
  InitEncryptTripleDES(Key, Context, Encrypt);
  BlockCount := (InStream.Size div SizeOf(Block));

  if Encrypt then begin
    Block[0] := DateTimeToFileDate(now);
    Block[1] := DateTimeToFileDate(now);
    Block[2] := DateTimeToFileDate(now);
    Block[3] := DateTimeToFileDate(now);
    EncryptTripleDES(Context, Block);
    OutStream.Write(Block, SizeOf(Block));
    IV := Block;
  end else begin
    InStream.Read(Block, SizeOf(Block));
    Dec(BlockCount);
    IV := Block;
  end;
  if Encrypt then begin
    Inc(BlockCount);
  end;

  for I := 1 to BlockCount - 1 do begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);

    if Encrypt then begin
      EncryptTripleDESCBC(Context, IV, Block);
      IV := Block;
    end else begin
      Work := Block;
      EncryptTripleDESCBC(Context, IV, Block);
      IV := Work;
    end;

    OutStream.Write(Block, SizeOf(Block));

    if Assigned(LbOnProgress) then begin
      if InStream.Position mod LbProgressSize = 0 then begin
        LbOnProgress (InStream.Position, InStream.Size);
      end;
    end;
  end;

  if Encrypt then begin
    FillChar(Block, SizeOf(Block), #0);
    I := (InStream.Size mod SizeOf(Block));
    if InStream.Read(Block, I) <> I then
      raise ECipherException.Create(SInvalidFileFormat);
    PByteArray(@Block)^[SizeOf(Block)-1] := I;
    EncryptTripleDESCBC(Context, IV, Block);
    OutStream.Write(Block, SizeOf(Block));
  end else begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);
    EncryptTripleDESCBC(Context, IV, Block);
    I := PByteArray(@Block)^[SizeOf(Block)-1];
    OutStream.Write(Block, I);
  end;
  if Assigned(LbOnProgress) then begin
    LbOnProgress (InStream.Position, InStream.Size);
  end;
end;

procedure TripleDESEncryptStream(InStream, OutStream : TStream; const Key : TKey128; Encrypt : Boolean);
var
  I          : LongInt;
  Block      : TDESBlock;
  Context    : TTripleDESContext;
  BlockCount : LongInt;
begin
  InitEncryptTripleDES(Key, Context, Encrypt);
  BlockCount := (InStream.Size div SizeOf(Block));
  if Encrypt then begin
    Inc(BlockCount);
  end;

  for I := 1 to BlockCount - 1 do begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);
    EncryptTripleDES(Context, Block);
    OutStream.Write(Block, SizeOf(Block));

    if Assigned(LbOnProgress) then begin
      if InStream.Position mod LbProgressSize = 0 then begin
        LbOnProgress (InStream.Position, InStream.Size);
      end;
    end;
  end;

  if Encrypt then begin
    FillChar(Block, SizeOf(Block), #0);
    I := (InStream.Size mod SizeOf(Block));
    if InStream.Read(Block, I) <> I then
      raise ECipherException.Create(SInvalidFileFormat);
    PByteArray(@Block)^[SizeOf(Block)-1] := I;
    EncryptTripleDES(Context, Block);
    OutStream.Write(Block, SizeOf(Block));
  end else begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);
    EncryptTripleDES(Context, Block);
    I := PByteArray(@Block)^[SizeOf(Block)-1];
    OutStream.Write(Block, I);
  end;
  if Assigned(LbOnProgress) then begin
    LbOnProgress (InStream.Position, InStream.Size);
  end;
end;

procedure RNG64EncryptFile(const InFile, OutFile : string; KeyHi, KeyLo : LongInt);
var
  Context   : TRNG64Context;
  InStream  : TStream;
  OutStream : TStream;
  BytesRead : LongInt;
  Buf       : array[1..2048] of Byte;
begin
  InitEncryptRNG64(KeyHi, KeyLo, Context);
  InStream := TFileStream.Create(InFile, fmOpenRead or fmShareDenyWrite);
  try
    OutStream := TFileStream.Create(OutFile, fmCreate);
    try
      repeat
        BytesRead := InStream.Read(Buf, SizeOf(Buf));
        if BytesRead > 0 then begin
          EncryptRNG64(Context, Buf, BytesRead);
          OutStream.WriteBuffer(Buf, BytesRead);

          if Assigned(LbOnProgress) then begin
            if InStream.Position mod LbProgressSize = 0 then begin
              LbOnProgress (InStream.Position, InStream.Size);
            end;
          end;
        end;
      until BytesRead < SizeOf(Buf);
    finally
      OutStream.Free;
    end;
  finally
    if Assigned(LbOnProgress) then begin
      LbOnProgress (InStream.Position, InStream.Size);
    end;
    InStream.Free;
  end;
end;

procedure RNG32EncryptFile(const InFile, OutFile : string; Key : LongInt);
var
  Context   : TRNG32Context;
  InStream  : TStream;
  OutStream : TStream;
  BytesRead : LongInt;
  Buf       : array[1..2048] of Byte;
begin
  InitEncryptRNG32(Key, Context);
  InStream := TFileStream.Create(InFile, fmOpenRead or fmShareDenyWrite);
  try
    OutStream := TFileStream.Create(OutFile, fmCreate);
    try
      repeat
        BytesRead := InStream.Read(Buf, SizeOf(Buf));
        if BytesRead > 0 then begin
          EncryptRNG32(Context, Buf, BytesRead);
          OutStream.WriteBuffer(Buf, BytesRead);

          if Assigned(LbOnProgress) then begin
            if InStream.Position mod LbProgressSize = 0 then begin
              LbOnProgress (InStream.Position, InStream.Size);
            end;
          end;
        end;
      until BytesRead < SizeOf(Buf);
    finally
      OutStream.Free;
    end;
  finally
    if Assigned(LbOnProgress) then begin
      LbOnProgress (InStream.Position, InStream.Size);
    end;
    InStream.Free;
  end;
end;

procedure LSCEncryptFile(const InFile, OutFile : string; const Key; KeySize : Integer);
var
  Context   : TLSCContext;
  InStream  : TStream;
  OutStream : TStream;
  BytesRead : LongInt;
  Buf       : array[1..2048] of Byte;
begin
  InitEncryptLSC(Key, KeySize, Context);
  InStream := TFileStream.Create(InFile, fmOpenRead or fmShareDenyWrite);
  try
    OutStream := TFileStream.Create(OutFile, fmCreate);
    try
      repeat
        BytesRead := InStream.Read(Buf, SizeOf(Buf));
        if BytesRead > 0 then begin
          EncryptLSC(Context, Buf, BytesRead);
          OutStream.WriteBuffer(Buf, BytesRead);

          if Assigned(LbOnProgress) then begin
            if InStream.Position mod LbProgressSize = 0 then begin
              LbOnProgress (InStream.Position, InStream.Size);
            end;
          end;
        end;
      until BytesRead < SizeOf(Buf);
    finally
      OutStream.Free;
    end;
  finally
    if Assigned(LbOnProgress) then begin
      LbOnProgress (InStream.Position, InStream.Size);
    end;
    InStream.Free;
  end;
end;

procedure LBCEncryptFileCBC(const InFile, OutFile : string; const Key : TKey128; Rounds : LongInt; Encrypt : Boolean);
var
  InStream, OutStream : TStream;
begin
  InStream := TFileStream.Create(InFile, fmOpenRead or fmShareDenyWrite);
  try
    OutStream := TFileStream.Create(OutFile, fmCreate);
    try
      LBCEncryptStreamCBC(InStream, OutStream, Key, Rounds, Encrypt);
    finally
      OutStream.Free;
    end;
  finally
    InStream.Free;
  end;
end;

procedure LBCEncryptFile(const InFile, OutFile : string; const Key : TKey128; Rounds : LongInt; Encrypt : Boolean);
var
  InStream, OutStream : TStream;
begin
  InStream := TFileStream.Create(InFile, fmOpenRead or fmShareDenyWrite);
  try
    OutStream := TFileStream.Create(OutFile, fmCreate);
    try
      LBCEncryptStream(InStream, OutStream, Key, Rounds, Encrypt);
    finally
      OutStream.Free;
    end;
  finally
    InStream.Free;
  end;
end;

procedure LQCEncryptFileCBC(const InFile, OutFile : string; const Key : TKey128; Encrypt : Boolean);
var
  InStream, OutStream : TStream;
begin
  InStream := TFileStream.Create(InFile, fmOpenRead or fmShareDenyWrite);
  try
    OutStream := TFileStream.Create(OutFile, fmCreate);
    try
      LQCEncryptStreamCBC(InStream, OutStream, Key, Encrypt);
    finally
      OutStream.Free;
    end;
  finally
    InStream.Free;
  end;
end;

procedure LQCEncryptFile(const InFile, OutFile : string; const Key : TKey128; Encrypt : Boolean);
var
  InStream, OutStream : TStream;
begin
  InStream := TFileStream.Create(InFile, fmOpenRead or fmShareDenyWrite);
  try
    OutStream := TFileStream.Create(OutFile, fmCreate);
    try
      LQCEncryptStream(InStream, OutStream, Key, Encrypt);
    finally
      OutStream.Free;
    end;
  finally
    InStream.Free;
  end;
end;

procedure LQCEncryptStreamCBC(InStream, OutStream : TStream;  const Key : TKey128; Encrypt : Boolean);
var
  I          : LongInt;
  Block      : TLQCBlock;
  IV         : TLQCBlock;
  Work       : TLQCBlock;
  BlockCount : LongInt;
begin
  BlockCount := (InStream.Size div SizeOf(Block));

  if Encrypt then begin
    Block[0] := DateTimeToFileDate(now);
    Block[1] := DateTimeToFileDate(now);
    EncryptLQC(Key, Block, Encrypt);
    OutStream.Write(Block, SizeOf(Block));
    IV := Block;
  end else begin
    InStream.Read(Block, SizeOf(Block));
    Dec(BlockCount);
    IV := Block;
  end;
  if Encrypt then begin
    Inc(BlockCount);
  end;
  for I := 1 to BlockCount - 1 do begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);

    if Encrypt then begin
      EncryptLQCCBC(Key, IV, Block, Encrypt);
      IV := Block;
    end else begin
      Work := Block;
      EncryptLQCCBC(Key, IV, Block, Encrypt);
      IV := Work;
    end;

    OutStream.Write(Block, SizeOf(Block));

    if Assigned(LbOnProgress) then begin
      if InStream.Position mod LbProgressSize = 0 then begin
        LbOnProgress (InStream.Position, InStream.Size);
      end;
    end;
  end;

  if Encrypt then begin
    FillChar(Block, SizeOf(Block), #0);
    I := (InStream.Size mod SizeOf(Block));
    if InStream.Read(Block, I) <> I then
      raise ECipherException.Create(SInvalidFileFormat);
    PByteArray(@Block)^[SizeOf(Block)-1] := I;
    EncryptLQCCBC(Key, IV, Block, Encrypt);
    OutStream.Write(Block, SizeOf(Block));
  end else begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);
    EncryptLQCCBC(Key, IV, Block, Encrypt);
    I := PByteArray(@Block)^[SizeOf(Block)-1];
    OutStream.Write(Block, I);
  end;
  if Assigned(LbOnProgress) then begin
    LbOnProgress (InStream.Position, InStream.Size);
  end;
end;

procedure LQCEncryptStream(InStream, OutStream : TStream; const Key : TKey128; Encrypt : Boolean);
var
  I          : LongInt;
  Block      : TLQCBlock;
  BlockCount : LongInt;
begin
  BlockCount := (InStream.Size div SizeOf(Block));
  if Encrypt then begin
    Inc(BlockCount);
  end;

  for I := 1 to BlockCount - 1 do begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);
    EncryptLQC(Key, Block, Encrypt);
    OutStream.Write(Block, SizeOf(Block));

    if Assigned(LbOnProgress) then begin
      if InStream.Position mod LbProgressSize = 0 then begin
        LbOnProgress (InStream.Position, InStream.Size);
      end;
    end;
  end;

  if Encrypt then begin
    FillChar(Block, SizeOf(Block), #0);
    I := (InStream.Size mod SizeOf(Block));
    if InStream.Read(Block, I) <> I then
      raise ECipherException.Create(SInvalidFileFormat);
    PByteArray(@Block)^[SizeOf(Block)-1] := I;
    EncryptLQC(Key, Block, Encrypt);
    OutStream.Write(Block, SizeOf(Block));
  end else begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);
    EncryptLQC(Key, Block, Encrypt);
    I := PByteArray(@Block)^[SizeOf(Block)-1];
    OutStream.Write(Block, I);
  end;
  if Assigned(LbOnProgress) then begin
    LbOnProgress (InStream.Position, InStream.Size);
  end;
end;

procedure LBCEncryptStreamCBC(InStream, OutStream : TStream; const Key : TKey128; Rounds : LongInt; Encrypt : Boolean);
var
  I          : LongInt;
  Block      : TLBCBlock;
  IV         : TLBCBlock;
  Work       : TLBCBlock;
  Context    : TLBCContext;
  BlockCount : LongInt;
begin
  InitEncryptLBC(Key, Context, Rounds, Encrypt);
  BlockCount := (InStream.Size div SizeOf(Block));

  if Encrypt then begin
    Block[0] := DateTimeToFileDate(now);
    Block[1] := DateTimeToFileDate(now);
    Block[2] := DateTimeToFileDate(now);
    Block[3] := DateTimeToFileDate(now);

    EncryptLBC(Context, Block);
    OutStream.Write(Block, SizeOf(Block));
    IV := Block;
  end else begin
    InStream.Read(Block, SizeOf(Block));
    Dec(BlockCount);
    IV := Block;
  end;
  if Encrypt then begin
    Inc(BlockCount);
  end;

  for I := 1 to BlockCount - 1 do begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);

    if Encrypt then begin
      EncryptLBCCBC(Context, IV, Block);
      IV := Block;
    end else begin
      Work := Block;
      EncryptLBCCBC(Context, IV, Block);
      IV := Work;
    end;

    OutStream.Write(Block, SizeOf(Block));

    if Assigned(LbOnProgress) then begin
      if InStream.Position mod LbProgressSize = 0 then begin
        LbOnProgress (InStream.Position, InStream.Size);
      end;
    end;
  end;

  if Encrypt then begin
    FillChar(Block, SizeOf(Block), #0);
    I := (InStream.Size mod SizeOf(Block));
    if InStream.Read(Block, I) <> I then
      raise ECipherException.Create(SInvalidFileFormat);
    PByteArray(@Block)^[SizeOf(Block)-1] := I;
    EncryptLBCCBC(Context, IV, Block);
    OutStream.Write(Block, SizeOf(Block));
  end else begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);
    EncryptLBCCBC(Context, IV, Block);
    I := PByteArray(@Block)^[SizeOf(Block)-1];
   OutStream.Write(Block, I);
  end;
  if Assigned(LbOnProgress) then begin
    LbOnProgress (InStream.Position, InStream.Size);
  end;
end;

procedure LBCEncryptStream(InStream, OutStream : TStream; const Key : TKey128; Rounds : LongInt; Encrypt : Boolean);
var
  I          : LongInt;
  Block      : TLBCBlock;
  Context    : TLBCContext;
  BlockCount : LongInt;
begin
  InitEncryptLBC(Key, Context, Rounds, Encrypt);
  BlockCount := (InStream.Size div SizeOf(Block));
  if Encrypt then begin
    Inc(BlockCount);
  end;
  for I := 1 to BlockCount - 1 do begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);
    EncryptLBC(Context, Block);
    OutStream.Write(Block, SizeOf(Block));

    if Assigned(LbOnProgress) then begin
      if InStream.Position mod LbProgressSize = 0 then begin
        LbOnProgress (InStream.Position, InStream.Size);
      end;
    end;
  end;

  if Encrypt then begin
    FillChar(Block, SizeOf(Block), #0);
    I := (InStream.Size mod SizeOf(Block));
    if InStream.Read(Block, I) <> I then
      raise ECipherException.Create(SInvalidFileFormat);
    PByteArray(@Block)^[SizeOf(Block)-1] := I;
    EncryptLBC(Context, Block);
    OutStream.Write(Block, SizeOf(Block));
  end else begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);
    EncryptLBC(Context, Block);
    I := PByteArray(@Block)^[SizeOf(Block)-1];
    OutStream.Write(Block, I);
  end;
  if Assigned(LbOnProgress) then begin
    LbOnProgress (InStream.Position, InStream.Size);
  end;
end;

procedure DESEncryptFileCBC(const InFile, OutFile : string; const Key : TKey64; Encrypt : Boolean);
var
  InStream, OutStream : TStream;
begin
  InStream := TFileStream.Create(InFile, fmOpenRead or fmShareDenyWrite);
  try
    OutStream := TFileStream.Create(OutFile, fmCreate);
    try
      DESEncryptStreamCBC(InStream, OutStream, Key, Encrypt);
    finally
      OutStream.Free;
    end;
  finally
    InStream.Free;
  end;
end;

procedure DESEncryptFile(const InFile, OutFile : string; const Key : TKey64; Encrypt : Boolean);
var
  InStream, OutStream : TStream;
begin
  InStream := TFileStream.Create(InFile, fmOpenRead or fmShareDenyWrite);
  try
    OutStream := TFileStream.Create(OutFile, fmCreate);
    try
      DESEncryptStream(InStream, OutStream, Key, Encrypt);
    finally
      OutStream.Free;
    end;
  finally
    InStream.Free;
  end;
end;

procedure DESEncryptStreamCBC(InStream, OutStream : TStream; const Key : TKey64; Encrypt : Boolean);
var
  I          : LongInt;
  Block      : TDESBlock;
  IV         : TDESBlock;
  Work       : TDESBlock;
  Context    : TDESContext;
  BlockCount : LongInt;
begin
  InitEncryptDES(Key, Context, Encrypt);
  BlockCount := (InStream.Size div SizeOf(Block));

  if Encrypt then begin
    Block[0] := DateTimeToFileDate(now);
    Block[1] := DateTimeToFileDate(now);
    Block[2] := DateTimeToFileDate(now);
    Block[3] := DateTimeToFileDate(now);

    EncryptDES(Context, Block);
    OutStream.Write(Block, SizeOf(Block));
    IV := Block;
  end else begin
    InStream.Read(Block, SizeOf(Block));
    Dec(BlockCount);
    IV := Block;
  end;
  if Encrypt then begin
    Inc(BlockCount);
  end;

  for I := 1 to BlockCount - 1 do begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);

    if Encrypt then begin
      EncryptDESCBC(Context, IV, Block);
      IV := Block;
    end else begin
      Work := Block;
      EncryptDESCBC(Context, IV, Block);
      IV := Work;
    end;

    OutStream.Write(Block, SizeOf(Block));

    if Assigned(LbOnProgress) then begin
      if InStream.Position mod LbProgressSize = 0 then begin
        LbOnProgress (InStream.Position, InStream.Size);
      end;
    end;
  end;

  if Encrypt then begin
    FillChar(Block, SizeOf(Block), #0);
    I := (InStream.Size mod SizeOf(Block));
    if InStream.Read(Block, I) <> I then
      raise ECipherException.Create(SInvalidFileFormat);
    PByteArray(@Block)^[SizeOf(Block)-1] := I;
    EncryptDESCBC(Context, IV, Block);
    OutStream.Write(Block, SizeOf(Block));
  end else begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);
    EncryptDESCBC(Context, IV, Block);
    I := PByteArray(@Block)^[SizeOf(Block)-1];
    OutStream.Write(Block, I);
  end;
  if Assigned(LbOnProgress) then begin
    LbOnProgress (InStream.Position, InStream.Size);
  end;
end;

procedure DESEncryptStream(InStream, OutStream : TStream; const Key : TKey64; Encrypt : Boolean);
var
  I          : LongInt;
  Block      : TDESBlock;
  Context    : TDESContext;
  BlockCount : LongInt;
begin
  InitEncryptDES(Key, Context, Encrypt);
  BlockCount := (InStream.Size div SizeOf(Block));
  if Encrypt then begin
    Inc(BlockCount);
  end;
  for I := 1 to BlockCount - 1 do begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);
    EncryptDES(Context, Block);
    OutStream.Write(Block, SizeOf(Block));

    if Assigned(LbOnProgress) then begin
      if InStream.Position mod LbProgressSize = 0 then begin
        LbOnProgress (InStream.Position, InStream.Size);
      end;
    end;
  end;

  if Encrypt then begin
    FillChar(Block, SizeOf(Block), #0);
    I := (InStream.Size mod SizeOf(Block));
    if InStream.Read(Block, I) <> I then
      raise ECipherException.Create(SInvalidFileFormat);
    PByteArray(@Block)^[SizeOf(Block)-1] := I;
    EncryptDES(Context, Block);
    OutStream.Write(Block, SizeOf(Block));
  end else begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);
    EncryptDES(Context, Block);
    I := PByteArray(@Block)^[SizeOf(Block)-1];
    OutStream.Write(Block, I);
  end;
  if Assigned(LbOnProgress) then begin
    LbOnProgress (InStream.Position, InStream.Size);
  end;
end;

procedure BFEncryptFileCBC(const InFile, OutFile : string; const Key : TKey128; Encrypt : Boolean);
var
  InStream, OutStream : TStream;
begin
  InStream := TFileStream.Create(InFile, fmOpenRead or fmShareDenyWrite);
  try
    OutStream := TFileStream.Create(OutFile, fmCreate);
    try
      BFEncryptStreamCBC(InStream, OutStream, Key, Encrypt);
    finally
      OutStream.Free;
    end;
  finally
    InStream.Free;
  end;
end;

procedure BFEncryptFile(const InFile, OutFile : string; const Key : TKey128; Encrypt : Boolean);
var
  InStream, OutStream : TStream;
begin
  InStream := TFileStream.Create(InFile, fmOpenRead or fmShareDenyWrite);
  try
    OutStream := TFileStream.Create(OutFile, fmCreate);
    try
      BFEncryptStream(InStream, OutStream, Key, Encrypt);
    finally
      OutStream.Free;
    end;
  finally
    InStream.Free;
  end;
end;

procedure BFEncryptStreamCBC(InStream, OutStream : TStream;  const Key : TKey128; Encrypt : Boolean);
var
  I : LongInt;
  Block : TBFBlock;
  IV : TBFBlock;
  Work : TBFBlock;
  Context : TBFContext;
  BlockCount : LongInt;
begin
  InitEncryptBF(Key, Context);
  BlockCount := (InStream.Size div SizeOf(Block));

  if Encrypt then begin
    Block[0] := DateTimeToFileDate(now);
    Block[1] := DateTimeToFileDate(now);
    EncryptBF(Context, Block, Encrypt);
    OutStream.Write(Block, SizeOf(Block));
    IV := Block;
  end else begin
    InStream.Read(Block, SizeOf(Block));
    Dec(BlockCount);
    IV := Block;
  end;

  if Encrypt then begin
    Inc(BlockCount);
  end;

  for I := 1 to BlockCount - 1 do begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);

    if Encrypt then begin
      EncryptBFCBC(Context, IV, Block, Encrypt);
      IV := Block;
    end else begin
      Work := Block;
      EncryptBFCBC(Context, IV, Block, Encrypt);
      IV := Work;
    end;

    OutStream.Write(Block, SizeOf(Block));

    if Assigned(LbOnProgress) then begin
      if InStream.Position mod LbProgressSize = 0 then begin
        LbOnProgress (InStream.Position, InStream.Size);
      end;
    end;
  end;

  if Encrypt then begin
    FillChar(Block, SizeOf(Block), #0);
    I := (InStream.Size mod SizeOf(Block));
    if InStream.Read(Block, I) <> I then
      raise ECipherException.Create(SInvalidFileFormat);
    PByteArray(@Block)^[SizeOf(Block)-1] := I;
    EncryptBFCBC(Context, IV, Block, Encrypt);
    OutStream.Write(Block, SizeOf(Block));
  end else begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);
    EncryptBFCBC(Context, IV, Block, Encrypt);
    I := PByteArray(@Block)^[SizeOf(Block)-1];
    OutStream.Write(Block, I);
  end;
  if Assigned(LbOnProgress) then begin
    LbOnProgress (InStream.Position, InStream.Size);
  end;
end;

procedure BFEncryptStream(InStream, OutStream : TStream; const Key : TKey128; Encrypt : Boolean);
var
  I          : LongInt;
  Block      : TBFBlock;
  Context    : TBFContext;
  BlockCount : LongInt;
begin
  InitEncryptBF(Key, Context);
  BlockCount := (InStream.Size div SizeOf(Block));

  if Encrypt then begin
    Inc(BlockCount);
  end;

  for I := 1 to BlockCount - 1 do begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);
    EncryptBF(Context, Block, Encrypt);
    OutStream.Write(Block, SizeOf(Block));

    if Assigned(LbOnProgress) then begin
      if InStream.Position mod LbProgressSize = 0 then  begin
        LbOnProgress (InStream.Position, InStream.Size);
      end;
    end;
  end;

  if Encrypt then begin
    FillChar(Block, SizeOf(Block), #0);
    I := (InStream.Size mod SizeOf(Block));
    if InStream.Read(Block, I) <> I then
      raise ECipherException.Create(SInvalidFileFormat);
    PByteArray(@Block)^[SizeOf(Block)-1] := I;
    EncryptBF(Context, Block, Encrypt);
    OutStream.Write(Block, SizeOf(Block));
  end else begin
    if InStream.Read(Block, SizeOf(Block)) <> SizeOf(Block) then
      raise ECipherException.Create(SInvalidFileFormat);
    EncryptBF(Context, Block, Encrypt);
    I := PByteArray(@Block)^[SizeOf(Block)-1];
    OutStream.Write(Block, I);
  end;
  if Assigned(LbOnProgress) then begin
    LbOnProgress (InStream.Position, InStream.Size);
  end;
end;

function LbBiModInv(e : LbInteger; _mod : LbInteger; var d : LbInteger) : Boolean;
var
  v : LbInteger;
  u : LbInteger;
  a : LbInteger;
  b : LbInteger;
  gcd : LbInteger;
begin
  LbBiVerify(e);
  LbBiVerify(_mod);
  LbBiPrepare(e, _mod, d);

  LbBiInit(u, cUSE_DEFAULT_PRECISION);
  LbBiInit(v, cUSE_DEFAULT_PRECISION);
  LbBiInit(a, cUSE_DEFAULT_PRECISION);
  LbBiInit(b, cUSE_DEFAULT_PRECISION);
  LbBiInit(gcd, cUSE_DEFAULT_PRECISION);
  Result := False;
  try
    LbBiCopy(u, e, e.dwUsed);
    LbBiCopy(v, _mod, _mod.dwUsed);
    LbBiExtendedEuclid(u, v, a, b, gcd);
    if (LbBiIsOne(gcd)) then begin
      LbBiSub(u, b, d);
      Result := True;
    end;
  finally
    LbBiFree(u);
    LbBiFree(v);
    LbBiFree(a);
    LbBiFree(b);
    LbBiFree(gcd);
  end;
end;

procedure LbBiExtendedEuclid(var u : LbInteger; var v : LbInteger; var u1 : LbInteger; var u2 : LbInteger; var GCD : LbInteger);
var
  t1 : LbInteger;
  t2 : LbInteger;
  t3 : LbInteger;
  zero : LbInteger;
  k : Integer;
  tmp : LbInteger;
begin

  LbBiVerify(u);
  LbBiVerify(v);
  LbBiPrepare(u, v, u1);
  LbBiPrepare(u, v, u2);
  LbBiPrepare(u, v, GCD);

  LbBiClear(u1);
  LbBiClear(u2);
  LbBiClear(GCD);

  LbBiInit(tmp, cDEFAULT_PRECISION);
  LbBiInit(t1, cDEFAULT_PRECISION);
  LbBiInit(t2, cDEFAULT_PRECISION);
  LbBiInit(t3, cDEFAULT_PRECISION);
  LbBiInit(zero, 1);

  try
    LbBiAddByte(zero, cPREPEND_ARRAY, $00);

    k := 0;
    while((LbBiIsEven(u)) and (LbBiIsEven(v)))do begin
      LbBiShr(u, 1);
      LbBiShr(v, 1);
      k := 1;
    end;

    if (LbBiCompare(u, v) = cLESS_THAN) then begin
      LbBiSwap(u, v);
    end;

    LbBiAddByte(u1, cPREPEND_ARRAY, $01);
    LbBiAddByte(u2, cPREPEND_ARRAY, $00);
    LbBiCopy(GCD, u, u.dwUsed);
    LbBiCopy(t1, v, v.dwUsed);
    LbBiClear(tmp);
    LbBiSubByDigit(u, $01, tmp);
    LbBiCopy(t2, tmp, tmp.dwUsed);
    LbBiCopy(t3, v, v.dwUsed);

    repeat { while t3 > 0 }
      repeat { while LbBiIsEven(GCD) }
        if (LbBiIsEven(GCD)) then begin
          if (LbBiIsOdd(u1) or LbBiIsOdd(u2)) then begin
            LbBiAddInPlace(u1, v);
            LbBiAddInPlace(u2, u);
          end;
          LbBiShr(u1, 1);
          LbBiShr(u2, 1);
          LbBiShr(GCD, 1);
        end;
        if (LbBiIsEven(t3) or (LbBiCompare(GCD, t3) = cLESS_THAN)) then begin
          LbBiSwap(u1, t1);
          LbBiSwap(u2, t2);
          LbBiSwap(GCD, t3);
        end;
      until(LbBiIsOdd(GCD));

      while((LbBiCompare(u1, t1) = cLESS_THAN) or (LbBiCompare(u2, t2) = cLESS_THAN))do begin
        LbBiAddInPlace(u1, v);
        LbBiAddInPlace(u2, u);
      end;
      LbBiSubInPlace(u1, t1);
      LbBiSubInPlace(u2, t2);
      LbBiSubInPlace(GCD, t3);
    until (LbBiCompare(t3, zero) = cLESS_THAN) or (LbBiCompare(t3, zero) = cEQUAL_TO );

    while(((LbBiCompare(u1, v) = cGREATER_THAN) or
           (LbBiCompare(u1, v) = cEQUAL_TO)) and
          ((LbBiCompare(u2, u) = cGREATER_THAN) or
           (LbBiCompare(u2, u) = cEQUAL_TO)))do begin
      LbBiSubInPlace(u1, v);
      LbBiSubInPlace(u2, u);
    end;
    LbBiShl(u1, k);
    LbBiShr(u2, k);
    LbBiShr(GCD, k);
  finally
    LbBiFree(tmp);
    LbBiFree(t1);
    LbBiFree(t2);
    LbBiFree(t3);
    LbBiFree(zero);
  end;
end;

procedure LbBiRandomBytes(var N1 : LbInteger; Count : Cardinal);
var
  RG : TLbRandomGenerator;
begin
  LbBiClear(N1);
  LbBiReAlloc(N1, Count);
  RG := TLbRandomGenerator.create;
  try
    RG.RandomBytes(N1.IntBuf.pBuf^, Count);
    N1.dwUsed := Count;
  finally
    RG.Free;
  end;
end;

procedure LbBiRandomSimplePrime(var N1 : LbInteger);
var
  x : Word;
  RG : TLbRandomGenerator;
begin
  RG := TLbRandomGenerator.create;
  try
    repeat
      RG.RandomBytes(x, SizeOf(x));
      x := x and $0FFF;
    until(x > 3) and (x <= High(SimplePrimes));
    LbBiAddWord(N1, cPREPEND_ARRAY, SimplePrimes[x]);
  finally
    RG.Free;
  end;
end;

procedure LbBiRandomPrime(var N1 : LbInteger; Iterations : Byte);
var
  tmp_byt : byte;
  Buf : pByte;
  len : Integer;
  passed : Boolean;
  random : TLbRandomGenerator;
begin
  random := TLbRandomGenerator.create;
  passed := False;
  len    := N1.IntBuf.dwLen;
  Buf   := pByte(AllocMem(len));
  try
    while(not passed)do begin
      fillchar(Buf^, len, $00);
      random.RandomBytes(Buf^, len);
      LbBiAddBuf(N1, cPREPEND_ARRAY, Buf, len);
      tmp_byt := LbBiGetByteValue(N1, 1);
      tmp_byt := tmp_byt or $01;
      LbBiAddByte(N1, 1, tmp_byt);
      tmp_byt := LbBiGetByteValue(N1, N1.dwUsed);
      tmp_byt := tmp_byt or $80;
      LbBiAddByte(N1, N1.dwUsed, tmp_byt);

      repeat
        if LbBiCheckSimplePrimes(N1) then begin
          if (not LbBiIsCompositFast(N1, Iterations)) then begin
            passed := True;
            break;
          end;
        end;
        LbBiAddByDigitInPlace(N1, 2);
      until N1.dwUsed > integer(len);
    end;
  finally
    FreeMem(Buf, len);
    random.Free;
  end;
end;

function LbBiIsCompositFast(N1 : LbInteger; n : Integer) : Boolean;
var
  w : LbInteger;
  wMinus1 : LbInteger;
  m : LbInteger;
  b : LbInteger;
  z : LbInteger;
  a : Integer;
  j : Integer;
  i : Integer;
  one : LbInteger;
  random : TLbRandomGenerator;
  Buf : pByte;
  len : Integer;
begin
  len := (N1.dwUsed div 2) + 1;
  random := TLbRandomGenerator.create;
  Buf := pByte(AllocMem(len));
  LbBiInit(w, N1.dwUsed);
  LbBiInit(wMinus1, N1.dwUsed);
  LbBiInit(m, N1.dwUsed);
  LbBiInit(b, len);
  LbBiInit(z, N1.dwUsed);
  LbBiInit(one, 2);
  Result := True;
  try
    i := 1;
    LbBiCopy(w, N1, N1.dwUsed);
    LbBiSubByDigit(w, $01, wMinus1);
    if LbBiIsZero(wMinus1) then exit;
    LbBiCopy(m, wMinus1, wMinus1.dwUsed);
    a := 0;
    while(not LbBiGetBit(wMinus1, a))do begin
      LbBiShr(m, 1);
      if LbBiIsZero(m) then exit;
      inc(a);
    end;

    while True do begin
      LbBiAddByte(one, cPREPEND_ARRAY, $01);
      while True do begin
        random.RandomBytes(Buf^, len);
        LbBiAddBuf(b, cPREPEND_ARRAY, Buf, len);
        if (LbBiCompare(one, b) <> cLESS_THAN)or (LbBiCompare(b, w) <> cLESS_THAN) then
            continue;
        break;
      end;

      j := 0;
      LbBiPowerAndMod(b, m, w, z);

      while True do begin
        if ((j = 0) and LbBiIsOne(z))or (LbBiCompare(z, wMinus1) = cEQUAL_TO) then begin
          if i < n then begin
            inc(i);
            break;
          end else begin
            Result := False;
            exit;
          end;
        end else begin
          if (j > 0) and (LbBiIsOne(z)) then begin
            exit
          end else begin
            inc(j);
            if (j < a) then begin
              LbBiMultInPlace(z, z);
              LbBiModInPlace(z, w);
            end else begin
              exit;
            end;
          end;
        end;
      end;
    end;

  finally
    FreeMem(Buf, len);
    LbBiFree(one);
    LbBiFree(b);
    LbBiFree(m);
    LbBiFree(w);
    LbBiFree(z);
    LbBiFree(wMinus1);
    random.Free;
  end;
end;

function LbBiCheckSimplePrimes(N1 : LbInteger) : Boolean;
var
  cnt : Integer;
  quotient : LbInteger;
  N2 : LbInteger;
  remBN : LbInteger;
begin
  LbBiInit(quotient, N1.dwUsed);
  LbBiInit(N2 , 2);
  LbBiInit(remBN, N1.dwUsed);
  try
    for cnt := 0 to cTotalSimple2KPrimes do begin
      LbBiClear(N2);
      LbBiAddWord(N2, cPREPEND_ARRAY, SimplePrimes[ cnt ]);
      if LbBiCompare( N1, N2 ) = cEQUAL_TO then
        break;
      LbBiDiv(N1, N2, quotient, remBN);
      if (not LbBiIsZero(quotient)) and (not LbBiIsOne(quotient))  and LbBiIsZero(remBN) then begin
        Result := False;
        exit;
      end;
    end;
    Result := True;
  finally
    LbBiFree(quotient);
    LbBiFree(N2);
    LbBiFree(remBN);
  end;
end;

procedure LbBiCopyBigInt2Buf(N1 : LbInteger; place : integer; buf : pByte; length : Integer);
var
  ptr : pByte;
begin
  ptr := N1.IntBuf.pBuf;
  inc(ptr, pred(place));
  move(ptr^, buf^, length);
end;

procedure LbBiAddDWord(var N1 : LbInteger; place : integer; N2 : integer);
begin
  LbBiAddBuf(N1, place, @N2, SizeOf(integer));
end;

procedure LbBiAddWord(var N1 : LbInteger; place : integer; N2 : word);
begin
  LbBiAddBuf(N1, place, @N2, SizeOf(word));
end;

procedure LbBiAddBuf(var N1 : LbInteger; place : integer; buf : pByte; length : Integer);
var
  totalLen : integer;
  ptr : pByte;
begin

  if (place = cAPPEND_ARRAY) then begin
    totalLen := succ(N1.dwUsed + integer(length));
    if (totalLen > N1.IntBuf.dwLen) then begin
      LbBiRealloc(N1, totalLen);
    end;
    ptr := N1.IntBuf.pBuf;
    inc(ptr, N1.dwUsed);
    move(buf^, ptr^, length);
    inc(N1.dwUsed, length);
  end else begin
    totalLen := pred(place) + integer(length);
    if (totalLen > N1.IntBuf.dwLen) then begin
      LbBiRealloc(N1, totalLen);
    end;
    ptr := N1.IntBuf.pBuf;
     inc(ptr, pred(place));
    move(buf^, ptr^, length);
    if (N1.dwUsed < totalLen) then begin
      N1.dwUsed := totalLen;
    end;
  end;
end;

procedure LbBiReverseBitsInPlace(var N1 : LbInteger);
var
  rev : LbInteger;
begin
  LbBiInit(rev, N1.IntBuf.dwLen);
  try
    LbBiReverseAllBits(N1, rev);
    LbBiClear(N1);
    N1.dwUsed := rev.dwUsed;
    N1.bSign := rev.bSign;
    LbBiCopy(N1, rev, rev.dwUsed);
  finally
    LbBiFree(rev);
  end;
end;

procedure LbBiReverseAllBits(N1 : LbInteger; var N2 : LbInteger);
var
  i : integer;
  byt_ptr : pByte;
begin
  LbBiReverseBytes(N1, N2);
  byt_ptr := N2.IntBuf.pBuf;
  for i := 1 to N2.dwUsed do begin
    byt_ptr^ := LbBiReverseBits(byt_ptr^);
    Inc((byt_ptr));
  end;
end;

procedure LbBiReverseBytesInPlace(var N1 : LbInteger);
var
  rev : LbInteger;
begin
  LbBiInit(rev, N1.IntBuf.dwLen);
  try
    LbBiReverseBytes  (N1, rev);
    LbBiClear(N1);
    N1.dwUsed := rev.dwUsed;
    N1.bSign := rev.bSign;
    LbBiCopy(N1, rev, rev.dwUsed);
  finally
    LbBiFree(rev);
  end;
end;

procedure LbBiReverseBytes(N1 : LbInteger; var N2 : LbInteger);
var
  tmp_ptr : pByte;
  cnt : integer;
begin
  tmp_ptr := N2.IntBuf.pBuf;
  FillChar(N2, SizeOf(N2), $00);
  N2.IntBuf.pBuf := tmp_ptr;
  N2.bSign := N1.bSign;
  N2.dwUsed := 0;
  if (N2.IntBuf.dwLen < N1.IntBuf.dwLen) then begin
    LbBiRealloc(N2, N1.IntBuf.dwLen);
  end;
  for cnt := N1.dwUsed downto 1 do begin
    LbBiAddByte(N2 , cAPPEND_ARRAY, LbBiGetByteValue(N1, cnt));
  end;
end;

procedure LbBiSubByDigitInPlace(var N1 : LbInteger; N2 : byte);
var
  diff : LbInteger;
begin
  LbBiInit(diff, N1.dwUsed);
  try
    LbBiSubByDigit(N1, N2, diff);
    LbBiClear(N1);
    N1.dwUsed := diff.dwUsed;
    N1.bSign := diff.bSign;
    if (N1.IntBuf.dwLen < diff.IntBuf.dwLen) then begin
      LbBiRealloc(N1, diff.IntBuf.dwLen);
    end;

    LbBiCopy(N1 , diff, diff.dwUsed);
  finally
    LbBiFree(diff);
  end;
end;

procedure LbBiAddByDigitInPlace(var N1 : LbInteger; N2 : byte);
var
  sum : LbInteger;
begin
  LbBiInit(sum, N1.dwUsed);
  try
    LbBiAddByDigit(N1, N2, sum);
    LbBiClear(N1);
    N1.dwUsed := sum.dwUsed;
    N1.bSign := sum.bSign;
    if (N1.IntBuf.dwLen < sum.IntBuf.dwLen) then begin
      LbBiRealloc(N1, sum.IntBuf.dwLen);
    end;

    LbBiCopy(N1 , sum, sum.dwUsed);
  finally
    LbBiFree(sum);
  end;
end;

procedure LbBiSubByDigit(N1 : LbInteger; N2 : byte; var Sum : LbInteger);
var
  tmp : LbInteger;
begin
  LbBiInit(tmp, N1.dwUsed);
  try
    LbBiAddByte(tmp, cPREPEND_ARRAY, N2);
    LbBiSub(N1, tmp, sum);
  finally
    LbBiFree(tmp);
  end;
end;

procedure LbBiAddByDigit(N1 : LbInteger; N2 : byte; var Sum : LbInteger);
var
  tmp : LbInteger;
begin
  LbBiInit(tmp, N1.dwUsed);
  try
    LbBiAddByte(tmp, cPREPEND_ARRAY, N2);
    LbBiAdd(N1, tmp, sum);
  finally
    LbBiFree(tmp);
  end;
end;

procedure LbBiPowerAndModInPLace(var I1 : LbInteger; exponent : LbInteger; modulus : LbInteger);
var
  _Result : LbInteger;
begin
  LbBiInit(_Result, cUSE_DEFAULT_PRECISION);
  try
    LbBiPowerAndMod(I1, exponent, modulus, _Result);
    LbBiClear(I1);
    I1.dwUsed := _Result.dwUsed;
    I1.bSign := _Result.bSign;
    if (I1.IntBuf.dwLen < _Result.IntBuf.dwLen) then begin
      LbBiRealloc(I1, _Result.IntBuf.dwLen);
    end;
    LbBiCopy(I1, _Result, _Result.dwUsed);
  finally
    LbBiFree(_Result);
  end;
end;

procedure LbBiPowerAndMod(I1 : LbInteger; exponent : LbInteger; modulus : LbInteger; var _Result : LbInteger);
var
  BitCount : Integer;
  i : Integer;
  tmp_byte : byte;
  hold : LbInteger;
begin
  LbBiClear(_Result);

  if (LbBiIsZero(exponent)) then begin
    LbBiAddByte(_Result , cPREPEND_ARRAY, $01);
    exit;
  end;
  LbBiInit (hold, cDEFAULT_PRECISION);
  try
    i := exponent.dwUsed;
    LbBiAddByte(_Result , cPREPEND_ARRAY, $01);
    while i > 0 do begin
      tmp_byte := LbBiGetByteValue(exponent, i);
      dec(i);
      Bitcount := 8;
      tmp_byte := LbBiReverseBits(tmp_byte);

      while bitcount > 0 do begin
        LbBiMultInPlace(_Result, _Result);
        LbBiModInPlace(_Result, modulus);
        if Odd(tmp_byte) then begin
          LbBiMultInPlace(_Result, I1);
          LbBiModInPlace(_Result, modulus);
        end;
        tmp_byte := tmp_byte shr 1;
        dec(Bitcount);
      end;
    end;
  finally
    LbBiFree(hold);
  end;
end;

procedure LbBiModInPlace(var N1 : LbInteger; Modulas : LbInteger);
var
  remainder : LbInteger;
begin
  LbBiInit(remainder, Modulas.dwUsed);
  LbBiMod(N1, Modulas, remainder);

  LbBiClear(N1);
  N1.dwUsed := remainder.dwUsed;
  N1.bSign := remainder.bSign;

  if (N1.IntBuf.dwLen < remainder.IntBuf.dwLen) then begin
    LbBiRealloc(N1, remainder.IntBuf.dwLen);
  end;

  LbBiCopy(N1, remainder, remainder.dwUsed);
  LbBiFree(remainder);
end;

procedure LbBiMod(N1 : LbInteger; N2 : LbInteger; var remainder : LbInteger);
var
  quotient : LbInteger;
begin
  LbBiInit(quotient, N2.dwUsed);
  LbBiDiv(N1, N2, quotient, remainder);
  LbBiFree(quotient);
end;

procedure LbBiDivInPlace(var N1 : LbInteger; N2 : LbInteger; var remainder : LbInteger);
var
  quotient : LbInteger;
begin
  LbBiInit(quotient, N1.dwUsed);
  try
    LbBiDiv(N1, N2, quotient, remainder);
    LbBiClear(N1);
    N1.dwUsed := quotient.dwUsed;
    N1.bSign := quotient.bSign;
    if (N1.IntBuf.dwLen < quotient.IntBuf.dwLen) then begin
      LbBiRealloc(N1, quotient.IntBuf.dwLen);
    end;
    LbBiCopy(N1, quotient, quotient.dwUsed);
  finally
    LbBiFree(quotient);
  end;
end;

procedure LbBiDiv(N1 : LbInteger; N2 : LbInteger; var quotient : LbInteger; var remainder : LbInteger);
begin
  LbBiDivBase(N1, N2, quotient, remainder);
  if (N1.bSign = N2.bSign) then begin
    quotient.bSign := cPOSITIVE
  end else begin
    quotient.bSign := cNEGATIVE;
  end;
end;

procedure LbBiDivBase(N1 : LbInteger; N2 : LbInteger; var quotient : LbInteger; var remainder : LbInteger);
var
  factor : byte;
  InxQ : Integer;
  InxX : Integer;
  tmpByte : byte;
  tmpInt : integer;
  sigDigit : byte;
  lclQT : longint;
  lclDVD : LbInteger;
  lclDSR : LbInteger;
  tmpDR : LbInteger;
  tmpBN : LbInteger;
  sigDivd : longint;
begin
  LbBiInit(lclDVD, N1.dwUsed);
  LbBiInit(lclDSR, N1.dwUsed);
  LbBiInit(tmpDR, N1.dwUsed);
  LbBiInit(tmpBN, N1.dwUsed);
  try
    if (N1.dwUsed < 1)or
      (N2.dwUsed < 1) then
        raise Exception.Create(sBINoNumber);

    if LbBiIsZero( N1 )then begin
      LbBiAddByte(quotient , cPREPEND_ARRAY, $00);
      LbBiAddByte(remainder, cPREPEND_ARRAY, $00);
      exit;
    end;

    if LbBiIsOne( N2 )then begin
      LbBiCopy(quotient, N1, N1.dwUsed);
      LbBiAddByte(remainder, cPREPEND_ARRAY, $00);
      exit;
    end;
    if LbBiIsZero( N2 )then
        raise Exception.Create(sBIZeroDivide);
    LbBiCopy(lclDVD, N1, N1.dwUsed);
    LbBiCopy(lclDSR, N2, N2.dwUsed);
    LbBiTrimSigZeros(lclDSR);

    tmpByte := pBiByteArray(lclDSR.IntBuf.pBuf)[pred(lclDSR.dwUsed)];
    if (tmpByte = 0) then
      raise Exception.Create(sBIZeroFactor);

    factor := LbBiFindFactor(tmpByte);
    if (factor <> 1) then begin
      LbBiMulByDigitInPlace(lclDVD, factor);
      LbBiMulByDigitInPlace(lclDSR, factor);
    end;
    if pBiByteArray(lclDVD.IntBuf.pBuf)[pred(lclDVD.dwUsed)] >= pBiByteArray(lclDSR.IntBuf.pBuf)[pred(lclDSR.dwUsed)] then begin
      LbBiAddByte(lclDVD, cAPPEND_ARRAY, $00);
    end;

    while(lclDVD.dwUsed < lclDSR.dwUsed)do begin
      LbBiAddByte(lclDVD, cAPPEND_ARRAY, $00);
    end;

    InxQ := lclDVD.dwUsed - lclDSR.dwUsed + 1;
    InxX := lclDVD.dwUsed;

    LbBiClear(quotient);
    LbBiClear(remainder);

    sigDigit := pBiByteArray(lclDSR.IntBuf.pBuf)[pred(lclDSR.dwUsed)];
    if (sigDigit = 0) then begin
      tmpInt := pred(lclDSR.dwUsed);
      while sigDigit = 0 do begin
        sigDigit := pBiByteArray(lclDSR.IntBuf.pBuf)[tmpInt];
        dec(tmpInt);
        if tmpInt < 0 then
          raise Exception.Create(sBIQuotientErr);
      end;
    end;

    while InxQ >= 1 do begin
      if (lclDVD.dwUsed = 1) then begin
        sigDivd := pBiByteArray(lclDVD.IntBuf.pBuf)[0]
      end
      else begin
        sigDivd := integer(pBiByteArray(lclDVD.IntBuf.pBuf)[InxX]) shl 8 + pBiByteArray(lclDVD.IntBuf.pBuf)[pred(InxX)];
      end;

      lclQT := sigDivd div sigDigit;
      if (lclQT <> 0) then begin
        if (lclQT >= cBYTE_POSSIBLE_VALUES) then begin
          lclQT := pred(cBYTE_POSSIBLE_VALUES);
        end;

        LbBiClear(tmpDR);
        LbBiMove(tmpDR, lclDSR, InxQ, lclDSR.dwUsed);

        LbBiMulByDigitInPlace(tmpDR, lclQT);

        while(LbBiCompare(lclDVD, tmpDR) = cLESS_THAN)do begin
          dec(lclQT);
          if (lclQT = 0) then break;

          LbBiClear(tmpDR);
          LbBiMove(tmpDR, lclDSR, InxQ, lclDSR.dwUsed);

          LbBiMulByDigitInPlace(tmpDR, lclQT);
        end;
      end;

      if (lclQT <> 0) then begin

        LbBiAddByte(quotient, InxQ , lclQT);
        LbBiSubInPlace (lclDVD, tmpDR);
      end;
      dec(InxX);
      dec(InxQ);
    end;

    LbBiCopy(remainder, lclDVD, lclDVD.dwUsed);

    if (factor <> 0) then begin
      if (remainder.dwUsed > 1) then begin
        LbBiDivByDigitInPlace(remainder, factor, tmpByte);
      end else if (remainder.dwUsed = 1) then begin
        tmpByte := pBiByteArray(remainder.IntBuf.pBuf)[0];
        tmpByte := tmpByte div factor;
        LbBiAddByte(remainder, cPREPEND_ARRAY, tmpByte);
      end;
    end;
  finally
    LbBiFree(lclDVD);
    LbBiFree(lclDSR);
    LbBiFree(tmpDR);
    LbBiFree(tmpBN);

    if (quotient.dwUsed = 0) then begin
      LbBiAddByte(quotient, cPREPEND_ARRAY, $00);
    end;

    if (remainder.dwUsed = 0) then begin
      LbBiAddByte(remainder, cPREPEND_ARRAY, $00);
    end;

    LbBiTrimSigZeros(quotient);
    LbBiTrimSigZeros(remainder);
  end;
end;

procedure LbBiDivByDigitInPlace(var N1 : LbInteger; N2 : byte; var remainder : byte);
var
  tmp : LbInteger;
  precis : Integer;
begin
  precis := (N1.dwUsed + 1) * 2;
  LbBiInit(tmp, precis);
  try
    LbBiDivByDigit(N1, N2, tmp, remainder);

    N1.dwUsed := tmp.dwUsed;
    N1.bSign := tmp.bSign;
    if (N1.IntBuf.dwLen < tmp.IntBuf.dwLen) then begin
      LbBiRealloc(N1, tmp.IntBuf.dwLen);
    end;
    LbBiCopy(N1, tmp, tmp.dwUsed);
  finally
    LbBiFree(tmp);
  end;
end;

procedure LbBiDivByDigit(N1 : LbInteger; N2 : byte; var quotient : LbInteger; var remainder : byte);
begin
  LbBiDivByDigitBase(N1, N2, quotient, remainder);
  quotient.bSign := N1.bSign;
end;

procedure LbBiDivByDigitBase(N1 : LbInteger; N2 : byte; var quotient : LbInteger; var remainder : byte);
var
  factor : byte;
  c : Integer;
  tmp : Integer;
  sigDivd : longint;
  lclQT : longint;
  Carry : WORD;
  plc : integer;
  lclDVD : LbInteger;
  divisor : byte;
begin
  LbBiInit(lclDVD, N1.dwUsed);
  Carry := 0;
  try
    if (LbBiIsZero(N1)) then begin
        LbBiAddByte(quotient, cPREPEND_ARRAY, $00);
        exit;
      end;
    if (N2 = 1) then begin
      LbBiCopy(quotient, N1, N1.dwUsed);
      exit;
    end;
    if (N2 = 0) then
      raise Exception.Create(sBIZeroDivide);

    LbBiCopy(lclDVD, N1, N1.dwUsed);
    divisor := N2;
    factor := LbBiFindFactor(N2);
    if (factor <> 1) then begin
      LbBiMulByDigitInPlace(lclDVD, factor);
      divisor := divisor * factor;
    end;
    if pBiByteArray( lclDVD.IntBuf.pBuf )[pred(lclDVD.dwUsed)] >= divisor then begin
      LbBiAddByte(lclDVD, cAPPEND_ARRAY, $00);
    end;

    LbBiClear(quotient);
    remainder := 0;

    plc := pred(lclDVD.dwUsed);
    if (lclDVD.dwUsed > quotient.dwUsed) then begin
       LbBiRealloc(quotient, lclDVD.dwUsed);
    end;
    Carry := 0;
    tmp := pred(lclDVD.dwUsed);
    for c := tmp downto 0 do begin
      sigDivd := (Carry shl 8) or (integer(pBiByteArray(lclDVD.IntBuf.pBuf)[c]));
      if (SigDivd < divisor) then begin
        Carry := SigDivd;
        dec(plc);
        continue;
      end;

      lclQT := sigDivd div divisor;
      if (lclQT <> 0) then begin
        if (lclQT >= cBYTE_POSSIBLE_VALUES) then begin
          lclQT := pred(cBYTE_POSSIBLE_VALUES);
        end;

        while sigDivd < (divisor * lclQT)do begin
          dec(lclQT);
          if (lclQT = 0) then
            raise Exception.Create(sBIQuotientErr);
        end;
      end;

      if (lclQT <> 0) then begin
        pBiByteArray(quotient.IntBuf.pBuf )[plc] := lclQT;
        if (quotient.dwUsed < succ(plc)) then begin
          quotient.dwUsed := succ(plc);
        end;

        Carry := sigDivd - (divisor * lclQT);
      end;
      dec(plc);
    end;
  finally
    remainder := Carry;
    if (quotient.dwUsed = 0) then begin
      LbBiAddByte(quotient, cPREPEND_ARRAY, $00);
    end;

    LbBiFree(lclDVD);
    LbBiTrimSigZeros(quotient);
  end;
end;

procedure LbBiMulByDigitInPlace(var N1 : LbInteger; N2 : byte);
var
 product : LbInteger;
 precis : Integer;
begin
  precis := (N1.dwUsed + 1) * 2;
  LbBiInit(product, precis);
  try
    LbBiMulByDigit(N1, N2, product);
    if (N1.IntBuf.dwLen < product.IntBuf.dwLen) then begin
      LbBiRealloc(N1, product.IntBuf.dwLen);
    end;
    N1.bSign := product.bSign;
    N1.dwUsed := product.dwUsed;
    LbBiCopy(N1, product, product.dwUsed);
  finally
    LbBiFree(product);
  end;
end;

procedure LbBiMulByDigit(N1 : LbInteger; N2 : byte; var product : LbInteger);
begin
  LbBiMulByDigitBase(N1, N2, product);
  product.bSign := N1.bSign;
end;

procedure LbBiMulByDigitBase(N1 : LbInteger; N2 : byte; var product : LbInteger);
var
  cnt : integer;
  carry : byte;
  prd : WORD;
  byt : byte;
  tmp : integer;
begin
  if (N2 = 1) then begin
    if (product.IntBuf.dwLen < N1.IntBuf.dwLen) then begin
      LbBiRealloc(product, N1.IntBuf.dwLen);
    end;
    product.dwUsed := N1.dwUsed;
    product.bSign := N1.bSign;
    LbBiCopy(product, N1, N1.dwUsed);
  end;

  if (n2 = 0) then begin
    product.dwUsed := 1;
    LbBiAddByte(product, cPREPEND_ARRAY, 0);
  end;

  if LbBiIsOne( N1 ) then begin
    product.dwUsed := 1;
    LbBiAddByte(product, cPREPEND_ARRAY, N2);
  end;
  if (N1.dwUsed = 1) and (pBiByteArray( N1.IntBuf.pBuf )[0] = 0) then begin
    product.dwUsed := 1;
    LbBiAddByte(product, cPREPEND_ARRAY, 0);
  end;

  Carry := 0;
  tmp := pred( N1.dwUsed );
  for cnt := 0 to tmp do begin
    prd   := (pBiByteArray( N1.IntBuf.pBuf )[cnt] * N2) + Carry;
    byt   := prd and $00FF;
    Carry := prd shr 8;
    pBiByteArray(Product.IntBuf.pBuf )[cnt] := byt;
    if (Product.dwUsed < succ(cnt)) then begin
      N1.dwUsed := succ(cnt);
    end;
  end;
  LbBiAddByte(Product, succ(N1.dwUsed), Carry);
  LbBiTrimSigZeros(Product);
end;

procedure LbBiMultInPlace(var N1 : LbInteger; N2 : LbInteger);
var
  product : LbInteger;
  precis : Integer;
begin
  precis := (N1.dwUsed + N2.dwUsed) * 2;
  LbBiInit(product, precis);
  LbBiMult(N1, N2, product);
  LbBiClear(N1);
  N1.dwUsed := product.dwUsed;
  N1.bSign := product.bSign;
  if (N1.IntBuf.dwLen < product.IntBuf.dwLen) then begin
    LbBiRealloc(N1, product.IntBuf.dwLen);
  end;
  LbBiCopy(N1, product, product.dwUsed);
  LbBiFree(product);
end;

procedure LbBiMult(N1 : LbInteger; N2 : LbInteger; var Product : LbInteger);
begin
  LbBiMultBase(N1, N2, Product);
  if (N1.bSign = N2.bSign) then begin
    Product.bSign := cPOSITIVE
  end else begin
    Product.bSign := cNEGATIVE;
  end;
end;

procedure LbBiMultBase(N1 : LbInteger; N2 : LbInteger; var Product : LbInteger);
var
  InxX : integer;
  InxY : integer;
  MaxX : integer;
  Carry : integer;
  prd : integer;
  plc : integer;
  byt : byte;
  tmp : integer;
begin
  if (MultSpecialCase(N1, N2, Product)) then
    exit;
  MaxX := pred(N1.dwUsed);
  tmp := pred(N2.dwUsed);
  for InxY := 0 to tmp do begin
    if pBiByteArray(N2.IntBuf.pBuf)[InxY] <> 0 then begin
      Carry := 0;
      for InxX := 0 to MaxX do begin
        plc := InxX + InxY;
        prd := pBiByteArray(N1.IntBuf.pBuf)[InxX];
        prd := prd * pBiByteArray(N2.IntBuf.pBuf)[InxY];
        if (Product.dwUsed < plc) then begin
          prd := prd + Carry
        end else begin
          prd := prd + pBiByteArray(Product.IntBuf.pBuf)[plc] + Carry;
        end;

        byt := prd and $00FF;
        Carry := prd shr 8;

        if (succ(plc) > Product.IntBuf.dwLen) then begin
          LbBiRealloc(Product, plc + 100);
        end;
        pBiByteArray(Product.IntBuf.pBuf )[plc] := byt;
        if (Product.dwUsed < succ(plc)) then begin
          N1.dwUsed := succ(plc);
        end;
      end;
      LbBiAddByte(Product, (MaxX + InxY + 2), Carry);
    end;
   end;
  LbBiTrimSigZeros(Product);
end;

function MultSpecialCase(N1 : LbInteger; N2 : LbInteger; var Product : LbInteger) : Boolean;
begin
  Result := False;
  if (LbBiIsZero(N1) or LbBiIsZero(N2)) then begin
    LbBiAddByte(Product, cPREPEND_ARRAY, $00);
    Result := True;
    exit;
  end;
  if (LbBiIsOne(N1)) then begin
    product.dwUsed := N2.dwUsed;

    if (product.IntBuf.dwLen < N2.IntBuf.dwLen) then begin
      LbBiRealloc(product, N2.IntBuf.dwLen);
    end;

    LbBiCopy(product, N2, N2.dwUsed);
    Result := True;
    exit;
  end;
  if (LbBiIsOne(N2)) then begin
    product.dwUsed := N1.dwUsed;

    if (product.IntBuf.dwLen < N1.IntBuf.dwLen) then begin
      LbBiRealloc(product, N1.IntBuf.dwLen);
    end;

    LbBiCopy(product, N1, N1.dwUsed);
    Result := True;
  end;
end;

procedure LbBiSubInPlace(var N1 : LbInteger;  N2 : LbInteger);
var
  Difference : LbInteger;
  prec : Integer;
begin
  if (N1.dwUsed > N2.dwUsed) then begin
    prec := succ(N1.dwUsed)
  end else begin
    prec := succ(N2.dwUsed);
  end;

  LbBiInit(Difference, prec);
  try
    LbBiSub(N1, N2, Difference);
    LbBiClear(N1);
    N1.dwUsed := Difference.dwUsed;
    N1.bSign := Difference.bSign;
    if (N1.IntBuf.dwLen < Difference.IntBuf.dwLen) then begin
      LbBiRealloc(N1, Difference.IntBuf.dwLen);
    end;
    LbBiCopy(N1, Difference, Difference.dwUsed);
  finally
    LbBiFree(Difference);
  end;
end;

procedure LbBiAddInPlace(var N1 : LbInteger; N2 : LbInteger);
var
  sum : LbInteger;
  prec : Integer;
begin
  if (N1.dwUsed > N2.dwUsed) then begin
    prec := succ(N1.dwUsed)
  end else begin
    prec := succ(N2.dwUsed);
  end;

  LbBiInit(sum, prec);
  try
    LbBiAdd(N1, N2, sum);
    LbBiClear(N1);
    N1.dwUsed := sum.dwUsed;
    N1.bSign := sum.bSign;
    if (N1.IntBuf.dwLen < sum.IntBuf.dwLen) then begin
      LbBiRealloc(N1, sum.IntBuf.dwLen);
    end;
    LbBiCopy(N1 , sum, sum.dwUsed);
  finally
    LbBiFree(sum);
  end;
end;

procedure LbBiSub(N1 : LbInteger; N2 : LbInteger; var diff : LbInteger);
begin
  N2.bSign := not N2.bSign;
  LbBiAdd(N1, N2, diff);
end;

procedure LbBiAdd(N1 : LbInteger; N2 : LbInteger; var Sum : LbInteger);
var
  value : Shortint;
begin
  if (N1.bSign = N2.bSign) then begin
    Sum.bSign := N1.bSign;
    LbBiAddBase(N1, N2, Sum);
  end else begin
    value := LbBiAbs(N1, N2);
    if (value = cEQUAL_TO) then begin
      LbBiAddByte(Sum, cPREPEND_ARRAY, $00);
      exit;
    end else if (value = cGREATER_THAN) then begin
      Sum.bSign := N1.bSign;
      LbBiSubBase(N1, N2, Sum);
    end else begin
      Sum.bSign := N2.bSign;
      LbBiSubBase(N2, N1, Sum);
    end;
  end;
end;

procedure LbBiSubBase(N1 : LbInteger; N2 : LbInteger; var Diff : LbInteger);
var
  tmp : integer;
  Borrow : WORD;
  cnt : integer;
  x : integer;
begin
  if( LbBiIsZero( N1 ))then begin
    LbBiCopy(Diff, N2, N2.dwUsed);
    exit;
  end;

  if( LbBiIsZero( N2 ))then begin
    LbBiCopy(Diff, N1, N1.dwUsed);
    exit;
  end;

  Borrow := 0;
  x := pred(N1.dwUsed);
  for cnt := 0 to x do begin
    tmp := pBiByteArray(N1.IntBuf.pBuf)[cnt];
    if (N2.dwUsed < succ(cnt)) then begin
      tmp := tmp - Borrow
    end else begin
      tmp := tmp - (pBiByteArray(N2.IntBuf.pBuf)[cnt] + Borrow);
    end;

    if (tmp < 0) then begin
      inc(tmp, cBYTE_POSSIBLE_VALUES);
      Borrow := 1;
    end else begin
      Borrow := 0;
    end;

    if (succ(Diff.dwUsed) > Diff.IntBuf.dwLen) then begin
      LbBiRealloc(Diff, succ(Diff.dwUsed));
    end;
    pBiByteArray(Diff.IntBuf.pBuf )[Diff.dwUsed] := tmp;
    inc(Diff.dwUsed);
  end;
  if (Borrow <> 0) then
    raise Exception.Create(sBISubtractErr);
  LbBiTrimSigZeros(Diff);
end;

procedure LbBiAddBase(N1 : LbInteger; N2 : LbInteger; var Sum : LbInteger);
var
  Carry : byte;
  cnt : Integer;
  Count : integer;
  tmp_wrd : WORD;
  tmp_byt : byte;
begin
  LbBiFindLargestUsed(N1, N2, Count);

  if( LbBiIsZero( N1 ))then begin
    LbBiCopy(sum, N2, N2.dwUsed);
    exit;
  end;

  if( LbBiIsZero( N2 ))then begin
    LbBiCopy(sum, N1, N1.dwUsed);
    exit;
  end;

  Carry := 0;
  if (succ(count) > Sum.dwUsed) then begin
    LbBiRealloc(Sum, succ(count));
  end;
  for cnt := 1 to count do begin
    tmp_wrd := LbBiGetByteValue(N1, cnt) + LbBiGetByteValue(N2, cnt) + Carry;
    tmp_byt := tmp_wrd and $00FF;
    Carry   := tmp_wrd shr 8;
    pBiByteArray(Sum.IntBuf.pBuf )[Sum.dwUsed] := tmp_byt;
    inc(Sum.dwUsed);
  end;
  LbBiAddByte(Sum, cAPPEND_ARRAY, Carry);
  LbBiTrimSigZeros(Sum);
end;

procedure LbBiMove(var dest : LbInteger; src : LbInteger; place : integer; len : Integer);
var
  ptr : pByte;
  size : integer;
begin
  if (not assigned(dest.IntBuf.pBuf)) then
    raise Exception.Create(sBIBufferNotAssigned);

  if (place = cAPPEND_ARRAY) then begin
    if ((integer(len) + dest.dwUsed) > dest.IntBuf.dwLen) then begin
      LbBiRealloc(dest, (integer(len) + dest.dwUsed));
    end;

    ptr := dest.IntBuf.pBuf;
    inc(ptr, dest.dwUsed);
    move(src.IntBuf.pBuf^, ptr^, len);
    inc(dest.dwUsed, len);
  end else begin
    size := pred(place) + integer(len);
    if size > dest.IntBuf.dwLen then begin
      LbBiRealloc(dest, size);
    end;
    ptr := dest.IntBuf.pBuf;
    inc(ptr, pred(place));
    move(src.IntBuf.pBuf^, ptr^, len);
    if (dest.dwUsed < size) then begin
      dest.dwUsed := size;
    end;
  end;
end;

procedure LbBiXORInPlace(var N1 : LbInteger; N2 : LbInteger);
var
  Nxor : LbInteger;
  prec : Integer;
begin
  if (N1.dwUsed > N2.dwUsed) then begin
    prec := succ(N1.dwUsed)
  end else begin
    prec := succ(N2.dwUsed);
  end;
  LbBiInit(Nxor, prec);
  try
    LbBiXOR(N1, N2, Nxor);
    LbBiClear(N1);
    N1.dwUsed := Nxor.dwUsed;
    N1.bSign := Nxor.bSign;
    if (N1.IntBuf.dwLen < Nxor.IntBuf.dwLen) then begin
      LbBiRealloc(N1, Nxor.IntBuf.dwLen);
    end;
    LbBiCopy(N1 , Nxor, Nxor.dwUsed);
  finally
    LbBiFree(Nxor);
  end;
end;

procedure LbBiXOR(N1 : LbInteger; N2 : LbInteger; var NXOR : LbInteger);
var
  count : integer;
  i : integer;
  a : byte;
  b : byte;
begin
  LbBiVerify(N1);
  LbBiVerify(N2);
  LbBiPrepare(N1, N2, NXOR);

  LbBiAddByte(NXOR, cPREPEND_ARRAY, $00);
  LbBiFindLargestUsed(N1, N2, count);
  for i := 1 to count do begin
    a := LbBiGetByteValue(N1, i);
    b := LbBiGetByteValue(N2, i);
    a := a xor b;
    LbBiAddByte(NXOR, i, a);
  end;
end;

procedure LbBiORInPlace(var N1 : LbInteger; N2 : LbInteger);
var
  Nor : LbInteger;
  prec : Integer;
begin
  if (N1.dwUsed > N2.dwUsed) then begin
    prec := succ(N1.dwUsed)
  end else begin
    prec := succ(N2.dwUsed);
  end;
  LbBiInit(Nor, prec);
  try
    LbBiOR(N1, N2, Nor);
    LbBiClear(N1);
    N1.dwUsed := Nor.dwUsed;
    N1.bSign := Nor.bSign;
    if (N1.IntBuf.dwLen < Nor.IntBuf.dwLen) then begin
      LbBiRealloc(N1, Nor.IntBuf.dwLen);
    end;
    LbBiCopy(N1 , Nor, Nor.dwUsed);
  finally
    LbBiFree(Nor);
  end;
end;

procedure LbBiOR(N1 : LbInteger; N2 : LbInteger; var NOR : LbInteger);
var
  count : integer;
  i : integer;
  a : byte;
  b : byte;
begin
  LbBiVerify(N1);
  LbBiVerify(N2);
  LbBiPrepare(N1, N2, NOR);

  LbBiAddByte(NOR, cPREPEND_ARRAY, $00);
  LbBiFindLargestUsed(N1, N2, count);
  for i := 1 to count do begin
    a := LbBiGetByteValue(N1, i);
    b := LbBiGetByteValue(N2, i);
    a := a or b;
    LbBiAddByte(NOR, i, a);
  end;
end;

procedure LbBiShl(var N1 : LbInteger; _shl : Integer);
var
  bitShl : byte;
  byteShl : Integer;
  tmp : word;
  shifted : byte;
  carry : byte;
  t : LbInteger;
  i : Integer;
  x : Integer;
begin

  if _shl < 1 then exit;
  LbBiVerify(N1);
  LbBiInit(t, cDEFAULT_PRECISION);
  LbBiAddByte(t, cPREPEND_ARRAY, $00);

  byteShl := _shl div 8;
  bitShl := _shl mod 8;

  try
    carry := 0;
    x := 0;
    for i := 1 to N1.dwUsed do begin
      tmp := pBiByteArray( N1.IntBuf.pBuf )[pred(i)];
      shifted := ((tmp shl bitShl) and $00FF) or carry;
      LbBiAddByte(t, i + byteShl, byte(shifted and $00FF));
      carry := ((tmp shr (8 - bitShl)) and $00FF);
      x := i;
    end;
    LbBiAddByte(t, succ(x) + byteShl, carry);
    LbBiCopy(N1, t, t.dwUsed);
  finally
    LbBiTrimSigZeros(N1);
    LbBiFree(t);
  end;
end;

procedure LbBiShr(var N1 : LbInteger; _shr : Integer);
var
  bitShr : byte;
  byteShr : Integer;
  carry : byte;
  tmp : word;
  shifted : byte;
  i : Integer;
  t : LbInteger;
begin
  if _shr < 1 then exit;

  LbBiVerify(N1);
  LbBiInit(t, cDEFAULT_PRECISION);
  LbBiAddByte(t, cPREPEND_ARRAY, $00);

  byteShr := _shr div 8;
  bitShr := _shr mod 8;
  if( byteShr > integer( N1.dwUsed ))then begin
    LbBiClear( N1 );
    LbBiAddByte( N1, cPREPEND_ARRAY, $00 );
  end;

  carry := 0;
  try
    for i := N1.dwUsed downto 1 do begin
      if (i - byteShr) < 1 then break;
      tmp := pBiByteArray( N1.IntBuf.pBuf )[pred(i)];
      shifted := (tmp shr bitShr) or carry;
      LbBiAddByte(t, i - byteShr, byte(shifted and $00FF));
      carry := ((tmp shl (8 - bitShr)) and $00FF);
    end;
    LbBiCopy(N1, t, t.dwUsed);
  finally
    LbBiTrimSigZeros( N1 );
    LbBiFree(t);
  end;
end;

function LbBiReverseBits(byt : Byte) : Byte;
var
  i : byte;
  rBit : Byte;
begin
  Result := 0;
  rBit := $80;
  for i := 1 to 8 do begin
    if ((byt and $01) <> 0) then begin
      Result := Result or rBit;
    end;
    rBit := rBit shr 1;
    byt := byt shr 1;
  end;
end;

procedure LbBiSwap(var N1 : LbInteger; var N2 : LbInteger);
var
  tmp : LbInteger;
begin
  tmp.bSign := N1.bSign;
  tmp.dwUsed := N1.dwUsed;
  tmp.IntBuf.dwLen := N1.IntBuf.dwLen;
  tmp.IntBuf.pBuf := N1.IntBuf.pBuf;

  N1.bSign := N2.bSign;
  N1.dwUsed := N2.dwUsed;
  N1.IntBuf.dwLen := N2.IntBuf.dwLen;
  N1.IntBuf.pBuf := N2.IntBuf.pBuf;

  N2.bSign := tmp.bSign;
  N2.dwUsed := tmp.dwUsed;
  N2.IntBuf.dwLen := tmp.IntBuf.dwLen;
  N2.IntBuf.pBuf := tmp.IntBuf.pBuf;
end;

function LbBiIsEven(N1 : LbInteger): Boolean;
begin
  Result := not (odd(LbBiGetByteValue(N1, 1)));
end;

function LbBiIsOdd(N1 : LbInteger): Boolean;
begin
  Result := odd(LbBiGetByteValue(N1, 1));
end;

function LbBiIsOne(N1 : LbInteger) : Boolean;
begin
  LbBiTrimSigZeros( N1 );
  Result := False;
  if (N1.dwUsed = 1) and (pBiByteArray( N1.IntBuf.pBuf )[0] = 1) then begin
    Result := True
  end;
end;

function LbBiIsZero(N1 : LbInteger) : Boolean;
begin
  LbBiTrimSigZeros( N1 );
  Result := False;
  if (N1.dwUsed = 1) and (pBiByteArray( N1.IntBuf.pBuf )[0] = 0) then begin
    Result := True
  end;
end;

function  LbBiAbs(N1 : LbInteger; N2 : LbInteger): Shortint;
var
  cnt : Integer;
begin
  LbBiTrimSigZeros(N1);
  LbBiTrimSigZeros(N2);

  if (N1.dwUsed <> N2.dwUsed) then begin
    if (N1.dwUsed > N2.dwUsed) then begin
      Result := cGREATER_THAN;
      exit;
    end else begin
      Result := cLESS_THAN;
      exit;
    end;
  end;
  cnt := N1.dwUsed;
  while pBiByteArray( N1.IntBuf.pBuf )[pred(cnt)] = pBiByteArray( N2.IntBuf.pBuf )[pred(cnt)] do begin
    dec(cnt);
    if (cnt = 0) then begin
      Result := cEQUAL_TO;
      exit;
    end;
  end;
  if pBiByteArray( N1.IntBuf.pBuf )[pred(cnt)] > pBiByteArray( N2.IntBuf.pBuf )[pred(cnt)] then begin
    Result := cGREATER_THAN
  end else begin
    Result := cLESS_THAN;
  end;
end;

function  LbBiCompare(N1 : LbInteger; N2 : LbInteger): Shortint;
var
  cnt : Integer;
begin
  LbBiTrimSigZeros( N1 );
  LbBiTrimSigZeros( N2 );
  if (N1.bSign <> N2.bSign) then begin
    if (N1.bSign = cPOSITIVE) then begin
      Result := cGREATER_THAN
    end else begin
      Result := cLESS_THAN;
    end;
    exit;
  end;

  if (N1.dwUsed <> N2.dwUsed) then begin
    if (N1.dwUsed > N2.dwUsed) then begin
      Result := cGREATER_THAN;
      exit;
    end else begin
      Result := cLESS_THAN;
      exit;
    end;
  end;

  cnt := N1.dwUsed;
  while pBiByteArray( N1.IntBuf.pBuf )[pred(cnt)] = pBiByteArray( N2.IntBuf.pBuf )[pred(cnt)] do begin
    dec(cnt);
    if (cnt = 0) then begin
      Result := cEQUAL_TO;
      exit;
    end;
  end;

  if pBiByteArray( N1.IntBuf.pBuf )[pred(cnt)] > pBiByteArray( N2.IntBuf.pBuf )[pred(cnt)] then begin
    Result := cGREATER_THAN
  end else begin
    Result := cLESS_THAN;
  end;
end;

procedure LbBiAddByte(var N1 : LbInteger; place : integer; _byte : byte);
begin
  if (place = cAPPEND_ARRAY) then begin
    if (succ(N1.dwUsed) > N1.IntBuf.dwLen) then begin
      LbBiRealloc(N1, succ(N1.dwUsed));
    end;
    pBiByteArray( N1.IntBuf.pBuf )[N1.dwUsed] := _byte;
    inc(N1.dwUsed);
  end else begin
    if (place > N1.IntBuf.dwLen) then begin
      LbBiRealloc(N1, place);
    end;
    pBiByteArray(N1.IntBuf.pBuf)[pred(place)] := _byte;
    if (N1.dwUsed < place) then begin
      N1.dwUsed := place;
    end;
  end;
end;

function LbBiGetBit(N1 : LbInteger; bit : Integer) : Boolean;
var
  tmp : Integer;
  mask : byte;
begin
  mask := $01;
  mask := mask shl (bit mod 8);

  tmp := (bit div 8) + 1 ;
  tmp := LbBiGetByteValue(N1, tmp);

  Result := ((mask and tmp) = mask);

end;

procedure LbBiCopy(var dest : LbInteger; src : LbInteger; len : Integer);
var
  ptr : pByte;
  size : integer;
begin
  fillchar(dest.IntBuf.pBuf^, dest.IntBuf.dwLen, $00);
  size := integer(len);
  if size > dest.IntBuf.dwLen then begin
    LbBiRealloc(dest, size);
  end;
  ptr := dest.IntBuf.pBuf;
  move(src.IntBuf.pBuf^, ptr^, len);
  if (dest.dwUsed < size) then begin
    dest.dwUsed := size;
  end;
end;

procedure LbBiPrepare(N1 : LbInteger; N2 : LbInteger; var N3 : LbInteger);
begin
  if (not(assigned(N3.IntBuf.pBuf))) then begin
    LbBiRealloc(N3, cDEFAULT_PRECISION);
  end;
  fillchar(N3.IntBuf.pBuf^, N3.IntBuf.dwLen, $00);
  N3.dwUsed := cDEFAULT_USED;
end;

function LbBiFindFactor(B1 : byte) : byte;
begin
  Result := 1;
  while(B1 < $80)do begin
    B1 := (B1 shl 1);
    Result := Result * 2;
  end;
end;

procedure LbBiFindLargestUsed(N1 : LbInteger; N2 : LbInteger; var count : integer);
begin
  if (N1.dwUsed >= N2.dwUsed) then begin
    Count := N1.dwUsed
  end else begin
    Count := N2.dwUsed;
  end;
end;

procedure LbBiVerify(var N1 : LbInteger);
begin
  if (not(assigned(N1.IntBuf.pBuf))) then
      raise Exception.Create(sBIBufferNotAssigned);
  if (N1.dwUsed = 0) then
      raise Exception.Create(sBINoNumber);
  LbBiTrimSigZeros(N1);
end;

procedure LbBiTrimSigZeros(var N1 : LbInteger);
begin
  if (not assigned(N1.IntBuf.pBuf)) then
    raise Exception.Create(sBIBufferNotAssigned);

  while(pBiByteArray( N1.IntBuf.pBuf )[pred(N1.dwUsed)] = 0)do begin
    dec(N1.dwUsed);
    if (N1.dwUsed <= 0) then begin
      N1.dwUsed := 1;
      exit;
    end;
  end;
end;

function LbBiGetByteValue (N1 : LbInteger; place : integer): byte;
begin
  if (N1.dwUsed < place) then begin
    Result := 0;
    exit;
  end;
  Result := pBiByteArray( N1.IntBuf.pBuf )[pred(place)];
end;

procedure LbBiClear(var N1 : LbInteger);
begin
  N1.bSign := cDEFAULT_SIGN;
  N1.dwUsed := cDEFAULT_USED;
  FillChar(N1.IntBuf.pBuf^, N1.IntBuf.dwLen, $00);
end;

procedure LbBiFree(var N1 : LbInteger);
begin
  if (assigned(N1.IntBuf.pBuf)) then begin
    FreeMem(N1.IntBuf.pBuf);
  end;
  FillChar(N1, SizeOf(LbInteger), $00);
end;

procedure LbBiRealloc(var N1 : LbInteger; Len : integer);
var
  tmpPtr : pByte;
begin
  if (N1.dwUsed > Len) then begin
    Exit;
  end;
  tmpPtr := AllocMem(Len);
  move(N1.IntBuf.pBuf^, tmpPtr^, N1.dwUsed);
  FreeMem(N1.IntBuf.pBuf);
  N1.IntBuf.dwLen := Len;
  N1.IntBuf.pBuf := tmpPtr;
end;

procedure LbBiInit(var N1 : LbInteger; Precision : Integer);
begin
  FillChar(N1, SizeOf(LbInteger), $00);

  if (Precision > 0) then begin
    N1.IntBuf.dwLen := Precision
  end else begin
    N1.IntBuf.dwLen := cDEFAULT_PRECISION;
  end;

  N1.bSign := cDEFAULT_SIGN;
  N1.dwUsed := cDEFAULT_USED;

  N1.IntBuf.pBuf := pByte(AllocMem(N1.IntBuf.dwLen));
end;

procedure StringHashSHA1(var Digest : TSHA1Digest; const Str : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF});
begin
  {$IFDEF LOCKBOXUNICODE}
  StringHashSHA1W(Digest, Str);
  {$ELSE}
  StringHashSHA1A(Digest, Str);
  {$ENDIF}
end;

procedure StringHashMix128(var Digest : LongInt; const Str : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF});
begin
  {$IFDEF LOCKBOXUNICODE}
  StringHashMix128W(Digest, Str);
  {$ELSE}
  StringHashMix128A(Digest, Str);
  {$ENDIF}
end;

procedure StringHashMD5(var Digest : TMD5Digest; const Str : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF});
begin
  {$IFDEF LOCKBOXUNICODE}
  StringHashMD5W(Digest, Str);
  {$ELSE}
  StringHashMD5A(Digest, Str);
  {$ENDIF}
end;

procedure StringHashLMD(var Digest; DigestSize : LongInt; const Str : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF});
begin
  {$IFDEF LOCKBOXUNICODE}
  StringHashLMDW(Digest, DigestSize, Str);
  {$ELSE}
  StringHashLMDA(Digest, DigestSize, Str);
  {$ENDIF}
end;

procedure StringHashELF(var Digest : LongInt; const Str : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF});
begin
  {$IFDEF LOCKBOXUNICODE}
  StringHashELFW(Digest, Str);
  {$ELSE}
  StringHashELFA(Digest, Str);
  {$ENDIF}
end;

procedure InitEncryptRDL(const Key; KeySize : Longint; var Context : TRDLContext; Encrypt : Boolean);
var
  i : Integer;
  Nk : Byte;
  temp : TRDLVector;
  Sk : Longint;
begin
  FillChar(Context, SizeOf(Context), #0);
  Context.Encrypt := Encrypt;
  Sk := Min(KeySize, SizeOf(Context.Rk));
  Move(Key, Context.Rk, Sk);
  Nk := KeySize div 4;
  if (Nk > RDLNk256) then begin
    Nk := RDLNk256
  end else if (Nk < RDLNk128) then begin
    Nk := RDLNk128;
  end;
  Context.Rounds := 6 + Nk;
  for i := Nk to (4 * (Context.Rounds + 1)) do begin
    temp := Context.W[i-1];
    if (Nk in [RDLNk128, RDLNk192]) then begin
      if (i mod Nk) = 0 then begin
        temp.dw := RdlSubVector(RdlRotateVector(temp, 1)).dw xor RCon[i div Nk];
      end;
      Context.W[i].dw := Context.W[i - Nk].dw xor temp.dw;
    end else begin
      if (i mod Nk) = 0 then begin
        temp.dw := RdlSubVector(RdlRotateVector(temp, 1)).dw xor RCon[i div Nk]
      end else if (i mod Nk) = 4 then begin
        temp := RdlSubVector(Temp);
      end;
      Context.W[i].dw := Context.W[i - Nk].dw xor temp.dw;
    end;
  end;
end;

procedure EncryptRDLCBC(const Context : TRDLContext; const Prev : TRDLBlock; var Block : TRDLBlock);
begin
  if Context.Encrypt then begin
    XorMemPrim(Block, Prev, SizeOf(Block));
    EncryptRDL(Context, Block);
  end else begin
    EncryptRDL(Context, Block);
    XorMemPrim(Block, Prev, SizeOf(Block));
  end;
end;

procedure EncryptRDL(const Context : TRDLContext; var Block : TRDLBlock);
var
  i : Integer;
begin
  if Context.Encrypt then begin
    XorMemPrim(Block, Context.Rk[0], SizeOf(TRDLBlock));
    for i := 1 to (Context.Rounds - 1) do
      RdlRound(Context.Rk[i], Block, False);
    RdlRound(Context.Rk[Context.Rounds], Block, True);
  end else begin
    RdlInvRound(Context.Rk[Context.Rounds], Block, True);
    for i := (Context.Rounds - 1) downto 1 do
      RdlInvRound(Context.Rk[i], Block, False);
    XorMemPrim(Block, Context.Rk[0], SizeOf(TRDLBlock));
  end;
end;

procedure RdlInvRound(const RoundKey : TRDLBlock; var State : TRDLBlock; First : Boolean);
var
  i : Integer;
  r : TRDLVectors;
  e : TRDLVector;
begin
  XorMemPrim(State, RoundKey, SizeOf(TRDLBlock));
  for i := 0 to 3 do begin
    if not First then begin
      e.dw := RDL_InvT0[TRDlVectors(State)[i].bt[0]] xor
              RDL_InvT1[TRDlVectors(State)[i].bt[1]] xor
              RDL_InvT2[TRDlVectors(State)[i].bt[2]] xor
              RDL_InvT3[TRDlVectors(State)[i].bt[3]];
      r[(i+0) mod 4].bt[0] := RDLInvSBox[e.bt[0]];
      r[(i+1) mod 4].bt[1] := RDLInvSBox[e.bt[1]];
      r[(i+2) mod 4].bt[2] := RDLInvSBox[e.bt[2]];
      r[(i+3) mod 4].bt[3] := RDLInvSBox[e.bt[3]];
    end else begin
      r[i].bt[0] := RDLInvSBox[TRDlVectors(State)[(i+0) mod 4].bt[0]];
      r[i].bt[1] := RDLInvSBox[TRDlVectors(State)[(i+3) mod 4].bt[1]];
      r[i].bt[2] := RDLInvSBox[TRDlVectors(State)[(i+2) mod 4].bt[2]];
      r[i].bt[3] := RDLInvSBox[TRDlVectors(State)[(i+1) mod 4].bt[3]];
    end;
  end;
  State := TRDLBlock(r);
end;

procedure RdlRound(const RoundKey : TRDLBlock; var State : TRDLBlock; Final : Boolean);
var
  i : Integer;
  e : TRDLVectors;
begin
  for i := 0 to 3 do begin
    if not Final then begin
      e[i].dw := RDL_T0[TRDlVectors(State)[(i+0) mod 4].bt[0]] xor
                 RDL_T1[TRDlVectors(State)[(i+1) mod 4].bt[1]] xor
                 RDL_T2[TRDlVectors(State)[(i+2) mod 4].bt[2]] xor
                 RDL_T3[TRDlVectors(State)[(i+3) mod 4].bt[3]]
    end else begin
      e[i].bt[0] := RDLSBox[TRDlVectors(State)[(i+0) mod 4].bt[0]];
      e[i].bt[1] := RDLSBox[TRDlVectors(State)[(i+1) mod 4].bt[1]];
      e[i].bt[2] := RDLSBox[TRDlVectors(State)[(i+2) mod 4].bt[2]];
      e[i].bt[3] := RDLSBox[TRDlVectors(State)[(i+3) mod 4].bt[3]];
    end;
  end;
  XorMemPrim(e, RoundKey, SizeOf(TRDLBlock));
  State := TRDLBlock(e);
end;

function RdlRotateVector(v : TRDLVector; Count : Byte) : TRDLVector;
var
  i : Byte;
begin
  i := Count mod 4;
  Result.bt[0] := v.bt[i];
  Result.bt[1] := v.bt[(i+1) mod 4];
  Result.bt[2] := v.bt[(i+2) mod 4];
  Result.bt[3] := v.bt[(i+3) mod 4];
end;

function RdlSubVector(v : TRDLVector) : TRDLVector;
begin
  Result.bt[0] := RdlSBox[v.bt[0]];
  Result.bt[1] := RdlSBox[v.bt[1]];
  Result.bt[2] := RdlSBox[v.bt[2]];
  Result.bt[3] := RdlSBox[v.bt[3]];
end;

procedure StringHashSHA1A(var Digest : TSHA1Digest; const Str : AnsiString);
begin
  HashSHA1(Digest, Str[1], Length(Str) * SizeOf(AnsiChar));
end;

procedure HashSHA1( var Digest : TSHA1Digest; const Buf; BufSize : Longint );
var
  Context : TSHA1Context;
begin
  InitSHA1( Context );
  UpdateSHA1( Context, Buf, BufSize );
  FinalizeSHA1( Context, Digest );
end;

procedure FinalizeSHA1( var Context : TSHA1Context; var Digest : TSHA1Digest );
begin
  with Context do begin
    sdBuf[ sdIndex ] := $80;

    if sdIndex >= 56 then begin
      SHA1Hash( Context );
    end;

    PDWord( @sdBuf[ 56 ])^ := SHA1SwapByteOrder( sdHi );
    PDWord( @sdBuf[ 60 ])^ := SHA1SwapByteOrder( sdLo );

    SHA1Hash( Context );

    sdHash[ 0 ] := SHA1SwapByteOrder( sdHash[ 0 ]);
    sdHash[ 1 ] := SHA1SwapByteOrder( sdHash[ 1 ]);
    sdHash[ 2 ] := SHA1SwapByteOrder( sdHash[ 2 ]);
    sdHash[ 3 ] := SHA1SwapByteOrder( sdHash[ 3 ]);
    sdHash[ 4 ] := SHA1SwapByteOrder( sdHash[ 4 ]);

    Move( sdHash, Digest, Sizeof( Digest ));
    SHA1Clear( Context );
  end;
end;

procedure UpdateSHA1( var Context : TSHA1Context; const Buf; BufSize: Longint );
var
  PBuf: ^Byte;
begin
  with Context do begin
    SHA1UpdateLen( Context, BufSize );
    PBuf := @Buf;
    while BufSize > 0 do begin
      if ( Sizeof( sdBuf ) - sdIndex ) <= DWord( BufSize ) then begin
        Move( PBuf^, sdBuf[ sdIndex ], Sizeof( sdBuf ) - sdIndex );
        Dec( BufSize, Sizeof( sdBuf ) - sdIndex );
        Inc( PBuf, Sizeof( sdBuf ) - sdIndex );
        SHA1Hash( Context );
      end else begin
        Move( PBuf^, sdBuf[ sdIndex ], BufSize );
        Inc( sdIndex, BufSize );
        BufSize := 0;
      end;
    end;
  end;
end;

procedure InitSHA1( var Context : TSHA1Context );
begin
  SHA1Clear( Context );
  Context.sdHash[ 0 ] := SHA1_A;
  Context.sdHash[ 1 ] := SHA1_B;
  Context.sdHash[ 2 ] := SHA1_C;
  Context.sdHash[ 3 ] := SHA1_D;
  Context.sdHash[ 4 ] := SHA1_E;
end;

procedure SHA1UpdateLen( var Context : TSHA1Context; Len : DWord );
begin
  Inc( Context.sdLo,( Len shl 3 ));
  if Context.sdLo < ( Len shl 3 ) then begin
    Inc( Context.sdHi );
  end;
  Inc( Context.sdHi, Len shr 29 );
end;

procedure SHA1Hash( var Context : TSHA1Context );
var
  A : DWord;
  B : DWord;
  C : DWord;
  D : DWord;
  E : DWord;

  X : DWord;
  W : array[ 0..79 ] of DWord;

  i : Longint;
begin
  with Context do begin
    sdIndex:= 0;
    Move( sdBuf, W, Sizeof( W ));
    for i := 0 to 15 do begin
      W[ i ]:= SHA1SwapByteOrder( W[ i ] );
    end;
    for i:= 16 to 79 do begin
      W[i]:= RolX( W[ i - 3 ] xor W[ i - 8 ] xor W[ i - 14 ] xor W[ i - 16 ], 1 );
    end;
    A := sdHash[ 0 ];
    B := sdHash[ 1 ];
    C := sdHash[ 2 ];
    D := sdHash[ 3 ];
    E := sdHash[ 4 ];

    for i:= 0 to 19 do begin
      X := RolX( A, 5 ) + ( D xor ( B and ( C xor D ))) + E + W[ i ] + SHA1_K1;
      E := D;
      D := C;
      C := RolX( B, 30 );
      B := A;
      A := X;
    end;

    for i:= 20 to 39 do begin
      X := RolX( A, 5 ) + ( B xor C xor D ) + E + W[ i ] + SHA1_K2;
      E := D;
      D := C;
      C := RolX( B, 30 );
      B := A;
      A := X;
    end;

    for i:= 40 to 59 do begin
      X := RolX( A, 5 ) + (( B and C ) or ( D and ( B or C ))) + E + W[ i ] + SHA1_K3;
      E := D;
      D := C;
      C := RolX( B, 30 );
      B := A;
      A := X;
    end;

    for i:= 60 to 79 do
    begin
      X := RolX( A, 5 ) + ( B xor C xor D ) + E + W[ i ] + SHA1_K4;
      E := D;
      D := C;
      C := RolX( B, 30 );
      B := A;
      A := X;
    end;

    sdHash[ 0 ]:= sdHash[ 0 ] + A;
    sdHash[ 1 ]:= sdHash[ 1 ] + B;
    sdHash[ 2 ]:= sdHash[ 2 ] + C;
    sdHash[ 3 ]:= sdHash[ 3 ] + D;
    sdHash[ 4 ]:= sdHash[ 4 ] + E;

    FillChar( W, Sizeof( W ), $00 );
    FillChar( sdBuf, Sizeof( sdBuf ), $00 );
  end;
end;

{$IFDEF UNICODE}
procedure StringHashSHA1W(var Digest : TSHA1Digest; const Str : UnicodeString);
begin
  HashSHA1(Digest, Str[1], Length(Str) * SizeOf(WideChar));
end;
{$ENDIF}

function SHA1SwapByteOrder( n : DWORD ) : DWORD;
begin
  n := ( n shr 24 ) or (( n shr 8 ) and LBMASK_LO ) or (( n shl 8 ) and LBMASK_HI ) or ( n shl 24 );
  Result := n;
end;

procedure SHA1Clear( var Context : TSHA1Context );
begin
  fillchar( Context, SizeOf( Context ), $00 );
end;

procedure StringHashLMDA(var Digest; DigestSize : LongInt; const Str : AnsiString);
begin
  HashLMD(Digest, DigestSize, Str[1], Length(Str) * SizeOf(AnsiChar));
end;

{$IFDEF UNICODE}
procedure StringHashLMDW(var Digest; DigestSize : LongInt; const Str : UnicodeString);
begin
  HashLMD(Digest, DigestSize, Str[1], Length(Str) * SizeOf(WideChar));
end;
{$ENDIF}

procedure StringHashMD5A(var Digest : TMD5Digest; const Str : AnsiString);
begin
  HashMD5(Digest, Str[1], Length(Str) * SizeOf(AnsiChar));
end;

{$IFDEF UNICODE}
procedure StringHashMD5W(var Digest : TMD5Digest; const Str : UnicodeString);
begin
  HashMD5(Digest, Str[1], Length(Str) * SizeOf(WideChar));
end;
{$ENDIF}

procedure StringHashMix128A(var Digest : LongInt; const Str : AnsiString);
begin
  HashMix128(Digest, Str[1], Length(Str) * SizeOf(AnsiChar));
end;

{$IFDEF UNICODE}
procedure StringHashMix128W(var Digest : LongInt; const Str : Unicodestring);
begin
  HashMix128(Digest, Str[1], Length(Str) * SizeOf(WideChar));
end;
{$ENDIF}

procedure HashMix128(var Digest : LongInt; const Buf;  BufSize : LongInt);
type
  T128BitArray = array[0..0] of T128Bit;
var
  Temp      : T128Bit;
  PTemp     : PByteArray;
  I, L   : LongInt;
begin
  Temp[0] := $243F6A88;
  Temp[1] := $93F40317;
  Temp[2] := $0C110496;
  Temp[3] := $C709C289;

  L := BufSize div SizeOf(T128Bit);
  for I := 0 to L - 1 do begin
    Temp[0] := Temp[0] + T128BitArray(Buf)[I][0];
    Temp[1] := Temp[1] + T128BitArray(Buf)[I][1];
    Temp[2] := Temp[2] + T128BitArray(Buf)[I][2];
    Temp[3] := Temp[3] + T128BitArray(Buf)[I][3];
    Mix128(Temp);
  end;

  PTemp := @Temp;
  if (BufSize > L * SizeOf(T128Bit)) then begin
    for I := 0 to (BufSize - L * SizeOf(T128Bit)) - 1 do
      PTemp^[I] := PTemp^[I] + TByteArray(Buf)[(L * SizeOf(T128Bit)) + I];
    Mix128(Temp);
  end;

  Digest := Temp[3];
end;

procedure StringHashELFA(var Digest : LongInt; const Str : AnsiString);
begin
  HashELF(Digest, Str[1], Length(Str) * SizeOf(AnsiChar));
end;

{$IFDEF UNICODE}
procedure StringHashELFW(var Digest : LongInt; const Str : UnicodeString);
begin
  HashELF(Digest, Str[1], Length(Str) * SizeOf(WideChar));
end;
{$ENDIF}

procedure HashELF(var Digest : LongInt; const Buf;  BufSize : LongInt);
var
  I, X  : LongInt;
begin
  Digest := 0;
  for I := 0 to BufSize - 1 do begin
    Digest := (Digest shl 4) + TByteArray(Buf)[I];
    X := Digest and $F0000000;
    if (X <> 0) then
      Digest := Digest xor (X shr 24);
    Digest := Digest and (not X);
  end;
end;

procedure Mix128(var X : T128Bit);
var
  AA, BB, CC, DD : LongInt;
begin
  AA := X[0];  BB := X[1];  CC := X[2];  DD := X[3];

  AA := AA + DD;  DD := DD + AA;  AA := AA xor (AA shr 7);
  BB := BB + AA;  AA := AA + BB;  BB := BB xor (BB shl 13);
  CC := CC + BB;  BB := BB + CC;  CC := CC xor (CC shr 17);
  DD := DD + CC;  CC := CC + DD;  DD := DD xor (DD shl 9);
  AA := AA + DD;  DD := DD + AA;  AA := AA xor (AA shr 3);
  BB := BB + AA;  AA := AA + BB;  BB := BB xor (BB shl 7);
  CC := CC + BB;  BB := BB + CC;  CC := CC xor (DD shr 15);
  DD := DD + CC;  CC := CC + DD;  DD := DD xor (DD shl 11);

  X[0] := AA;  X[1] := BB;  X[2] := CC;  X[3] := DD;
end;

procedure  ShrinkDESKey(var Key : TKey64);
const
  SK1 : TKey64 = ($C4,$08,$B0,$54,$0B,$A1,$E0,$AE);
  SK2 : TKey64 = ($EF,$2C,$04,$1C,$E6,$38,$2F,$E6);
var
  I       : Integer;
  Work1   : TKey64;
  Work2   : TKey64;
  Context : TDESContext;
begin
  for I := 0 to 7 do begin
    Work1[I] := Key[I] and $FE;
  end;
  InitEncryptDES(SK1, Context, True);
  Work2 := Work1;
  EncryptDES(Context, TDESBlock(Work2));
  for I := 0 to 7 do begin
    Work1[I] := Work1[I] xor Work2[I];
  end;
  TInt64(Work1).Lo := TInt64(Work1).Lo and $F101F101;
  TInt64(Work1).Hi := TInt64(Work1).Hi and $F101F101;
  InitEncryptDES(SK2, Context, True);
  EncryptDES(Context, TDESBlock(Work1));
  Key := Work1;
end;

{$IFDEF UNICODE}
procedure GenerateMD5KeyW(var Key : TKey128; const Str : UnicodeString);
var
  D : TMD5Digest;
begin
  HashMD5(D, Str[1], Length(Str) * SizeOf(WideChar));
  Key := TKey128(D);
end;
{$ENDIF}

procedure GenerateMD5Key(var Key : TKey128; const Str : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF});
begin
  {$IFDEF LOCKBOXUNICODE}
  GenerateMD5KeyW(Key, Str);
  {$ELSE}
  GenerateMD5KeyA(Key, Str);
  {$ENDIF}
end;

procedure GenerateMD5KeyA(var Key : TKey128; const Str : AnsiString);
var
  D : TMD5Digest;
begin
  HashMD5(D, Str[1], Length(Str) * SizeOf(AnsiChar));
  Key := TKey128(D);
end;

procedure HashMD5(var Digest : TMD5Digest; const Buf;  BufSize : LongInt);
var
  Context : TMD5Context;
begin
  fillchar( context, SizeOf( context ), $00 );
  InitMD5(Context);
  UpdateMD5(Context, Buf, BufSize);
  FinalizeMD5(Context, Digest);
end;

procedure FinalizeMD5(var Context : TMD5Context; var Digest : TMD5Digest);
const
  Padding: array [0..63] of Byte = (
    $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00,
    $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00,
    $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00,
    $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00);
var
  MD5    : TMD5ContextEx;
  InBuf  : array [0..15] of DWord;
  MDI    : LongInt;
  I      : Word;
  II     : Word;
  PadLen : Word;
begin
  Move(Context, MD5, SizeOf(MD5));
  InBuf[14] := MD5.Count[0];
  InBuf[15] := MD5.Count[1];
  MDI := (MD5.Count[0] shr 3) and $3F;
  if (MDI < 56) then
    PadLen := 56 - MDI
  else
    PadLen := 120 - MDI;
  UpdateMD5(Context, Padding, PadLen);
  Move(Context, MD5, SizeOf(MD5));
  II := 0;
  for I := 0 to 13 do begin
    InBuf[I] :=
      ( LongInt( MD5.Buf[ II + 3 ]) shl 24 ) or
      ( LongInt( MD5.Buf[ II + 2 ]) shl 16 ) or
      ( LongInt( MD5.Buf[ II + 1 ]) shl 8  ) or
        LongInt( MD5.Buf[ II     ]);
    Inc(II, 4);
  end;
  Transform(MD5.State, InBuf);
  II := 0;
  for I := 0 to 3 do begin
    Digest[II] := Byte(MD5.State[I] and $FF);
    Digest[II + 1] := Byte((MD5.State[I] shr 8) and $FF);
    Digest[II + 2] := Byte((MD5.State[I] shr 16) and $FF);
    Digest[II + 3] := Byte((MD5.State[I] shr 24) and $FF);
    Inc(II, 4);
  end;
  Move(MD5, Context, SizeOf(Context));
end;

procedure UpdateMD5(var Context : TMD5Context;  const Buf;  BufSize : LongInt);
var
  MD5    : TMD5ContextEx;
  InBuf  : array [0..15] of DWord;
  BufOfs : LongInt;
  MDI    : Word;
  I      : Word;
  II     : Word;
begin
  Move(Context, MD5, SizeOf(MD5));
  MDI := (MD5.Count[0] shr 3) and $3F;
  if ((MD5.Count[0] + (DWord(BufSize) shl 3)) < MD5.Count[0]) then
    Inc(MD5.Count[1]);
  Inc(MD5.Count[0], BufSize shl 3);
  Inc(MD5.Count[1], BufSize shr 29);
  BufOfs := 0;
  while (BufSize > 0) do begin
    Dec(BufSize);
    MD5.Buf[MDI] := TByteArray(Buf)[BufOfs];
    Inc(MDI);
    Inc(BufOfs);
    if (MDI = $40) then begin
      II := 0;
      for I := 0 to 15 do begin
        InBuf[I] := LongInt(MD5.Buf[II + 3]) shl 24 or
          LongInt(MD5.Buf[II + 2]) shl 16 or
          LongInt(MD5.Buf[II + 1]) shl 8 or
          LongInt(MD5.Buf[II]);
        Inc(II, 4);
      end;
      Transform(MD5.State, InBuf);
      Transform(TMD5ContextEx( Context ).State, InBuf);
      MDI := 0;
    end;
  end;
  Move(MD5, Context, SizeOf(Context));
end;

procedure Transform(var Buffer : array of DWord;  const InBuf : array of DWord);
const
  S11 = 7;
  S12 = 12;
  S13 = 17;
  S14 = 22;
  S21 = 5;
  S22 = 9;
  S23 = 14;
  S24 = 20;
  S31 = 4;
  S32 = 11;
  S33 = 16;
  S34 = 23;
  S41 = 6;
  S42 = 10;
  S43 = 15;
  S44 = 21;
var
  Buf : array [0..3] of DWord;
  InA : array [0..15] of DWord;
var
  A   : DWord;
  B   : DWord;
  C   : DWord;
  D   : DWord;

  procedure FF(var A : DWord;  B, C, D, X, S, AC : DWord);
  begin
    A := RolX(A + ((B and C) or (not B and D)) + X + AC, S) + B;
  end;

  procedure GG(var A : DWord;  B, C, D, X, S, AC : DWord);
  begin
    A := RolX(A + ((B and D) or (C and not D)) + X + AC, S) + B;
  end;

  procedure HH(var A : DWord;  B, C, D, X, S, AC : DWord);
  begin
    A := RolX(A + (B xor C xor D) + X + AC, S) + B;
  end;

  procedure II(var A : DWord;  B, C, D, X, S, AC : DWord);
  begin
    A := RolX(A + (C xor (B or not D)) + X + AC, S) + B;
  end;

begin
  Move(Buffer, Buf, SizeOf(Buf));
  Move(InBuf, InA, SizeOf(InA));
  A := Buf [0];
  B := Buf [1];
  C := Buf [2];
  D := Buf [3];

  {round 1}
  FF(A, B, C, D, InA [ 0], S11, $D76AA478);  { 1 }
  FF(D, A, B, C, InA [ 1], S12, $E8C7B756);  { 2 }
  FF(C, D, A, B, InA [ 2], S13, $242070DB);  { 3 }
  FF(B, C, D, A, InA [ 3], S14, $C1BDCEEE);  { 4 }
  FF(A, B, C, D, InA [ 4], S11, $F57C0FAF);  { 5 }
  FF(D, A, B, C, InA [ 5], S12, $4787C62A);  { 6 }
  FF(C, D, A, B, InA [ 6], S13, $A8304613);  { 7 }
  FF(B, C, D, A, InA [ 7], S14, $FD469501);  { 8 }
  FF(A, B, C, D, InA [ 8], S11, $698098D8);  { 9 }
  FF(D, A, B, C, InA [ 9], S12, $8B44F7AF);  { 10 }
  FF(C, D, A, B, InA [10], S13, $FFFF5BB1);  { 11 }
  FF(B, C, D, A, InA [11], S14, $895CD7BE);  { 12 }
  FF(A, B, C, D, InA [12], S11, $6B901122);  { 13 }
  FF(D, A, B, C, InA [13], S12, $FD987193);  { 14 }
  FF(C, D, A, B, InA [14], S13, $A679438E);  { 15 }
  FF(B, C, D, A, InA [15], S14, $49B40821);  { 16 }

  {round 2}
  GG(A, B, C, D, InA [ 1], S21, $F61E2562);  { 17 }
  GG(D, A, B, C, InA [ 6], S22, $C040B340);  { 18 }
  GG(C, D, A, B, InA [11], S23, $265E5A51);  { 19 }
  GG(B, C, D, A, InA [ 0], S24, $E9B6C7AA);  { 20 }
  GG(A, B, C, D, InA [ 5], S21, $D62F105D);  { 21 }
  GG(D, A, B, C, InA [10], S22, $02441453);  { 22 }
  GG(C, D, A, B, InA [15], S23, $D8A1E681);  { 23 }
  GG(B, C, D, A, InA [ 4], S24, $E7D3FBC8);  { 24 }
  GG(A, B, C, D, InA [ 9], S21, $21E1CDE6);  { 25 }
  GG(D, A, B, C, InA [14], S22, $C33707D6);  { 26 }
  GG(C, D, A, B, InA [ 3], S23, $F4D50D87);  { 27 }
  GG(B, C, D, A, InA [ 8], S24, $455A14ED);  { 28 }
  GG(A, B, C, D, InA [13], S21, $A9E3E905);  { 29 }
  GG(D, A, B, C, InA [ 2], S22, $FCEFA3F8);  { 30 }
  GG(C, D, A, B, InA [ 7], S23, $676F02D9);  { 31 }
  GG(B, C, D, A, InA [12], S24, $8D2A4C8A);  { 32 }

  {round 3}
  HH(A, B, C, D, InA [ 5], S31, $FFFA3942);  { 33 }
  HH(D, A, B, C, InA [ 8], S32, $8771F681);  { 34 }
  HH(C, D, A, B, InA [11], S33, $6D9D6122);  { 35 }
  HH(B, C, D, A, InA [14], S34, $FDE5380C);  { 36 }
  HH(A, B, C, D, InA [ 1], S31, $A4BEEA44);  { 37 }
  HH(D, A, B, C, InA [ 4], S32, $4BDECFA9);  { 38 }
  HH(C, D, A, B, InA [ 7], S33, $F6BB4B60);  { 39 }
  HH(B, C, D, A, InA [10], S34, $BEBFBC70);  { 40 }
  HH(A, B, C, D, InA [13], S31, $289B7EC6);  { 41 }
  HH(D, A, B, C, InA [ 0], S32, $EAA127FA);  { 42 }
  HH(C, D, A, B, InA [ 3], S33, $D4EF3085);  { 43 }
  HH(B, C, D, A, InA [ 6], S34,  $4881D05);  { 44 }
  HH(A, B, C, D, InA [ 9], S31, $D9D4D039);  { 45 }
  HH(D, A, B, C, InA [12], S32, $E6DB99E5);  { 46 }
  HH(C, D, A, B, InA [15], S33, $1FA27CF8);  { 47 }
  HH(B, C, D, A, InA [ 2], S34, $C4AC5665);  { 48 }

  {round 4}
  II(A, B, C, D, InA [ 0], S41, $F4292244);  { 49 }
  II(D, A, B, C, InA [ 7], S42, $432AFF97);  { 50 }
  II(C, D, A, B, InA [14], S43, $AB9423A7);  { 51 }
  II(B, C, D, A, InA [ 5], S44, $FC93A039);  { 52 }
  II(A, B, C, D, InA [12], S41, $655B59C3);  { 53 }
  II(D, A, B, C, InA [ 3], S42, $8F0CCC92);  { 54 }
  II(C, D, A, B, InA [10], S43, $FFEFF47D);  { 55 }
  II(B, C, D, A, InA [ 1], S44, $85845DD1);  { 56 }
  II(A, B, C, D, InA [ 8], S41, $6FA87E4F);  { 57 }
  II(D, A, B, C, InA [15], S42, $FE2CE6E0);  { 58 }
  II(C, D, A, B, InA [ 6], S43, $A3014314);  { 59 }
  II(B, C, D, A, InA [13], S44, $4E0811A1);  { 60 }
  II(A, B, C, D, InA [ 4], S41, $F7537E82);  { 61 }
  II(D, A, B, C, InA [11], S42, $BD3AF235);  { 62 }
  II(C, D, A, B, InA [ 2], S43, $2AD7D2BB);  { 63 }
  II(B, C, D, A, InA [ 9], S44, $EB86D391);  { 64 }

  Inc(Buf [0], A);
  Inc(Buf [1], B);
  Inc(Buf [2], C);
  Inc(Buf [3], D);

  Move(Buf, Buffer, SizeOf(Buffer));
end;

function RolX(I, C : DWord): DWord;
begin
   Result := (I shl (C and 31)) or (I shr (32-(C and 31)));
end;

procedure InitMD5(var Context : TMD5Context);
var
  MD5 : TMD5ContextEx;
begin
  Move(Context, MD5, SizeOf(MD5));
  MD5.Count[0] := 0;
  MD5.Count[1] := 0;
  MD5.State[0] := $67452301;
  MD5.State[1] := $EFCDAB89;
  MD5.State[2] := $98BADCFE;
  MD5.State[3] := $10325476;
  Move(MD5, Context, SizeOf(Context));
end;

{$IFDEF UNICODE}
procedure GenerateLMDKeyW(var Key; KeySize : Integer; const Str : UnicodeString);
begin
  HashLMD(Key, KeySize, Str[1], Length(Str) * SizeOf(WideChar));
end;
{$ENDIF}

procedure GenerateLMDKey(var Key; KeySize : Integer; const Str : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF});
begin
  {$IFDEF LOCKBOXUNICODE}
  GenerateLMDKeyW(Key, KeySize, Str);
  {$ELSE}
  GenerateLMDKeyA(Key, KeySize, Str);
  {$ENDIF}
end;

procedure GenerateLMDKeyA(var Key; KeySize : Integer; const Str : Ansistring);
begin
  HashLMD(Key, KeySize, Str[1], Length(Str) * SizeOf(AnsiChar));
end;

procedure HashLMD(var Digest; DigestSize : LongInt; const Buf; BufSize : LongInt);
var
  Context : TLMDContext;
begin
  InitLMD(Context);
  UpdateLMD(Context, Buf, BufSize);
  FinalizeLMD(Context, Digest, DigestSize);
end;

procedure FinalizeLMD(var Context : TLMDContext; var Digest; DigestSize : LongInt);
const
  Padding : array [0..7] of Byte = (1, 0, 0, 0, 0, 0, 0, 0);
var
  ContextEx : TLMDContextEx;
  BCContext : TLBCContext;
  I         : Integer;
begin
  Move(Context, ContextEx, SizeOf(ContextEx));
  UpdateLMD(Context, Padding, SizeOf(Padding) - ContextEx.KeyIndex);
  Move(Context, ContextEx, SizeOf(ContextEx));
  InitEncryptLBC(ContextEx.Key, BCContext, 8, True);
  for I := 0 to (SizeOf(ContextEx.Digest) div SizeOf(TLBCBlock)) - 1 do begin
    EncryptLBC(BCContext, PLBCBlock(@ContextEx.Digest[I * SizeOf(TLBCBlock)])^);
  end;
  Move(ContextEx.Digest, Digest, Min(SizeOf(ContextEx.Digest), DigestSize));
end;

procedure UpdateLMD(var Context : TLMDContext; const Buf; BufSize : LongInt);
var
  ContextEx : TLMDContextEx;
  AA, BB    : LongInt;
  CC, DD    : LongInt;
  I, R      : LongInt;
begin
  Move(Context, ContextEx, SizeOf(ContextEx));
  for I := 0 to BufSize - 1 do begin
    with ContextEx do begin
      Digest[DigestIndex] := Digest[DigestIndex] xor TByteArray(Buf)[I];
      DigestIndex := DigestIndex + 1;
      if (DigestIndex = SizeOf(Digest)) then begin
        DigestIndex := 0;
      end;
      Key[KeyIndex] := Key[KeyIndex] xor TByteArray(Buf)[I];
      KeyIndex := KeyIndex + 1;
      if (KeyIndex = SizeOf(Key) div 2) then begin
        AA := KeyInts[3];
        BB := KeyInts[2];
        CC := KeyInts[1];
        DD := KeyInts[0];
        for R := 0 to 3 do begin
          AA := AA + DD; DD := DD + AA; AA := AA xor (AA shr 7);
          BB := BB + AA; AA := AA + BB; BB := BB xor (BB shl 13);
          CC := CC + BB; BB := BB + CC; CC := CC xor (CC shr 17);
          DD := DD + CC; CC := CC + DD; DD := DD xor (DD shl 9);
          AA := AA + DD; DD := DD + AA; AA := AA xor (AA shr 3);
          BB := BB + AA; AA := AA + BB; BB := BB xor (BB shl 7);
          CC := CC + BB; BB := BB + CC; CC := CC xor (DD shr 15);
          DD := DD + CC; CC := CC + DD; DD := DD xor (DD shl 11);
        end;
        KeyInts[0] := AA;
        KeyInts[1] := BB;
        KeyInts[2] := CC;
        KeyInts[3] := DD;
        KeyIndex := 0;
      end;
    end;
  end;
  Move(ContextEx, Context, SizeOf(Context));
end;

procedure InitLMD(var Context : TLMDContext);
var
  ContextEx : TLMDContextEx;
begin
  Move(Context, ContextEx, SizeOf(ContextEx));
  ContextEx.DigestIndex := 0;
  TBlock2048(ContextEx.Digest) := TBlock2048(Pi2048);

  ContextEx.KeyIndex := 0;
  ContextEx.KeyInts[0] := $55555555;
  ContextEx.KeyInts[1] := $55555555;
  ContextEx.KeyInts[2] := $55555555;
  ContextEx.KeyInts[3] := $55555555;
  Move(ContextEx, Context, SizeOf(Context));
end;


procedure GenerateRandomKey(var Key; KeySize : Integer);
var
  I     : Integer;
begin
  Randomize;
  for I := 0 to KeySize - 1 do begin
    TByteArray(Key)[I] := System.Random(256);
  end;
end;

procedure EncryptRNG64(var Context : TRNG64Context; var Buf; BufSize : LongInt);
var
  I : Integer;
begin
  for I := 0 to BufSize - 1 do begin
    TByteArray(Buf)[I] := TByteArray(Buf)[I] xor Random64Byte(TInt64(Context));
  end;
end;

procedure InitEncryptRNG64(KeyHi, KeyLo : LongInt; var Context : TRNG64Context);
begin
  TInt64(Context).Lo := KeyLo;
  TInt64(Context).Hi := KeyHi;
end;

procedure EncryptRNG32(var Context : TRNG32Context; var Buf; BufSize : LongInt);
var
  I     : LongInt;
begin
  for I := 0 to BufSize - 1 do begin
    TByteArray(Buf)[I] := TByteArray(Buf)[I] xor Random32Byte(LongInt(Context));
  end;
end;

procedure InitEncryptRNG32(Key : LongInt; var Context : TRNG32Context);
begin
  LongInt(Context) := Key;
end;

procedure EncryptLSC(var Context : TLSCContext; var Buf; BufSize : LongInt);
var
  L, Y, X   : LongInt;
  I, A      : LongInt;
begin
  I := Context.Index;
  A := Context.Accumulator;
  for L := 0 to BufSize - 1 do begin
    I := I + 1;
    X := Context.SBox[Byte(I)];
    Y := Context.SBox[Byte(X)] + X;
    Context.SBox[Byte(I)] := Context.SBox[Byte(Y)];
    Context.SBox[Byte(Y)] := X;
    A := A + Context.SBox[Byte(Byte(Y shr 8) + Byte(Y))];
    TByteArray(Buf)[L] := TByteArray(Buf)[L] xor Byte(A);
  end;
  Context.Index := I;
  Context.Accumulator := A;
end;

procedure InitEncryptLSC(const Key; KeySize : Integer; var Context : TLSCContext);
var
  R, I, A   : LongInt;
  X         : Byte;
begin
  for I := 0 to 255 do begin
    Context.SBox[I] := I;
  end;
  A := 0;
  for R := 0 to 2 do begin
    for I := 0 to 255 do begin
      A := A + Context.SBox[I] + TByteArray(Key)[I mod KeySize];
      X := Context.SBox[I];
      Context.SBox[I] := Context.SBox[Byte(A)];
      Context.SBox[Byte(A)] := X;
    end;
  end;
  Context.Index := 0;
  Context.Accumulator := A;
end;

procedure EncryptBFCBC(const Context : TBFContext; const Prev : TBFBlock; var Block : TBFBlock; Encrypt : Boolean);
begin
  if Encrypt then begin
    XorMem(Block, Prev, SizeOf(Block));
    EncryptBF(Context, Block, Encrypt);
  end else begin
    EncryptBF(Context, Block, Encrypt);
    XorMem(Block, Prev, SizeOf(Block));
  end;
end;

procedure InitEncryptBF(Key : TKey128; var Context : TBFContext);
var
  I     : Integer;
  J     : Integer;
  K     : Integer;
  Data  : LongInt;
  Block : TBFBlock;
begin
  Move(bf_P, Context.PBox, SizeOf(Context.PBox));
  Move(bf_S, Context.SBox, SizeOf(Context.SBox));
  J := 0;
  for I := 0 to (BFRounds+1) do begin
    Data := 0;
    for K := 0 to 3 do begin
      Data := (Data shl 8) or Key[J];
      Inc(J);
      if J >= SizeOf(Key) then begin
        J := 0;
      end;
    end;
    Context.PBox[I] := Context.PBox[I] xor Data;
  end;
  Block[0] := 0;
  Block[1] := 0;
  I := 0;
  repeat
    EncryptBF(Context, Block, True);
    Context.PBox[I] := Block[0];
    Context.PBox[I+1] := Block[1];
    Inc(I, 2);
  until I > BFRounds+1;
  for J := 0 to 3 do begin
    I := 0;
    repeat
      EncryptBF(Context, Block, True);
      Context.SBox[J, I] := Block[0];
      Context.SBox[J, I+1] := Block[1];
      Inc(I, 2);
    until I > 255;
  end;
end;

procedure EncryptBF(const Context : TBFContext; var Block : TBFBlock; Encrypt : Boolean);
var
  I : Integer;
  TmpBlock : TBFBlockEx;
begin
  Move(Block, TmpBlock, SizeOf(TmpBlock));
  if Encrypt then begin
    Block[0] := Block[0] xor Context.PBox[0];
    I := 1;
    repeat
      Block[1] := Block[1] xor Context.PBox[I] xor ((( Context.SBox[0, TmpBlock.Xl[3]] + Context.SBox[1, TmpBlock.Xl[2]]) xor Context.SBox[2, TmpBlock.Xl[1]]) + Context.SBox[3, TmpBlock.Xl[0]]);
      Block[0] := Block[0] xor Context.PBox[I+1] xor (((Context.SBox[0, TmpBlock.Xr[3]] + Context.SBox[1, TmpBlock.Xr[2]]) xor Context.SBox[2, TmpBlock.Xr[1]]) + Context.SBox[3, TmpBlock.Xr[0]]);
      Inc(I, 2);
    until I > BFRounds;
    Block[1] := Block[1] xor Context.PBox[(BFRounds+1)];
  end else begin
    Block[1] := Block[1] xor Context.PBox[(BFRounds+1)];
    I := BFRounds;
    repeat
      Block[0] := Block[0] xor Context.PBox[I] xor (((Context.SBox[0, TmpBlock.Xr[3]] + Context.SBox[1, TmpBlock.Xr[2]]) xor Context.SBox[2, TmpBlock.Xr[1]]) + Context.SBox[3, TmpBlock.Xr[0]]);
      Block[1] := Block[1] xor Context.PBox[i-1] xor (((Context.SBox[0, TmpBlock.Xl[3]] + Context.SBox[1, TmpBlock.Xl[2]]) xor Context.SBox[2, TmpBlock.Xl[1]]) + Context.SBox[3, TmpBlock.Xl[0]]);
       Dec (I, 2);
     until I < 1;
     Block[0] := Block[0] xor Context.PBox[0];
  end;
end;

procedure EncryptLQCCBC(const Key : TKey128; const Prev : TLQCBlock; var Block : TLQCBlock; Encrypt : Boolean);
begin
  if Encrypt then begin
    XorMem(Block, Prev, SizeOf(Block));
    EncryptLQC(Key, Block, Encrypt);
  end else begin
    EncryptLQC(Key, Block, Encrypt);
    XorMem(Block, Prev, SizeOf(Block));
  end;
end;

procedure EncryptLQC(const Key : TKey128; var Block : TLQCBlock; Encrypt : Boolean);
const
  CKeyBox : array [False..True, 0..3, 0..2] of LongInt =
    (((0, 3, 1), (2, 1, 3), (1, 0, 2), (3, 2, 0)),
     ((3, 2, 0), (1, 0, 2), (2, 1, 3), (0, 3, 1)));
var
  KeyInts : array [0..3] of Longint;
  Blocks  : array [0..1] of Longint;
  Work    : LongInt;
  Right   : LongInt;
  Left    : LongInt;
  R       : LongInt;
  AA, BB  : LongInt;
  CC, DD  : LongInt;
begin
  Move(Key, KeyInts, SizeOf(KeyInts));
  Move(Block, Blocks, SizeOf(Blocks));
  Right := Blocks[0];
  Left := Blocks[1];

  for R := 0 to 3 do begin
    AA := Right;
    BB := KeyInts[CKeyBox[Encrypt, R, 0]];
    CC := KeyInts[CKeyBox[Encrypt, R, 1]];
    DD := KeyInts[CKeyBox[Encrypt, R, 2]];
    AA := AA + DD; DD := DD + AA; AA := AA xor (AA shr 7);
    BB := BB + AA; AA := AA + BB; BB := BB xor (BB shl 13);
    CC := CC + BB; BB := BB + CC; CC := CC xor (CC shr 17);
    DD := DD + CC; CC := CC + DD; DD := DD xor (DD shl 9);
    AA := AA + DD; DD := DD + AA; AA := AA xor (AA shr 3);
    BB := BB + AA; {AA := AA + BB;}  BB := BB xor (BB shl 7);
    CC := CC + BB; {BB := BB + CC;}  CC := CC xor (DD shr 15);
    DD := DD + CC; {CC := CC + DD;}  DD := DD xor (DD shl 11);

    Work := Left xor DD;
    Left := Right;
    Right := Work;
  end;

  Blocks[0] := Left;
  Blocks[1] := Right;
  Move(Blocks, Block, SizeOf(Block));
end;

procedure EncryptTripleDESCBC3Key(const Context : TTripleDESContext3Key; const Prev : TDESBlock; var Block : TDESBlock);
begin
  if Context[0].Encrypt then begin
    XorMem(Block, Prev, SizeOf(Block));
    EncryptDES(Context[0], Block);
    EncryptDES(Context[1], Block);
    EncryptDES(Context[2], Block);
  end else begin
    EncryptDES(Context[0], Block);
    EncryptDES(Context[1], Block);
    EncryptDES(Context[2], Block);
    XorMem(Block, Prev, SizeOf(Block));
  end;
end;


procedure EncryptTripleDES3Key(const Context : TTripleDESContext3Key; var Block : TDESBlock);
begin
  EncryptDES(Context[2], Block);
  EncryptDES(Context[1], Block);
  EncryptDES(Context[0], Block);
end;

procedure InitEncryptTripleDES3Key(const Key1, Key2, Key3 : TKey64; var Context : TTripleDESContext3Key; Encrypt : Boolean);
begin
  if Encrypt then begin
    InitEncryptDES(Key1, Context[0], True);
    InitEncryptDES(Key2, Context[1], False);
    InitEncryptDES(Key3, Context[2], True);
  end else begin
    InitEncryptDES(Key1, Context[2], False);
    InitEncryptDES(Key2, Context[1], True);
    InitEncryptDES(Key3, Context[0], False);
  end;
end;

procedure EncryptTripleDESCBC(const Context : TTripleDESContext;  const Prev : TDESBlock; var Block : TDESBlock);
begin
  if Context[0].Encrypt then begin
    XorMem(Block, Prev, SizeOf(Block));
    EncryptDES(Context[0], Block);
    EncryptDES(Context[1], Block);
    EncryptDES(Context[0], Block);
  end else begin
    EncryptDES(Context[0], Block);
    EncryptDES(Context[1], Block);
    EncryptDES(Context[0], Block);
    XorMem(Block, Prev, SizeOf(Block));
  end;
end;

procedure EncryptTripleDES(const Context : TTripleDESContext;  var Block : TDESBlock);
begin
  EncryptDES(Context[0], Block);
  EncryptDES(Context[1], Block);
  EncryptDES(Context[0], Block);
end;

procedure InitEncryptTripleDES(const Key : TKey128;  var Context : TTripleDESContext; Encrypt : Boolean);
var
  KeyArray : array [0..1] of TKey64;
begin
  Move(Key, KeyArray, SizeOf(KeyArray));
  if Encrypt then begin
    InitEncryptDES(KeyArray[0], Context[0], True);
    InitEncryptDES(KeyArray[1], Context[1], False);
  end else begin
    InitEncryptDES(KeyArray[0], Context[0], False);
    InitEncryptDES(KeyArray[1], Context[1], True);
  end;
end;

procedure EncryptDESCBC(const Context : TDESContext;  const Prev : TDESBlock;  var Block : TDESBlock);
begin
  if Context.Encrypt then begin
    XorMem(Block, Prev, SizeOf(Block));
    EncryptDES(Context, Block);
  end else begin
    EncryptDES(Context, Block);
    XorMem(Block, Prev, SizeOf(Block));
  end;
end;

procedure EncryptDES(const Context : TDESContext;  var Block : TDESBlock);
const
  SPBox : array [0..7, 0..63] of DWord =
    (($01010400, $00000000, $00010000, $01010404, $01010004, $00010404, $00000004, $00010000,
      $00000400, $01010400, $01010404, $00000400, $01000404, $01010004, $01000000, $00000004,
      $00000404, $01000400, $01000400, $00010400, $00010400, $01010000, $01010000, $01000404,
      $00010004, $01000004, $01000004, $00010004, $00000000, $00000404, $00010404, $01000000,
      $00010000, $01010404, $00000004, $01010000, $01010400, $01000000, $01000000, $00000400,
      $01010004, $00010000, $00010400, $01000004, $00000400, $00000004, $01000404, $00010404,
      $01010404, $00010004, $01010000, $01000404, $01000004, $00000404, $00010404, $01010400,
      $00000404, $01000400, $01000400, $00000000, $00010004, $00010400, $00000000, $01010004),
     ($80108020, $80008000, $00008000, $00108020, $00100000, $00000020, $80100020, $80008020,
      $80000020, $80108020, $80108000, $80000000, $80008000, $00100000, $00000020, $80100020,
      $00108000, $00100020, $80008020, $00000000, $80000000, $00008000, $00108020, $80100000,
      $00100020, $80000020, $00000000, $00108000, $00008020, $80108000, $80100000, $00008020,
      $00000000, $00108020, $80100020, $00100000, $80008020, $80100000, $80108000, $00008000,
      $80100000, $80008000, $00000020, $80108020, $00108020, $00000020, $00008000, $80000000,
      $00008020, $80108000, $00100000, $80000020, $00100020, $80008020, $80000020, $00100020,
      $00108000, $00000000, $80008000, $00008020, $80000000, $80100020, $80108020, $00108000),
     ($00000208, $08020200, $00000000, $08020008, $08000200, $00000000, $00020208, $08000200,
      $00020008, $08000008, $08000008, $00020000, $08020208, $00020008, $08020000, $00000208,
      $08000000, $00000008, $08020200, $00000200, $00020200, $08020000, $08020008, $00020208,
      $08000208, $00020200, $00020000, $08000208, $00000008, $08020208, $00000200, $08000000,
      $08020200, $08000000, $00020008, $00000208, $00020000, $08020200, $08000200, $00000000,
      $00000200, $00020008, $08020208, $08000200, $08000008, $00000200, $00000000, $08020008,
      $08000208, $00020000, $08000000, $08020208, $00000008, $00020208, $00020200, $08000008,
      $08020000, $08000208, $00000208, $08020000, $00020208, $00000008, $08020008, $00020200),
     ($00802001, $00002081, $00002081, $00000080, $00802080, $00800081, $00800001, $00002001,
      $00000000, $00802000, $00802000, $00802081, $00000081, $00000000, $00800080, $00800001,
      $00000001, $00002000, $00800000, $00802001, $00000080, $00800000, $00002001, $00002080,
      $00800081, $00000001, $00002080, $00800080, $00002000, $00802080, $00802081, $00000081,
      $00800080, $00800001, $00802000, $00802081, $00000081, $00000000, $00000000, $00802000,
      $00002080, $00800080, $00800081, $00000001, $00802001, $00002081, $00002081, $00000080,
      $00802081, $00000081, $00000001, $00002000, $00800001, $00002001, $00802080, $00800081,
      $00002001, $00002080, $00800000, $00802001, $00000080, $00800000, $00002000, $00802080),
     ($00000100, $02080100, $02080000, $42000100, $00080000, $00000100, $40000000, $02080000,
      $40080100, $00080000, $02000100, $40080100, $42000100, $42080000, $00080100, $40000000,
      $02000000, $40080000, $40080000, $00000000, $40000100, $42080100, $42080100, $02000100,
      $42080000, $40000100, $00000000, $42000000, $02080100, $02000000, $42000000, $00080100,
      $00080000, $42000100, $00000100, $02000000, $40000000, $02080000, $42000100, $40080100,
      $02000100, $40000000, $42080000, $02080100, $40080100, $00000100, $02000000, $42080000,
      $42080100, $00080100, $42000000, $42080100, $02080000, $00000000, $40080000, $42000000,
      $00080100, $02000100, $40000100, $00080000, $00000000, $40080000, $02080100, $40000100),
     ($20000010, $20400000, $00004000, $20404010, $20400000, $00000010, $20404010, $00400000,
      $20004000, $00404010, $00400000, $20000010, $00400010, $20004000, $20000000, $00004010,
      $00000000, $00400010, $20004010, $00004000, $00404000, $20004010, $00000010, $20400010,
      $20400010, $00000000, $00404010, $20404000, $00004010, $00404000, $20404000, $20000000,
      $20004000, $00000010, $20400010, $00404000, $20404010, $00400000, $00004010, $20000010,
      $00400000, $20004000, $20000000, $00004010, $20000010, $20404010, $00404000, $20400000,
      $00404010, $20404000, $00000000, $20400010, $00000010, $00004000, $20400000, $00404010,
      $00004000, $00400010, $20004010, $00000000, $20404000, $20000000, $00400010, $20004010),
     ($00200000, $04200002, $04000802, $00000000, $00000800, $04000802, $00200802, $04200800,
      $04200802, $00200000, $00000000, $04000002, $00000002, $04000000, $04200002, $00000802,
      $04000800, $00200802, $00200002, $04000800, $04000002, $04200000, $04200800, $00200002,
      $04200000, $00000800, $00000802, $04200802, $00200800, $00000002, $04000000, $00200800,
      $04000000, $00200800, $00200000, $04000802, $04000802, $04200002, $04200002, $00000002,
      $00200002, $04000000, $04000800, $00200000, $04200800, $00000802, $00200802, $04200800,
      $00000802, $04000002, $04200802, $04200000, $00200800, $00000000, $00000002, $04200802,
      $00000000, $00200802, $04200000, $00000800, $04000002, $04000800, $00000800, $00200002),
     ($10001040, $00001000, $00040000, $10041040, $10000000, $10001040, $00000040, $10000000,
      $00040040, $10040000, $10041040, $00041000, $10041000, $00041040, $00001000, $00000040,
      $10040000, $10000040, $10001000, $00001040, $00041000, $00040040, $10040040, $10041000,
      $00001040, $00000000, $00000000, $10040040, $10000040, $10001000, $00041040, $00040000,
      $00041040, $00040000, $10041000, $00001000, $00000040, $10040040, $00001000, $00041040,
      $10001000, $00000040, $10000040, $10040000, $10040040, $10000000, $00040000, $10001040,
      $00000000, $10041040, $00040040, $10000040, $10040000, $10001000, $10001040, $00000000,
      $10041040, $00041000, $00041000, $00001040, $00001040, $00040040, $10000000, $10041000));
var
  I, L, R, Work : DWord;
  CPtr          : PDWord;

  procedure SplitBlock(const Block : TDESBlock; var L, R : DWord);
  var
   Temp: TDesConverter;
   I: integer;
  begin
    for I := Low(Block) to High(Block) do
    Temp.Bytes[7-I] := Block[I];
    L:= Temp.DWords[1];
    R:= Temp.DWords[0];
  end;


  procedure JoinBlock(const L, R : LongInt; var Block : TDESBlock);
  var
     Temp: TDesConverter;
     I: integer;
  begin
       Temp.DWords[0] := DWord(L);
       Temp.DWords[1] := DWord(R);
       for I := Low(Block) to High(Block) do
           Block[I] := Temp.Bytes[7-I];
  end;

  procedure IPerm(var L, R : DWord);
  var
    Work : DWord;
  begin
    Work := ((L shr 4) xor R) and $0F0F0F0F;
    R := R xor Work;
    L := L xor Work shl 4;

    Work := ((L shr 16) xor R) and $0000FFFF;
    R := R xor Work;
    L := L xor Work shl 16;

    Work := ((R shr 2) xor L) and $33333333;
    L := L xor Work;
    R := R xor Work shl 2;

    Work := ((R shr 8) xor L) and $00FF00FF;
    L := L xor Work;
    R := R xor Work shl 8;

    R := (R shl 1) or (R shr 31);
    Work := (L xor R) and $AAAAAAAA;
    L := L xor Work;
    R := R xor Work;
    L := (L shl 1) or (L shr 31);
  end;

  procedure FPerm(var L, R : DWord);
  var
    Work : DWord;
  begin
    L := L;

    R := (R shl 31) or (R shr 1);
    Work := (L xor R) and $AAAAAAAA;
    L := L xor Work;
    R := R xor Work;
    L := (L shr 1) or (L shl 31);

    Work := ((L shr 8) xor R) and $00FF00FF;
    R := R xor Work;
    L := L xor Work shl 8;

    Work := ((L shr 2) xor R) and $33333333;
    R := R xor Work;
    L := L xor Work shl 2;

    Work := ((R shr 16) xor L) and $0000FFFF;
    L := L xor Work;
    R := R xor Work shl 16;

    Work := ((R shr 4) xor L) and $0F0F0F0F;
    L := L xor Work;
    R := R xor Work shl 4;
  end;

begin
  SplitBlock(Block, L, R);
  IPerm(L, R);

  CPtr := @Context;
  for I := 0 to 7 do begin
    Work := (((R shr 4) or (R shl 28)) xor CPtr^);
    Inc(CPtr);
    L := L xor SPBox[6, Work and $3F];
    L := L xor SPBox[4, Work shr 8 and $3F];
    L := L xor SPBox[2, Work shr 16 and $3F];
    L := L xor SPBox[0, Work shr 24 and $3F];

    Work := (R xor CPtr^);
    Inc(CPtr);
    L := L xor SPBox[7, Work and $3F];
    L := L xor SPBox[5, Work shr 8 and $3F];
    L := L xor SPBox[3, Work shr 16 and $3F];
    L := L xor SPBox[1, Work shr 24 and $3F];

    Work := (((L shr 4) or (L shl 28)) xor CPtr^);
    Inc(CPtr);
    R := R xor SPBox[6, Work and $3F];
    R := R xor SPBox[4, Work shr 8 and $3F];
    R := R xor SPBox[2, Work shr 16 and $3F];
    R := R xor SPBox[0, Work shr 24 and $3F];

    Work := (L xor CPtr^);
    Inc(CPtr);
    R := R xor SPBox[7, Work and $3F];
    R := R xor SPBox[5, Work shr 8 and $3F];
    R := R xor SPBox[3, Work shr 16 and $3F];
    R := R xor SPBox[1, Work shr 24 and $3F];
  end;

  FPerm(L, R);
  JoinBlock(L, R, Block);
end;

procedure InitEncryptLBC(const Key : TKey128; var Context : TLBCContext; Rounds: LongInt; Encrypt : Boolean);
type
  TSubKeys = packed record
    case Byte of
      0: (SubKeys64 : array [0..15] of TKey64);
      1: (SubKeysInts : array [0..3, 0..7] of LongInt);
  end;
var
  KeyArray  : pLongIntArray;
  AA, BB    : LongInt;
  CC, DD    : LongInt;
  EE, FF    : LongInt;
  GG, HH    : LongInt;
  I, R      : LongInt;
  Temp      : TSubKeys;
begin
  KeyArray := @Key;
  Context.Encrypt := Encrypt;
  Context.Rounds := Max(4, Min(16, Rounds));

  for I := 0 to 3 do begin
    AA := KeyArray^[0]; BB := BCSalts[I];
    CC := KeyArray^[1]; DD := BCSalts[I];
    EE := KeyArray^[2]; FF := BCSalts[I];
    GG := KeyArray^[3]; HH := BCSalts[I];
    for R := 0 to 7 do begin
      AA := AA xor (BB shl 11); DD := DD + AA; BB := BB + CC;
      BB := BB xor (CC shr 2);  EE := EE + BB; CC := CC + DD;
      CC := CC xor (DD shl 8);  FF := FF + CC; DD := DD + EE;
      DD := DD xor (EE shr 16); GG := GG + DD; EE := EE + FF;
      EE := EE xor (FF shl 10); HH := HH + EE; FF := FF + GG;
      FF := FF xor (GG shr 4);  AA := AA + FF; GG := GG + HH;
      GG := GG xor (HH shl 8);  BB := BB + GG; HH := HH + AA;
      HH := HH xor (AA shr 9);  CC := CC + HH; AA := AA + BB;
    end;
    Context.SubKeysInts[I, 0] := AA;
    Context.SubKeysInts[I, 1] := BB;
    Context.SubKeysInts[I, 2] := CC;
    Context.SubKeysInts[I, 3] := DD;
    Context.SubKeysInts[I, 4] := EE;
    Context.SubKeysInts[I, 5] := FF;
    Context.SubKeysInts[I, 6] := GG;
    Context.SubKeysInts[I, 7] := HH;
  end;

  if not Encrypt then begin
    for I := 0 to Context.Rounds - 1 do begin
      Temp.SubKeys64[(Context.Rounds - 1) - I] := Context.SubKeys64[I];
    end;
    for I := 0 to Context.Rounds - 1 do begin
      Context.SubKeys64[I] := Temp.SubKeys64[I];
    end;
  end;
end;

procedure InitEncryptDES(const Key : TKey64; var Context : TDESContext;  Encrypt : Boolean);
const
  PC1        : array [0..55] of Byte =
    (56, 48, 40, 32, 24, 16, 8, 0, 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26,
     18, 10, 2, 59, 51, 43, 35, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21,
     13, 5, 60, 52, 44, 36, 28, 20, 12, 4, 27, 19, 11, 3);
  PC2        : array [0..47] of Byte =
    (13, 16, 10, 23, 0, 4, 2, 27, 14, 5, 20, 9, 22, 18, 11, 3, 25, 7,
     15, 6, 26, 19, 12, 1, 40, 51, 30, 36, 46, 54, 29, 39, 50, 44, 32, 47,
     43, 48, 38, 55, 33, 52, 45, 41, 49, 35, 28, 31);
  CTotRot    : array [0..15] of Byte = (1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28);
  CBitMask   : array [0..7] of Byte = (128, 64, 32, 16, 8, 4, 2, 1);
var
  PC1M       : array [0..55] of Byte;
  PC1R       : array [0..55] of Byte;
  KS         : array [0..7] of Byte;
  I, J, L, M : LongInt;
begin
  for J := 0 to 55 do begin
    L := PC1[J];
    M := L mod 8;
    PC1M[J] := Ord((Key[L div 8] and CBitMask[M]) <> 0);
  end;
  for I := 0 to 15 do begin
    for J := 0 to 27 do begin
      L := J + CTotRot[I];
      if (L < 28) then begin
        PC1R[J] := PC1M[L];
        PC1R[J + 28] := PC1M[L + 28];
      end else begin
        PC1R[J] := PC1M[L - 28];
        PC1R[J + 28] := PC1M[L];
      end;
    end;
    FillChar(KS, SizeOf(KS), 0);
    for J := 0 to 47 do begin
      if Boolean(PC1R[PC2[J]]) then begin
        L := J div 6;
        KS[L] := KS[L] or CBitMask[J mod 6] shr 2;
      end;
    end;
    if Encrypt then begin
      Context.TransformedKey[I * 2] := (LongInt(KS[0]) shl 24) or (LongInt(KS[2]) shl 16) or
        (LongInt(KS[4]) shl 8) or (LongInt(KS[6]));
      Context.TransformedKey[I * 2 + 1] := (LongInt(KS[1]) shl 24) or (LongInt(KS[3]) shl 16) or
        (LongInt(KS[5]) shl 8) or (LongInt(KS[7]));
    end else begin
      Context.TransformedKey[31 - (I * 2 + 1)] := (LongInt(KS[0]) shl 24) or (LongInt(KS[2]) shl 16) or
        (LongInt(KS[4]) shl 8) or (LongInt(KS[6]));
      Context.TransformedKey[31 - (I * 2)] := (LongInt(KS[1]) shl 24) or (LongInt(KS[3]) shl 16) or
        (LongInt(KS[5]) shl 8) or (LongInt(KS[7]));
    end;
  end;
  Context.Encrypt := Encrypt;
end;

procedure EncryptLBCCBC(const Context : TLBCContext; const Prev : TLBCBlock; var Block : TLBCBlock);
begin
  if Context.Encrypt then begin
    XorMem(Block, Prev, SizeOf(Block));
    EncryptLBC(Context, Block);
  end else begin
    EncryptLBC(Context, Block);
    XorMem(Block, Prev, SizeOf(Block));
  end;
end;


procedure XorMem(var Mem1;  const Mem2;  Count : Cardinal);
begin
  XorMemPrim(Mem1, Mem2, Count);
end;

procedure XorMemPrim(var Mem1; const Mem2; Count : Cardinal);
var
   i: Integer;
   p1,p2: NativeInt;
begin
   p1 := NativeInt(@Mem1);
   p2 := NativeInt(@Mem2);
   for i := 1 to count div 4 do begin
     PDWord(p1)^ := PDWord(p1)^ xor PDWord(p2)^;
     p1 := p1 + 4;
     p2 := p2 + 4;
   end;
   for i:=1 to count mod 4 do begin
     PByte(p1)^ := PByte(p1)^ xor PByte(p2)^;
     p1 := p1 + 1;
     p2 := p2 + 1;
   end;
end;

procedure EncryptLBC(const Context : TLBCContext; var Block : TLBCBlock);
var
  Blocks    : array[0..1] of TBCHalfBlock;
  Work      : TBCHalfBlock;
  Right     : TBCHalfBlock;
  Left      : TBCHalfBlock;
  AA, BB    : LongInt;
  CC, DD    : LongInt;
  R, T      : LongInt;
begin
  Move(Block, Blocks, SizeOf(Blocks));
  Right := Blocks[0];
  Left := Blocks[1];

  for R := 0 to Context.Rounds - 1 do begin
    AA := Right[0];
    BB := TBCHalfBlock(Context.SubKeys64[R])[0];
    CC := Right[1];
    DD := TBCHalfBlock(Context.SubKeys64[R])[1];

    AA := AA + DD; DD := DD + AA; AA := AA xor (AA shr 7);
    BB := BB + AA; AA := AA + BB; BB := BB xor (BB shl 13);
    CC := CC + BB; BB := BB + CC; CC := CC xor (CC shr 17);
    DD := DD + CC; CC := CC + DD; DD := DD xor (DD shl 9);
    AA := AA + DD; DD := DD + AA; AA := AA xor (AA shr 3);
    BB := BB + AA; AA := AA + BB; BB := BB xor (BB shl 7);
    CC := CC + BB; BB := BB + CC; CC := CC xor (DD shr 15);
    DD := DD + CC; CC := CC + DD; DD := DD xor (DD shl 11);

    T := AA; AA := CC; CC := T;
    T := BB; BB := DD; DD := T;

    AA := AA + DD; DD := DD + AA; AA := AA xor (AA shr 7);
    BB := BB + AA; AA := AA + BB; BB := BB xor (BB shl 13);
    CC := CC + BB; BB := BB + CC; CC := CC xor (CC shr 17);
    DD := DD + CC; CC := CC + DD; DD := DD xor (DD shl 9);
    AA := AA + DD; DD := DD + AA; AA := AA xor (AA shr 3);
    BB := BB + AA; AA := AA + BB; BB := BB xor (BB shl 7);
    CC := CC + BB; BB := BB + CC; CC := CC xor (DD shr 15);
    DD := DD + CC; CC := CC + DD; DD := DD xor (DD shl 11);

    Work[0] := Left[0] xor AA xor BB;
    Work[1] := Left[1] xor CC xor DD;

    Left := Right;
    Right := Work;
  end;

  Blocks[0] := Left;
  Blocks[1] := Right;
  Move(Blocks, Block, SizeOf(Block));                                {!!.01}
end;

function Random64Byte(var Seed : TInt64) : Byte;
var
  L : LongInt;
  R : TLongIntRec;
begin
  L := Random64(Seed);
  R := TLongIntRec(L);
  Result := R.LoLo xor R.LoHi xor R.HiLo xor R.HiHi;
end;

function Random64(var Seed : TInt64) : LongInt;
begin
  Ran01(Seed.Lo);
  Ran01(Seed.Hi);
  Result := Seed.Lo xor Seed.Hi;
end;

function Random32Byte(var Seed : LongInt) : Byte;
var
  L : LongInt;
  R : TLongIntRec;
begin
  L := Ran01(Seed);
  R := TLongIntRec(L);
  Result := R.LoLo xor R.LoHi xor R.HiLo xor R.HiHi;
end;

function Ran03(var Seed : LongInt) : LongInt;
begin
  Result := Ran0Prim(Seed, 69621, 30845, 23902);
end;

function Ran02(var Seed : LongInt) : LongInt;
begin
  Result := Ran0Prim(Seed, 48271, 44488, 3399);
end;

function Ran01(var Seed : LongInt) : LongInt;
begin
  Result := Ran0Prim(Seed, 16807, 127773, 2836);
end;

function Ran0Prim(var Seed : LongInt; IA, IQ, IR : LongInt) : LongInt;
const
  IM = 2147483647;
  MA = 123459876;
var
  I, K : LongInt;
begin
  I := Seed xor MA;
  K := I div IQ;
  I := (IA * (I - (K * IQ))) - (IR * K);
  if I < 0 then begin
    I := I + IM;
  end;
  Result := I xor MA;
  Seed := Result;
end;

function CompareBuffers(const Buf1, Buf2; BufSize : Cardinal) : Boolean;
var
  i : Integer;
begin
  Result := False;
  for i := 0 to Pred(BufSize) do begin
    Result := TByteArray(Buf1)[i] = TByteArray(Buf2)[i];
    if not Result then begin
      Break;
    end;
  end;
end;

function Max(A, B : LongInt) : LongInt;
begin
  if A > B then begin
    Result := A
  end else begin
    Result := B;
  end;
end;

function Min(A, B : LongInt) : LongInt;
begin
  if A < B then begin
    Result := A
  end else begin
    Result := B;
  end;
end;

function BufferToHex(const Buf; BufSize : Cardinal) : string;
var
  I     : LongInt;
begin
  Result := '';
  for I := 0 to BufSize - 1 do begin
    Result := Result + IntToHex(TByteArray(Buf)[I], 2);
  end;
end;

function HexToBuffer(const Hex : string; var Buf; BufSize : Cardinal) : Boolean;
var
  i, C  : Integer;
  Str   : string;
  Count : Integer;
begin
  Result := False;
  Str := '';
  for i := 1 to Length(Hex) do begin
    if {$IFDEF Unicode}CharInSet(UpCase(Hex[i]), ['0'..'9', 'A'..'F']){$ELSE} Upcase(Hex[i]) in ['0'..'9', 'A'..'F'] {$ENDIF} then begin
      Str := Str + Hex[i];
    end;
  end;
  FillChar(Buf, BufSize, #0);
  Count := Min(Length(Hex), BufSize);
  for i := 0 to Count - 1 do begin
    Val('$' + Copy(Str, (i shl 1) + 1, 2), TByteArray(Buf)[i], C);   {!!.01}
    if (C <> 0) then begin
      Exit;
    end;
  end;
  Result := True;
end;

constructor TLbRandomGenerator.create;
begin
  inherited;
  ChurnSeed;
end;

destructor TLbRandomGenerator.Destroy;
begin
  RandCount := 0;
  FillChar( Seed, SizeOf( Seed ), $00 );
  inherited;
end;

procedure TLbRandomGenerator.ChurnSeed;
var
  RandomSeed : array[ 0..15 ] of byte;
  Context : TMD5Context;
  lcg : TLbRanLFS;
  i : integer;
begin
  lcg := TLbRanLFS.Create;
  try
    lcg.FillBuf( RandomSeed, SizeOf( RandomSeed ));
    for i := 0 to 4 do begin
      InitMD5( Context );
      UpdateMD5( Context, Seed, SizeOf( Seed ));
      UpdateMD5( Context, RandomSeed, SizeOf( RandomSeed ));
      FinalizeMD5( Context, Seed );
    end;
  finally
    lcg.Free;
  end;
end;

procedure TLbRandomGenerator.RandomBytes( var buff; len : DWORD );
var
  Context : TMD5Context;
  TmpDig : TMD5Digest;
  Index : DWORD;
  m : integer;
  SizeOfTmpDig : integer;
begin
  SizeOfTmpDig := SizeOf( TmpDig );
  Index := 0;

  if(( len - Index ) < 16 )then begin
    m := len - Index
  end else begin
    m := SizeOfTmpDig;
  end;

  While Index < len do begin
    InitMD5( Context );
    UpdateMD5( Context, Seed, sizeof( Seed ));
    UpdateMD5( Context, RandCount, sizeof( RandCount ));
    FinalizeMD5( Context, TmpDig );

    inc( RandCount );
    move( tmpDig, TByteArray( buff )[ Index ], m );
    inc( Index, m );

    if(( len - Index ) < 16 )then begin
      m := len - Index
    end else begin
      m := SizeOfTmpDig;
    end;
  end;
end;

constructor TLbRanLFS.Create;
begin
  inherited;
  SetSeed;
end;

destructor TLbRanLFS.Destroy;
begin
  inherited;
end;

procedure TLbRanLFS.FillBuf( var buff; len : DWORD );
var
  l : DWORD;
  b : byte;
  tmp_byt : byte;
begin
  for l := 0 to pred( len )do begin
    tmp_byt := 0;
    for b := 0 to 7 do begin
      tmp_byt := ( tmp_byt shl 1 ) or LFS;
    end;
    TByteArray( buff )[ l ] := tmp_byt;
  end;
end;

procedure TLbRanLFS.SetSeed;
const
  hold : integer = 1;
var
  _time : TSYSTEMTIME;

begin
  while true do begin

    ShiftRegister := hold;
    GetLocalTime( _time );
    ShiftRegister := ( ShiftRegister shl ( hold and $0000000F )) xor
                     (( DWORD( _time.Hour or _time.Second ) shl 16 ) or
                      ( DWORD( _time.Minute or _time.MilliSecond  )));
    hold := ShiftRegister;
    inc( hold );
    if( ShiftRegister <> 0 )then begin
      break;
    end;
  end;
end;

function TLbRanLFS.LFS : byte;
begin
  ShiftRegister := (((( ShiftRegister shr 31 ) xor
                      ( ShiftRegister shr 6  ) xor
                      ( ShiftRegister shr 4  ) xor
                      ( ShiftRegister shr 2  ) xor
                      ( ShiftRegister shr 1  ) xor
                      ( ShiftRegister )) and $00000001 ) shl 31 ) or
                      ( ShiftRegister shr 1 );
  result := ShiftRegister and $00000001;
end;


constructor TLbBigInt.Create(ALen : Integer);
var
  prec : Integer;
begin
  if (Alen < 1) then
    prec := cUSE_DEFAULT_PRECISION
  else
    prec := ALen;

  LbBiInit(FI, prec);
  inherited Create;
end;

destructor TLbBigInt.Destroy;
begin
  LbBiFree(FI);
  inherited Destroy;
end;

procedure TLbBigInt.SetSign(value : Boolean);
begin
  LbBiVerify(FI);
  if (value <> FI.bSign) then begin
    FI.bSign := value;
  end;
end;

function TLbBigInt.getSign : Boolean;
begin
  LbBiVerify(FI);
  Result := FI.bSign;
end;

procedure TLbBigInt.Add(I2 : TLbBigInt);
var
  tmp : LbInteger;
begin
  LbBiInit(tmp, cUSE_DEFAULT_PRECISION);
  try
    LbBiCopy(tmp, I2.Int, I2.Int.dwUsed);
    LbBiVerify(tmp);
    LbBiAddInPlace(FI, tmp);
  finally
    LbBiFree(tmp);
  end;
end;

procedure TLbBigInt.Subtract(I2 : TLbBigInt);
var
  tmp : LbInteger;
begin
  LbBiVerify(FI);
  LbBiInit(tmp, cUSE_DEFAULT_PRECISION);
  try
    LbBiCopy(tmp, I2.Int, I2.Int.dwUsed);
    LbBiVerify(tmp);
    LbBiSubInPlace(FI, tmp);
  finally
    LbBiFree(tmp);
  end;
end;

procedure TLbBigInt.Multiply(I2 : TLbBigInt);
var
  tmp : LbInteger;
begin
  LbBiVerify(FI);
  LbBiInit(tmp, cUSE_DEFAULT_PRECISION);
  try
    LbBiCopy(tmp, I2.Int, I2.Int.dwUsed);
    LbBiVerify(tmp);
    LbBiMultInPlace(FI, tmp);
  finally
    LbBiFree(tmp);
  end;
end;

procedure TLbBigInt.Divide(I2 : TLbBigInt);
var
  tmp : LbInteger;
  rem : LbInteger;
begin
  LbBiVerify(FI);
  LbBiInit(tmp, cUSE_DEFAULT_PRECISION);
  LbBiInit(rem, cUSE_DEFAULT_PRECISION);
  try
    LbBiCopy(tmp, I2.Int, I2.Int.dwUsed);
    LbBiVerify(tmp);
    LbBiDivInPlace(FI, tmp, rem);
  finally
    LbBiFree(tmp);
    LbBiFree(rem);
  end;
end;

procedure TLbBigInt.Modulus(I2 : TLbBigInt);
var
  tmp : LbInteger;
begin
  LbBiVerify(FI);
  LbBiInit(tmp, cUSE_DEFAULT_PRECISION);
  try
    LbBiCopy(tmp, I2.Int, I2.Int.dwUsed);
    LbBiVerify(tmp);
    LbBiModInPlace(FI, tmp);
  finally
    LbBiFree(tmp);
  end;
end;

procedure TLbBigInt.SubtractByte(b : byte);
begin
  LbBiVerify(FI);
  LbBiSubByDigitInPlace(FI, b);
end;

procedure TLbBigInt.MultiplyByte(b : byte);
begin
  LbBiVerify(FI);
  LbBiMulByDigitInPlace(FI, b);
end;

procedure TLbBigInt.DivideByte(b : byte);
var
  rem : byte;
begin
  LbBiVerify(FI);
  LbBiDivByDigitInPlace(FI, b, rem);
end;

procedure TLbBigInt.ModByte(b : byte);
var
  rem : byte;
begin
  LbBiVerify(FI);
  LbBiDivByDigitInPlace(FI, b, rem);
  LbBiClear(FI);
  LbBiAddByte(FI, cPREPEND_ARRAY, rem);
end;

procedure TLbBigInt.AddByte(b : byte);
begin
  LbBiVerify(FI);
  LbBiAddByDigitInPlace(FI, b);
end;

procedure TLbBigInt.Clear;
begin
  LbBiClear(FI);
end;

procedure TLbBigInt.Trim;
begin
  LbBiVerify(FI);
  LbBiTrimSigZeros(FI);
end;

function TLbBigInt.Compare(I2 : TLbBigInt) : ShortInt;
var
  tmp : LbInteger;
begin
  LbBiVerify(FI);
  LbBiInit(tmp, I2.Int.dwUsed);
  try
    LbBiCopy(tmp, I2.Int, I2.Int.dwUsed);
    LbBiVerify(tmp);
    Result := LbBiCompare(FI, tmp);
  finally
    LbBiFree(tmp);
  end;
end;

function TLbBigInt.Abs(I2 : TLbBigInt): ShortInt;
var
  tmp : LbInteger;
begin
  LbBiVerify(FI);
  LbBiInit(tmp, cUSE_DEFAULT_PRECISION);
  try
    LbBiCopy(tmp, I2.Int, I2.Int.dwUsed);
    LbBiVerify(tmp);
    Result := LbBiAbs(FI, tmp);
  finally
    LbBiFree(tmp);
  end;
end;

function TLbBigInt.IsZero : Boolean;
begin
  LbBiVerify(FI);
  Result := LbBiIsZero(FI);
end;

function TLbBigInt.IsOne : Boolean;
begin
  LbBiVerify(FI);
  Result := LbBiIsOne(FI);
end;

function TLbBigInt.IsComposite(Iterations : Cardinal) : Boolean;
begin
  LbBiVerify(FI);
  Result := true;
  if LbBiCheckSimplePrimes(FI) then
     if (not LbBiIsCompositFast(FI, Iterations)) then
         Result := false;
end;

procedure TLbBigInt.Copy(I2 : TLbBigInt);
begin
  Clear;
  LbBIMove(FI, I2.Int, cAPPEND_ARRAY, I2.Size);
end;

procedure TLbBigInt.CopyLen(I2 : TLbBigInt; Len : Integer);
begin
  Clear;
  LbBIMove(FI, I2.Int, cAPPEND_ARRAY, Len);
end;

procedure TLbBigInt.CopyByte(b : byte);
begin
  Clear;
  LbBiAddByte(FI, cPREPEND_ARRAY, b);
end;

procedure TLbBigInt.CopyWord(w : word);
begin
  Clear;
  LbBiAddWord(FI, cPREPEND_ARRAY, w);
end;

procedure TLbBigInt.CopyDWord(d : dword);
begin
  Clear;
  LbBiAddDWord(FI, cPREPEND_ARRAY, d);
end;

procedure TLbBigInt.CopyBuffer(const Buf; BufLen : Integer);
begin
  Clear;
  LbBiAddBuf(FI, cPREPEND_ARRAY, @Buf, BufLen);
end;

procedure TLbBigInt.Append(I : TLbBigInt);
begin
  LbBIMove(FI, I.Int, cAPPEND_ARRAY, I.Size);
end;

procedure TLbBigInt.AppendByte(b : byte);
begin
  LbBiAddByte(FI, cAPPEND_ARRAY, b);
end;

procedure TLbBigInt.AppendWord(w : word);
begin
  LbBiAddWord(FI, cAPPEND_ARRAY, w);
end;

procedure TLbBigInt.AppendDWord(d : dword);
begin
  LbBiAddDWord(FI, cAPPEND_ARRAY, d);
end;

procedure TLbBigInt.AppendBuffer(const Buf; BufLen : Integer);
begin
  LbBiAddBuf(FI, cAPPEND_ARRAY, @Buf, BufLen);
end;

procedure TLbBigInt.Prepend(I : TLbBigInt);
begin
  LbBIMove(FI, I.Int, cPREPEND_ARRAY, I.Size);
end;

procedure TLbBigInt.PrependByte(b : byte);
begin
  LbBiAddByte(FI, cPREPEND_ARRAY, b);
end;

procedure TLbBigInt.PrependWord(w : word);
begin
  LbBiAddWord(FI, cPREPEND_ARRAY, w);
end;

procedure TLbBigInt.PrependDWord(d : dword);
begin
  LbBiAddDWord(FI, cPREPEND_ARRAY, d);
end;

procedure TLbBigInt.PrependBuffer(const Buf; BufLen : Integer);
begin
  LbBiAddBuf(FI, cPREPEND_ARRAY, @Buf, BufLen);
end;

procedure TLbBigInt.RandomPrime(Iterations : Byte);
begin
  LbBiRandomPrime(FI, Iterations);
end;

procedure TLbBigInt.RandomSimplePrime;
begin
  LbBiRandomSimplePrime(FI);
end;

procedure TLbBigInt.RandomBytes(Count : Cardinal);
begin
  LbBiRandomBytes(FI, Count);
end;

function TLbBigInt.ToBuffer(var Buf; BufLen : Integer ) : integer;
var
  len : Integer;
begin
  len := Min(FI.dwUsed, BufLen);
  result := len;
  LbBiCopyBigInt2Buf(FI, cPREPEND_ARRAY, @Buf, len);
end;

procedure TLbBigInt.ReverseBits;
begin
  LbBiVerify(FI);
  LbBiReverseBitsInPlace(FI);
end;

procedure TLbBigInt.ReverseBytes;
begin
  LbBiVerify(FI);
  LbBiReverseBytesInPlace(FI);
end;

function TLbBigInt.IsOdd : Boolean;
begin
  LbBiVerify(FI);
  Result := LbBiIsOdd(FI);
end;

function TLbBigInt.IsEven : Boolean;
begin
  LbBiVerify(FI);
  Result := LbBiIsEven(FI);
end;

function TLbBigInt.GetBit(bit : Integer) : Boolean;
begin
  LbBiVerify(FI);
  Result := LbBiGetBit(FI, bit);
end;

procedure TLbBigInt.Shr_(_shr : Integer);
begin
  LbBiVerify(FI);
  LbBiShr(FI, _shr);
end;

procedure TLbBigInt.Shl_(_shl : Integer);
begin
  LbBiVerify(FI);
  LbBiShl(FI, _shl);
end;

procedure TLbBigInt.XOR_(I2 : TLbBigInt);
begin
  LbBiVerify(FI);
  LbBiXORInPlace(FI, I2.Int);
end;

procedure TLbBigInt.OR_(I2 : TLbBigInt);
begin
  LbBiVerify(FI);
  LbBiORInPlace(FI, I2.Int);
end;

function TLbBigInt.ModInv(Modulus : TLbBigInt) : Boolean;
var
  tmp : LbInteger;
  x : LbInteger;
begin
  LbBiInit(tmp, cUSE_DEFAULT_PRECISION);
  LbBiInit(x, cUSE_DEFAULT_PRECISION);
  try
    LbBiCopy(tmp, Modulus.Int, Modulus.Int.dwUsed);
    LbBiVerify(tmp);

    Result := LbBiModInv(FI, tmp, x);
    LbBiClear(FI);
    LbBiCopy(FI, x, x.dwUsed);
  finally
    LbBiFree(tmp);
    LbBiFree(x);
  end;
end;

function TLbBigInt.GetSize : integer;
begin
  Result := FI.dwUsed;
end;

function TLbBigInt.GetIntStr : string;
begin
  Result := BufferToHex(IntBuf^, FI.dwUsed);
end;

function TLbBigInt.GetIntBuf : pByte;
begin
  Result := FI.IntBuf.pBuf;
end;

procedure TLbBigInt.PowerAndMod(Exponent : TLbBigInt; Modulus : TLbBigInt);
begin
  LbBiPowerAndModInPLace(FI, Exponent.Int, Modulus.Int);
end;

function TLbBigInt.GetByteValue( place : integer ) : Byte;
begin
  LbBiVerify(FI);
  result := LbBiGetByteValue( FI, place );
end;

constructor TLbCipher.Create(AOwner : TComponent);
begin
  inherited Create(AOwner);
end;

destructor TLbCipher.Destroy;
begin
  inherited Destroy;
end;

function TLbCipher.DecryptBuffer(const InBuf; InBufSize : Cardinal; var OutBuf) : Cardinal;
var
  InS, OutS : TMemoryStream;
begin
  InS := TMemoryStream.Create;
  OutS := TMemoryStream.Create;
  try
    InS.SetSize(InBufSize);
    InS.Write(InBuf, InBufSize);
    InS.Position := 0;
    DecryptStream(InS, OutS);
    OutS.Position := 0;
    OutS.Read(OutBuf, OutS.Size);
    Result := OutS.Size;
  finally
    InS.Free;
    OutS.Free;
  end;
end;

function TLbCipher.DecryptString(const InString: {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF}): {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
begin
  {$IFDEF LOCKBOXUNICODE}
  Result := DecryptStringW(InString);
  {$ELSE}
  Result := DecryptStringA(InString);
  {$ENDIF}
end;


function TLbCipher.EncryptBuffer(const InBuf; InBufSize : Cardinal; var OutBuf) : Cardinal;
var
  InS, OutS : TMemoryStream;
begin
  InS := TMemoryStream.Create;
  OutS := TMemoryStream.Create;
  try
    InS.SetSize(InBufSize);
    InS.Write(InBuf, InBufSize);
    InS.Position := 0;
    EncryptStream(InS, OutS);
    OutS.Position := 0;
    OutS.Read(OutBuf, OutS.Size);
    Result := OutS.Size;
  finally
    InS.Free;
    OutS.Free;
  end;
end;


function TLbCipher.EncryptString(const InString : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF}) : {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF};
begin
  {$IFDEF LOCKBOXUNICODE}
  Result := EncryptStringW(InString);
  {$ELSE}
  Result := EncryptStringA(InString);
  {$ENDIF}
end;

constructor TLbSymmetricCipher.Create(AOwner : TComponent);
begin
  inherited Create(AOwner);
end;

destructor TLbSymmetricCipher.Destroy;
begin
  inherited Destroy;
end;

procedure TLbSymmetricCipher.GenerateKey(const Passphrase: {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF});
begin
  {$IFDEF LOCKBOXUNICODE}
  GenerateKeyW(Passphrase);
  {$ELSE}
  GenerateKeyA(Passphrase);
  {$ENDIF}
end;

constructor TLbBlowfish.Create(AOwner : TComponent);
begin
  inherited Create(AOwner);
end;

destructor TLbBlowfish.Destroy;
begin
  inherited Destroy;
end;

procedure TLbBlowfish.DecryptFile(const InFile, OutFile : string);
begin
  case CipherMode of
    cmECB : BFEncryptFile(InFile, OutFile, FKey, False);
    cmCBC : BFEncryptFileCBC(InFile, OutFile, FKey, False);
  end;
end;

procedure TLbBlowfish.DecryptStream(InStream , OutStream : TStream);
begin
  case CipherMode of
    cmECB : BFEncryptStream(InStream, OutStream, FKey, False);
    cmCBC : BFEncryptStreamCBC(InStream, OutStream, FKey, False);
  end;
end;

function TLbBlowfish.DecryptStringA(const InString : AnsiString) : AnsiString;
begin
  case CipherMode of
    cmECB : Result := BFEncryptStringExA(InString, FKey, False);
    cmCBC : Result := BFEncryptStringCBCExA(InString, FKey, False);
  end;
end;

{$IFDEF UNICODE}
function TLbBlowfish.DecryptStringW(const InString : UnicodeString) : UnicodeString;
begin
  case CipherMode of
    cmECB : Result := BFEncryptStringExW(InString, FKey, False);
    cmCBC : Result := BFEncryptStringCBCExW(InString, FKey, False);
  end;
end;
{$ENDIF}

procedure TLbBlowfish.EncryptFile(const InFile, OutFile : string);
begin
  case CipherMode of
    cmECB : BFEncryptFile(InFile, OutFile, FKey, True);
    cmCBC : BFEncryptFileCBC(InFile, OutFile, FKey, True);
  end;
end;

procedure TLbBlowfish.EncryptStream(InStream, OutStream : TStream);
begin
  case CipherMode of
    cmECB : BFEncryptStream(InStream, OutStream, FKey, True);
    cmCBC : BFEncryptStreamCBC(InStream, OutStream, FKey, True);
  end;
end;

function TLbBlowfish.EncryptStringA(const InString: AnsiString): AnsiString;
begin
  case CipherMode of
    cmECB : Result := BFEncryptStringExA(InString, FKey, True);
    cmCBC : Result := BFEncryptStringCBCExA(InString, FKey, True);
  end;
end;

{$IFDEF UNICODE}
function TLbBlowfish.EncryptStringW(const InString : UnicodeString) : UnicodeString;
begin
  case CipherMode of
    cmECB : Result := BFEncryptStringExW(InString, FKey, True);
    cmCBC : Result := BFEncryptStringCBCExW(InString, FKey, True);
  end;
end;
{$ENDIF}

procedure TLbBlowfish.GenerateKeyA(const Passphrase : AnsiString);
begin
  GenerateLMDKeyA(FKey, SizeOf(FKey), Passphrase);
end;

{$IFDEF UNICODE}
procedure TLbBlowfish.GenerateKeyW(const Passphrase : UnicodeString);
begin
  GenerateLMDKeyW(FKey, SizeOf(FKey), Passphrase);
end;
{$ENDIF}

procedure TLbBlowfish.GenerateRandomKey;
begin
  lockbox.GenerateRandomKey(FKey, SizeOf(FKey));
end;

procedure TLbBlowfish.GetKey(var Key : TKey128);
begin
  Key := FKey;
end;

procedure TLbBlowfish.SetKey(const Key : TKey128);
begin
  FKey := Key;
end;

function TLbBlowfish.OutBufSizeNeeded(InBufSize : Cardinal) : Cardinal;
var
  BlkCount, BlkSize : Cardinal;
begin
  BlkSize := SizeOf(TBFBlock);
  BlkCount := (InBufSize div BlkSize) + 1;
  Result := BlkCount * BlkSize;
end;

constructor TLbDES.Create(AOwner : TComponent);
begin
  inherited Create(AOwner);
end;

destructor TLbDES.Destroy;
begin
  inherited Destroy;
end;

procedure TLbDES.DecryptFile(const InFile, OutFile : string);
begin
  case CipherMode of
    cmECB : DESEncryptFile(InFile, OutFile, FKey, False);
    cmCBC : DESEncryptFileCBC(InFile, OutFile, FKey, False);
  end;
end;

procedure TLbDES.DecryptStream(InStream , OutStream : TStream);
begin
  case CipherMode of
    cmECB : DESEncryptStream(InStream, OutStream, FKey, False);
    cmCBC : DESEncryptStreamCBC(InStream, OutStream, FKey, False);
  end;
end;

function TLbDES.DecryptStringA(const InString : AnsiString) : AnsiString;
begin
  case CipherMode of
    cmECB : Result := DESEncryptStringExA(InString, FKey, False);
    cmCBC : Result := DESEncryptStringCBCExA(InString, FKey, False);
  end;
end;

{$IFDEF UNICODE}
function TLbDES.DecryptStringW(const InString : UnicodeString) : UnicodeString;
begin
  case CipherMode of
    cmECB : Result := DESEncryptStringExW(InString, FKey, False);
    cmCBC : Result := DESEncryptStringCBCExW(InString, FKey, False);
  end;
end;
{$ENDIF}

procedure TLbDES.EncryptFile(const InFile, OutFile : string);
begin
  case CipherMode of
    cmECB : DESEncryptFile(InFile, OutFile, FKey, True);
    cmCBC : DESEncryptFileCBC(InFile, OutFile, FKey, True);
  end;
end;

procedure TLbDES.EncryptStream(InStream, OutStream : TStream);
begin
  case CipherMode of
    cmECB : DESEncryptStream(InStream, OutStream, FKey, True);
    cmCBC : DESEncryptStreamCBC(InStream, OutStream, FKey, True);
  end;
end;

function TLbDES.EncryptStringA(const InString : AnsiString) : AnsiString;
begin
  case CipherMode of
    cmECB : Result := DESEncryptStringExA(InString, FKey, True);
    cmCBC : Result := DESEncryptStringCBCExA(InString, FKey, True);
  end;
end;

{$IFDEF UNICODE}
function TLbDES.EncryptStringW(const InString : UnicodeString) : UnicodeString;
begin
  case CipherMode of
    cmECB : Result := DESEncryptStringExW(InString, FKey, True);
    cmCBC : Result := DESEncryptStringCBCExW(InString, FKey, True);
  end;
end;
{$ENDIF}

procedure TLbDES.GenerateKeyA(const Passphrase : AnsiString);
begin
  GenerateLMDKeyA(FKey, SizeOf(FKey), Passphrase);
end;

{$IFDEF UNICODE}
procedure TLbDES.GenerateKeyW(const Passphrase : UnicodeString);
begin
  GenerateLMDKeyW(FKey, SizeOf(FKey), Passphrase);
end;
{$ENDIF}

procedure TLbDES.GenerateRandomKey;
begin
  lockbox.GenerateRandomKey(FKey, SizeOf(FKey));
end;

procedure TLbDES.SetKey(const Key : TKey64);
begin
  FKey := Key;
end;

procedure TLbDES.GetKey(var Key : TKey64);
begin
  Key := FKey;
end;

function TLbDES.OutBufSizeNeeded(InBufSize : Cardinal) : Cardinal;
var
  BlkCount, BlkSize : Cardinal;
begin
  BlkSize := SizeOf(TDESBlock);
  BlkCount := (InBufSize div BlkSize) + 1;
  Result := BlkCount * BlkSize;
end;

constructor TLb3DES.Create(AOwner : TComponent);
begin
  inherited Create(AOwner);
end;

destructor TLb3DES.Destroy;
begin
  inherited Destroy;
end;

procedure TLb3DES.DecryptFile(const InFile, OutFile : string);
begin
  case CipherMode of
    cmECB : TripleDESEncryptFile(InFile, OutFile, FKey, False);
    cmCBC : TripleDESEncryptFileCBC(InFile, OutFile, FKey, False);
  end;
end;

procedure TLb3DES.DecryptStream(InStream , OutStream : TStream);
begin
  case CipherMode of
    cmECB : TripleDESEncryptStream(InStream, OutStream, FKey, False);
    cmCBC : TripleDESEncryptStreamCBC(InStream, OutStream, FKey, False);
  end;
end;

function TLb3DES.DecryptStringA(const InString : AnsiString) : AnsiString;
begin
  case CipherMode of
    cmECB : Result := TripleDESEncryptStringExA(InString, FKey, False);
    cmCBC : Result := TripleDESEncryptStringCBCExA(InString, FKey, False);
  end;
end;

{$IFDEF UNICODE}
function TLb3DES.DecryptStringW(const InString : UnicodeString) : UnicodeString;
begin
  case CipherMode of
    cmECB : Result := TripleDESEncryptStringExW(InString, FKey, False);
    cmCBC : Result := TripleDESEncryptStringCBCExW(InString, FKey, False);
  end;
end;
{$ENDIF}

procedure TLb3DES.EncryptFile(const InFile, OutFile : string);
begin
  case CipherMode of
    cmECB : TripleDESEncryptFile(InFile, OutFile, FKey, True);
    cmCBC : TripleDESEncryptFileCBC(InFile, OutFile, FKey, True);
  end;
end;

procedure TLb3DES.EncryptStream(InStream, OutStream : TStream);
begin
  case CipherMode of
    cmECB : TripleDESEncryptStream(InStream, OutStream, FKey, True);
    cmCBC : TripleDESEncryptStreamCBC(InStream, OutStream, FKey, True);
  end;
end;

function TLb3DES.EncryptStringA(const InString : AnsiString) : AnsiString;
begin
  case CipherMode of
    cmECB : Result := TripleDESEncryptStringExA(InString, FKey, True);
    cmCBC : Result := TripleDESEncryptStringCBCExA(InString, FKey, True);
  end;
end;

{$IFDEF UNICODE}
function TLb3DES.EncryptStringW(const InString : UnicodeString) : UnicodeString;
begin
  case CipherMode of
    cmECB : Result := TripleDESEncryptStringExW(InString, FKey, True);
    cmCBC : Result := TripleDESEncryptStringCBCExW(InString, FKey, True);
  end;
end;
{$ENDIF}

procedure TLb3DES.GenerateKeyA(const Passphrase : AnsiString);
begin
  GenerateLMDKeyA(FKey, SizeOf(FKey), Passphrase);
end;

{$IFDEF UNICODE}
procedure TLb3DES.GenerateKeyW(const Passphrase : UnicodeString);
begin
  GenerateLMDKeyW(FKey, SizeOf(FKey), Passphrase);
end;
{$ENDIF}

procedure TLb3DES.GenerateRandomKey;
begin
  lockbox.GenerateRandomKey(FKey, SizeOf(FKey));
end;

procedure TLb3DES.SetKey(const Key : TKey128);
begin
  FKey := Key;
end;

procedure TLb3DES.GetKey(var Key : TKey128);
begin
  Key := FKey;
end;

function TLb3DES.OutBufSizeNeeded(InBufSize : Cardinal) : Cardinal;
var
  BlkCount, BlkSize : Cardinal;
begin
  BlkSize := SizeOf(TDESBlock);
  BlkCount := (InBufSize div BlkSize) + 1;
  Result := BlkCount * BlkSize;
end;

constructor TLbRijndael.Create(AOwner : TComponent);
begin
  inherited Create(AOwner);
end;

destructor TLbRijndael.Destroy;
begin
  inherited Destroy;
  KeySize := ks128;                                                    {!!.04}
end;

procedure TLbRijndael.DecryptFile(const InFile, OutFile : string);
begin
  case CipherMode of
    cmECB : RDLEncryptFile(InFile, OutFile, FKey, FKeySizeBytes, False);
    cmCBC : RDLEncryptFileCBC(InFile, OutFile, FKey, FKeySizeBytes, False);
  end;
end;

procedure TLbRijndael.DecryptStream(InStream , OutStream : TStream);
begin
  case CipherMode of
    cmECB : RDLEncryptStream(InStream, OutStream, FKey, FKeySizeBytes, False);
    cmCBC : RDLEncryptStreamCBC(InStream, OutStream, FKey, FKeySizeBytes, False);
  end;
end;

function TLbRijndael.DecryptStringA(const InString : AnsiString) : AnsiString;
begin
  case CipherMode of
    cmECB : Result := RDLEncryptStringExA(InString, FKey, FKeySizeBytes, False);
    cmCBC : Result := RDLEncryptStringCBCExA(InString, FKey, FKeySizeBytes, False);
  end;
end;

{$IFDEF UNICODE}
function TLbRijndael.DecryptStringW(const InString : UnicodeString) : UnicodeString;
begin
  case CipherMode of
    cmECB : Result := RDLEncryptStringExW(InString, FKey, FKeySizeBytes, False);
    cmCBC : Result := RDLEncryptStringCBCExW(InString, FKey, FKeySizeBytes, False);
  end;
end;
{$ENDIF}

procedure TLbRijndael.EncryptFile(const InFile, OutFile : string);
begin
  case CipherMode of
    cmECB : RDLEncryptFile(InFile, OutFile, FKey, FKeySizeBytes, True);
    cmCBC : RDLEncryptFileCBC(InFile, OutFile, FKey, FKeySizeBytes, True);
  end;
end;

procedure TLbRijndael.EncryptStream(InStream, OutStream : TStream);
begin
  case CipherMode of
    cmECB : RDLEncryptStream(InStream, OutStream, FKey, FKeySizeBytes, True);
    cmCBC : RDLEncryptStreamCBC(InStream, OutStream, FKey, FKeySizeBytes, True);
  end;
end;

function TLbRijndael.EncryptStringA(const InString : AnsiString) : AnsiString;
begin
  case CipherMode of
    cmECB : Result := RDLEncryptStringExA(InString, FKey, FKeySizeBytes, True);
    cmCBC : Result := RDLEncryptStringCBCExA(InString, FKey, FKeySizeBytes, True);
  end;
end;

{$IFDEF UNICODE}
function TLbRijndael.EncryptStringW(const InString : UnicodeString) : UnicodeString;
begin
  case CipherMode of
    cmECB : Result := RDLEncryptStringExW(InString, FKey, FKeySizeBytes, True);
    cmCBC : Result := RDLEncryptStringCBCExW(InString, FKey, FKeySizeBytes, True);
  end;
end;
{$ENDIF}

procedure TLbRijndael.GenerateKeyA(const Passphrase : AnsiString);
begin
  GenerateLMDKeyA(FKey, FKeySizeBytes, Passphrase);
end;

{$IFDEF UNICODE}
procedure TLbRijndael.GenerateKeyW(const Passphrase : UnicodeString);
begin
  GenerateLMDKeyW(FKey, FKeySizeBytes, Passphrase);
end;
{$ENDIF}

procedure TLbRijndael.GenerateRandomKey;
begin
  lockbox.GenerateRandomKey(FKey, FKeySizeBytes);
end;

procedure TLbRijndael.GetKey(var Key);
begin
  Move(FKey, Key, FKeySizeBytes);
end;

procedure TLbRijndael.SetKey(const Key);
begin
  Move(Key, FKey, FKeySizeBytes);
end;

procedure TLbRijndael.SetKeySize(Value : TLbKeySizeRDL);
begin
  FKeySize := Value;
  FKeySizeBytes := RDLKeySizeMap[Value];
end;

function TLbRijndael.OutBufSizeNeeded(InBufSize : Cardinal) : Cardinal;
var
  BlkCount, BlkSize : Cardinal;
begin
  BlkSize := SizeOf(TRDLBlock);
  BlkCount := (InBufSize div BlkSize) + 1;
  Result := BlkCount * BlkSize;
end;

constructor TLbHash.Create(AOwner : TComponent);
begin
  inherited Create(AOwner);
end;

destructor TLbHash.Destroy;
begin
  inherited Destroy;
end;


procedure TLbHash.HashString(const AStr: {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF});
begin
  {$IFDEF LOCKBOXUNICODE}
  HashStringW(AStr);
  {$ELSE}
  HashStringA(AStr);
  {$ENDIF}
end;

constructor TLbMD5.Create(AOwner : TComponent);
begin
  inherited Create(AOwner);
end;

destructor TLbMD5.Destroy;
begin
  inherited Destroy;
end;

procedure TLbMD5.GetDigest(var Digest : TMD5Digest);
begin
  Move(FDigest, Digest, SizeOf(Digest));
end;

procedure TLbMD5.HashBuffer(const Buf; BufSize : Cardinal);
begin
  HashMD5(FDigest, Buf, BufSize);
end;

procedure TLbMD5.HashFile(const AFileName : string);
var
  FS : TFileStream;
begin
  FS := TFileStream.Create(AFileName, fmOpenRead or fmShareDenyNone);
  try
    HashStream(FS);
  finally
    FS.Free;
  end;
end;

procedure TLbMD5.HashStream(AStream: TStream);
var
  Context : TMD5Context;
  BufSize : Integer;
begin
  InitMD5(Context);
  BufSize := AStream.Read(FBuf, SizeOf(FBuf));
  while (BufSize > 0) do begin
    UpdateMD5(Context, FBuf, BufSize);
    BufSize := AStream.Read(FBuf, SizeOf(FBuf));
  end;
  FinalizeMD5(Context, FDigest);
end;

procedure TLbMD5.HashStringA(const AStr : AnsiString);
begin
  StringHashMD5A(FDigest, AStr);
end;
{$IFDEF UNICODE}
procedure TLbMD5.HashStringW(const AStr : UnicodeString);
begin
  StringHashMD5W(FDigest, AStr);
end;
{$ENDIF}

constructor TLbSHA1.Create(AOwner : TComponent);
begin
  inherited Create(AOwner);
end;

destructor TLbSHA1.Destroy;
begin
  inherited Destroy;
end;

procedure TLbSHA1.GetDigest(var Digest : TSHA1Digest);
begin
  Move(FDigest, Digest, SizeOf(Digest));
end;

procedure TLbSHA1.HashBuffer(const Buf; BufSize : Cardinal);
begin
  HashSHA1(FDigest, Buf, BufSize);
end;

procedure TLbSHA1.HashFile(const AFileName : string);
var
  FS : TFileStream;
begin
  FS := TFileStream.Create(AFileName, fmOpenRead or fmShareDenyNone);
  try
    HashStream(FS);
  finally
    FS.Free;
  end;
end;

procedure TLbSHA1.HashStream(AStream: TStream);
var
  Context : TSHA1Context;
  BufSize : Integer;
begin
  InitSHA1(Context);
  BufSize := AStream.Read(FBuf, SizeOf(FBuf));
  while (BufSize > 0) do begin
    UpdateSHA1(Context, FBuf, BufSize);
    BufSize := AStream.Read(FBuf, SizeOf(FBuf));
  end;
  FinalizeSHA1(Context, FDigest);
end;

procedure TLbSHA1.HashStringA(const AStr : AnsiString);
begin
  StringHashSHA1A(FDigest, AStr);
end;
{$IFDEF UNICODE}
procedure TLbSHA1.HashStringW(const AStr : UnicodeString);
begin
  StringHashSHA1W(FDigest, AStr);
end;
{$ENDIF}

constructor TLbSCStream.Create(const Key; KeySize : Integer);
begin
  inherited Create;

  Reinitialize(Key, KeySize);
end;

procedure TLbSCStream.Reinitialize(const Key; KeySize : Integer);
begin
  ChangeKey(Key, KeySize);
  Position := 0;
end;

procedure TLbSCStream.ChangeKey(const Key; KeySize : Integer);
begin
  InitEncryptLSC(Key, KeySize, FContext);
end;

function TLbSCStream.Read(var Buffer; Count : LongInt) : LongInt;
begin
  Result := inherited Read(Buffer, Count);
  EncryptLSC(FContext, Buffer, Count);
end;

function TLbSCStream.Write(const Buffer; Count : LongInt) : LongInt;
var
  Buf : Pointer;
begin
  GetMem(Buf, Count);
  try
    Move(Buffer, Buf^, Count);
    EncryptLSC(FContext, Buf^, Count);
    Result := inherited Write(Buf^, Count);
  finally
    FreeMem(Buf, Count);
  end;
end;

constructor TLbSCFileStream.Create(const FileName : string; Mode : Word;  const Key; KeySize : Integer);
begin
  inherited Create(FileName, Mode);
  Reinitialize(Key, KeySize);
end;

procedure TLbSCFileStream.Reinitialize(const Key; KeySize : Integer);
begin
  ChangeKey(Key, KeySize);
  Position := 0;
end;

procedure TLbSCFileStream.ChangeKey(const Key; KeySize : Integer);
begin
  InitEncryptLSC(Key, KeySize, FContext);
end;

function TLbSCFileStream.Read(var Buffer; Count : LongInt) : LongInt;
begin
  Result := inherited Read(Buffer, Count);
  EncryptLSC(FContext, Buffer, Count);
end;

function TLbSCFileStream.Write(const Buffer; Count : LongInt) : LongInt;
var
  Buf : Pointer;
begin
  GetMem(Buf, Count);
  try
    Move(Buffer, Buf^, Count);
    EncryptLSC(FContext, Buf^, Count);
    Result := inherited Write(Buf^, Count);
  finally
    FreeMem(Buf, Count);
  end;
end;

constructor TLbRNG32Stream.Create(const Key : LongInt);
begin
  inherited Create;
  Reinitialize(Key);
end;

procedure TLbRNG32Stream.Reinitialize(const Key : LongInt);
begin
  ChangeKey(Key);
  Position := 0;
end;

procedure TLbRNG32Stream.ChangeKey(const Key : LongInt);
begin
  InitEncryptRNG32(Key, FContext);
end;

function TLbRNG32Stream.Read(var Buffer; Count : LongInt) : LongInt;
begin
  Result := inherited Read(Buffer, Count);
  EncryptRNG32(FContext, Buffer, Count);
end;

function TLbRNG32Stream.Write(const Buffer; Count : LongInt) : LongInt;
var
  Buf : Pointer;
begin
  GetMem(Buf, Count);
  try
    Move(Buffer, Buf^, Count);
    EncryptRNG32(FContext, Buf^, Count);
    Result := inherited Write(Buf^, Count);
  finally
    FreeMem(Buf, Count);
  end;
end;

constructor TLbRNG32FileStream.Create(const FileName : string; Mode : Word; const Key : LongInt);
begin
  inherited Create(FileName, Mode);
  Reinitialize(Key);
end;

procedure TLbRNG32FileStream.Reinitialize(const Key : LongInt);
begin
  ChangeKey(Key);
  Position := 0;
end;

procedure TLbRNG32FileStream.ChangeKey(const Key : LongInt);
begin
  InitEncryptRNG32(Key, FContext);
end;

function TLbRNG32FileStream.Read(var Buffer; Count : LongInt) : LongInt;
begin
  Result := inherited Read(Buffer, Count);
  EncryptRNG32(FContext, Buffer, Count);
end;

function TLbRNG32FileStream.Write(const Buffer; Count : LongInt) : LongInt;
var
  Buf : Pointer;
begin
  GetMem(Buf, Count);
  try
    Move(Buffer, Buf^, Count);
    EncryptRNG32(FContext, Buf^, Count);
    Result := inherited Write(Buf^, Count);
  finally
    FreeMem(Buf, Count);
  end;
end;

constructor TLbRNG64Stream.Create(const KeyHi, KeyLo : LongInt);
begin
  inherited Create;

  Reinitialize(KeyHi, KeyLo);
end;

procedure TLbRNG64Stream.Reinitialize(const KeyHi, KeyLo : LongInt);
begin
  ChangeKey(KeyHi, KeyLo);
  Position := 0;
end;

procedure TLbRNG64Stream.ChangeKey(const KeyHi, KeyLo : LongInt);
begin
  InitEncryptRNG64(KeyHi, KeyLo, FContext);
end;

function TLbRNG64Stream.Read(var Buffer; Count : LongInt) : LongInt;
begin
  Result := inherited Read(Buffer, Count);
  EncryptRNG64(FContext, Buffer, Count);
end;

function TLbRNG64Stream.Write(const Buffer; Count : LongInt) : LongInt;
var
  Buf : Pointer;
begin
  GetMem(Buf, Count);
  try
    Move(Buffer, Buf^, Count);
    EncryptRNG64(FContext, Buf^, Count);
    Result := inherited Write(Buf^, Count);
  finally
    FreeMem(Buf, Count);
  end;
end;

constructor TLbRNG64FileStream.Create(const FileName : string; Mode : Word; const KeyHi, KeyLo : LongInt);
begin
  inherited Create(FileName, Mode);
  Reinitialize(KeyHi, KeyLo);
end;

procedure TLbRNG64FileStream.Reinitialize(const KeyHi, KeyLo : LongInt);
begin
  ChangeKey(KeyHi, KeyLo);
  Position := 0;
end;

procedure TLbRNG64FileStream.ChangeKey(const KeyHi, KeyLo : LongInt);
begin
  InitEncryptRNG64(KeyHi, KeyLo, FContext);
end;

function TLbRNG64FileStream.Read(var Buffer; Count : LongInt) : LongInt;
begin
  Result := inherited Read(Buffer, Count);
  EncryptRNG64(FContext, Buffer, Count);
end;

function TLbRNG64FileStream.Write(const Buffer; Count : LongInt) : LongInt;
var
  Buf : Pointer;
begin
  GetMem(Buf, Count);
  try
    Move(Buffer, Buf^, Count);
    EncryptRNG64(FContext, Buf^, Count);
    Result := inherited Write(Buf^, Count);
  finally
    FreeMem(Buf, Count);
  end;
end;

constructor TLbAsymmetricKey.Create(aKeySize : TLbAsymKeySize);
begin
  FKeySize := aKeySize;
end;

destructor TLbAsymmetricKey.Destroy;
begin
  inherited Destroy;
end;

procedure TLbAsymmetricKey.Assign(aKey : TLbAsymmetricKey);
begin
  FKeySize := aKey.KeySize;
end;

procedure TLbAsymmetricKey.SetKeySize(Value : TLbAsymKeySize);
begin
  FKeySize := Value;
end;

procedure TLbAsymmetricKey.MovePtr(var Ptr : PByte; var Max : Integer);
begin
  Dec(Max);
  if (Max < 0) then
    raise Exception.Create(sASNKeyBadKey);
  Inc(Ptr);
end;

procedure TLbAsymmetricKey.MovePtrCount(var Ptr : PByte; var Max : Integer; Count : Integer);
begin
  Dec(Max, Count);
  if (Max < 0) then
    raise Exception.Create(sASNKeyBadKey);
  Inc(Ptr, Count);
end;

function TLbAsymmetricKey.GetASN1StructLen(var Input : PByte; var Len : Integer) : Integer;
var
  Tmp_int : Integer;
  TagLen  : Integer;
  Tmp_ptr : PByte;
  Max     : Integer;
  IsHighBit : boolean;
begin
  Max := Len;
  Tmp_ptr := Input;
  tagLen := $00;

  isHighBit := ( tmp_ptr^ and HIGH_BIT_MASK ) = HIGH_BIT_MASK;
  tmp_int := tmp_ptr^ and BIT_MASK_7F;

  MovePtr( tmp_ptr, max );
  if( isHighBit )then begin
    while( tmp_int > 0 )do begin
      tagLen := ( tagLen shl 8 ) or  tmp_ptr^;
      MovePtr( tmp_ptr, max );
      dec( tmp_int );
    end;
  end else
    tagLen := tmp_int;

  result := tagLen;
  len := max;
  input := tmp_ptr;
end;

function TLbAsymmetricKey.GetASN1StructNum (var Input : PByte; var Len : Integer) : Integer;
var
  tmp_int : Integer;
  tagNum : Integer;
  tmp_ptr : pBYTE;
  max : Integer;
  hold_byte : BYTE;
  tag : Integer;
begin
  max := len;
  tmp_ptr := input;
  hold_byte := tmp_ptr^;
  tagNum := ( hold_byte and ASN1_TAG_NUM_MASK );

  if( tagNum = ASN1_TYPE_HIGH_TAG_NUMBER )then begin
    MovePtr( tmp_ptr, max );
    tmp_int := 0;
    while(( tmp_ptr^ and HIGH_BIT_MASK ) > 0 )do begin
      tmp_int := tmp_int shl 7;
      MovePtr( tmp_ptr, max );
      tmp_int := tmp_int or ( tmp_ptr^ and BIT_MASK_7F );
    end;
    tmp_int := tmp_int shl 7;
    MovePtr( tmp_ptr, max );
    tmp_int := tmp_int or ( tmp_ptr^ and BIT_MASK_7F );
    tag := tmp_int;
  end else begin
    tag := tagNum;
    MovePtr( tmp_ptr, max );
  end;
  len := max;
  input := tmp_ptr;
  result := tag;
end;

procedure TLbAsymmetricKey.CreateASN1(var Buf; var BufLen : Integer; Tag : Byte);
var
  i : Integer;
  x : Integer;
  tmp : array[0..4095] of Byte;
  TagSize : Integer;
  tmp_Len : Integer;
begin

  if (BufLen > SizeOf(tmp)) then
    raise Exception.Create(sASNKeyBadKey);

  TagSize := 0;
  tmp_Len := BufLen;
  tmp[TagSize] := Tag;
  Inc(TagSize);
  if (BufLen > BIT_MASK_7F) then begin
    i := BufLen div $FF;
    if (i = 0) then
      i := 1;
    tmp[TagSize] := ($80 or i);
    Inc(TagSize , i);
    for x := 1 to i do begin
      tmp[TagSize] := BufLen and $000000FF;
      BufLen := BufLen shr 8;
      Dec(TagSize);
    end;
    Inc(TagSize, i+1);
  end else begin
    tmp[TagSize] := BufLen;
    Inc(TagSize)
  end;

  BufLen := tmp_Len + TagSize;
  if (BufLen > SizeOf(tmp)) then
    raise Exception.Create(sASNKeyBadKey);

  Move(Buf, tmp[TagSize], tmp_Len);
  Move(tmp, Buf, BufLen);
end;

function TLbAsymmetricKey.EncodeASN1(biValue : TLbBigInt; var pBuf : PByteArray; var MaxLen : Integer) : Integer;
const
  TAG02 = $02;
var
  Pad : Boolean;
begin
  Result := biValue.Size;
  Pad := (biValue.GetByteValue(1) > $80);
  if Pad then
    Inc(Result);
  if (Result > MaxLen) then
    raise Exception.Create(sASNKeyBadKey);

  FillChar(pBuf^, Result, #0);
  biValue.ToBuffer(pBuf^, Result);

  if Pad then begin
    Move(pBuf^[0], pBuf^[1], Result-1);
    pBuf^[0] := $00;
  end;

  CreateASN1(pBuf^, Result, TAG02);
  MovePtrCount(PByte(pBuf), MaxLen, Result);
end;

procedure TLbAsymmetricKey.LoadFromStream(aStream : TStream);
var
  KeyBuf : array[0..4096] of Byte;
  Len : Integer;
  MemStream : TMemoryStream;
  BFKey : TKey128;
begin
  FillChar(KeyBuf, SizeOf(KeyBuf), #0);
  aStream.Position := 0;
  if (FPassphrase <> '') then begin
    MemStream := TMemoryStream.Create;
    try
      StringHashMD5A(TMD5Digest(BFKey), FPassphrase);
      BFEncryptStream(aStream, MemStream, BFKey, False);
      Len := MemStream.Size;
      if (Len > SizeOf(KeyBuf)) then
        raise Exception.Create(sASNKeyBadKey);
      MemStream.Position := 0;
      MemStream.Read(KeyBuf, Len);
    finally
      MemStream.Free;
    end;
  end else begin
    Len := aStream.Size;
    if (Len > SizeOf(KeyBuf)) then
      raise Exception.Create(sASNKeyBadKey);
    aStream.Read(KeyBuf, Len);
  end;
  ParseASNKey(pByte(@KeyBuf), Len);
  FillChar(KeyBuf, SizeOf(KeyBuf), #0);
end;

procedure TLbAsymmetricKey.StoreToStream(aStream : TStream);
var
  KeyBuf : array[0..4096] of Byte;
  Len : Integer;
  MemStream : TMemoryStream;
  BFKey : TKey128;
begin
  FillChar(KeyBuf, SizeOf(KeyBuf), #0);
  Len := CreateASNKey(@KeyBuf, SizeOf(KeyBuf));
  if (FPassphrase <> '') then begin
    MemStream := TMemoryStream.Create;
    try
      MemStream.Write(KeyBuf, Len);
      MemStream.Position := 0;
      StringHashMD5A(TMD5Digest(BFKey), FPassphrase);
      BFEncryptStream(MemStream, aStream, BFKey, True);
    finally
      MemStream.Free;
    end;
  end else
    aStream.Write(KeyBuf, Len);

  FillChar(KeyBuf, SizeOf(KeyBuf), #0);
end;

procedure TLbAsymmetricKey.LoadFromFile(aFileName : string);
var
  FS : TFileStream;
begin
  FS := TFileStream.Create(aFileName, fmOpenRead);
  try
    LoadFromStream(FS);
  finally
    FS.Free;
  end;
end;

procedure TLbAsymmetricKey.StoreToFile(aFileName : string);
var
  FS : TFileStream;
begin
  FS := TFileStream.Create(aFileName, fmCreate);
  try
    StoreToStream(FS);
  finally
    FS.Free;
  end;
end;

procedure TLbAsymmetricKey.ParseASN1(var input : pByte; var length : Integer; biValue : TLbBigInt);
var
  tag : Integer;
  len : Integer;
begin
  tag := GetASN1StructNum( input, length );
  len := GetASN1StructLen( input, length );

  if( len > length )then
    raise Exception.Create(sASNKeyBadKey);

  if( tag = ASN1_TYPE_Integer )then begin
    if( input^ = $00 ) and ( pByteArray( input )^[ 1 ] > $80 )then begin
      MovePtr( input, length );
      dec( len );
    end;
    biValue.CopyBuffer( input^, len );
    inc( pByte( input ), len );
    length := length - len;
  end else
    raise Exception.Create(sASNKeyBadKey);
end;

constructor TLbAsymmetricCipher.Create(AOwner : TComponent);
begin
  inherited Create(AOwner);

  FKeySize := cLbDefAsymKeySize;
end;

destructor TLbAsymmetricCipher.Destroy;
begin
  inherited Destroy;
end;

procedure TLbAsymmetricCipher.SetKeySize(Value : TLbAsymKeySize);
begin
  FKeySize := Value;
end;

constructor TLbSignature.Create(AOwner : TComponent);
begin
  inherited Create(AOwner);

  FKeySize := cLbDefAsymKeySize;
end;

destructor TLbSignature.Destroy;
begin
  inherited Destroy;
end;

procedure TLbSignature.SetKeySize(Value : TLbAsymKeySize);
begin
  FKeySize := Value;
end;

procedure TLbSignature.SignString(const AStr: {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF});
begin
  {$IFDEF LOCKBOXUNICODE}
  SignStringW(AStr);
  {$ELSE}
  SignStringA(AStr);
  {$ENDIF}
end;

function TLbSignature.VerifyString(const AStr: {$IFDEF LOCKBOXUNICODE}UnicodeString{$ELSE}AnsiString{$ENDIF}): Boolean;
begin
  {$IFDEF LOCKBOXUNICODE}
  Result := VerifyStringW(AStr);
  {$ELSE}
  Result := VerifyStringA(AStr);
  {$ENDIF}
end;

constructor TLbRSAKey.Create(aKeySize : TLbAsymKeySize);
begin
  inherited Create(aKeySize);

  FModulus := TLbBigInt.Create(cLbAsymKeyBytes[FKeySize]);
  FExponent := TLbBigInt.Create(cLbAsymKeyBytes[FKeySize]);
end;

destructor TLbRSAKey.Destroy;
begin
  FModulus.Free;
  FExponent.Free;

  inherited Destroy;
end;

procedure TLbRSAKey.Assign(aKey : TLbAsymmetricKey);
begin
  inherited Assign(aKey);

  if (aKey is TLbRSAKey) then begin
    FModulus.Copy(TLbRSAKey(aKey).Modulus);
    FExponent.Copy(TLbRSAKey(aKey).Exponent);
  end;
end;

procedure TLbRSAKey.Clear;
begin
  FModulus.Clear;
  FExponent.Clear;
end;

function TLbRSAKey.GetModulusAsString : string;
begin
  Result := FModulus.IntStr;
end;

procedure TLbRSAKey.SetModulusAsString(Value : string);
var
  Buf : array[Byte] of Byte;
begin
  FillChar(Buf, SizeOf(Buf), #0);
  HexToBuffer(Value, Buf, cLbAsymKeyBytes[FKeySize]);
  FModulus.CopyBuffer(Buf, cLbAsymKeyBytes[FKeySize]);
  FModulus.Trim;
end;

function TLbRSAKey.GetExponentAsString : string;
begin
  Result := FExponent.IntStr;
end;

procedure TLbRSAKey.SetExponentAsString(Value : string);
var
  Buf : array[Byte] of Byte;
begin
  FillChar(Buf, SizeOf(Buf), #0);
  HexToBuffer(Value, Buf, cLbAsymKeyBytes[FKeySize]);
  FExponent.CopyBuffer(Buf, cLbAsymKeyBytes[FKeySize]);
  FExponent.Trim;
end;

function TLbRSAKey.CreateASNKey(Input : pByteArray; Length : Integer) : Integer;
const
  TAG30 = $30;
var
  ExpSize : Integer;
  ModSize : Integer;
  Total : Integer;
  pInput : PByteArray;
  Max : Integer;
begin
  pInput := Input;
  Max := Length;
  ModSize := EncodeASN1(FModulus, pInput, Max);
  ExpSize := EncodeASN1(FExponent, pInput, Max);
  Total := ExpSize + ModSize;
  CreateASN1(Input^, Total, TAG30);
  Result := Total;
end;

function TLbRSAKey.ParseASNKey(Input : PByte; Length : Integer) : Boolean;
var
  Tag : Integer;
  Max : Integer;
  pInput : PByte;
begin
  Max := Length;
  pInput := Input;
  Tag := GetASN1StructNum(pInput, Max);
  GetASN1StructLen(pInput, Max);
  if (Tag <> ASN1_TYPE_SEQUENCE) then
    raise Exception.Create(sRSAKeyBadKey);
  ParseASN1(pInput, Max, FModulus);
  ParseASN1(pInput, Max, FExponent);
  Result := (Max = 0);
end;

constructor TLbRSA.Create(AOwner : TComponent);
begin
  inherited Create(AOwner);

  FPrivateKey := TLbRSAKey.Create(FKeySize);
  FPublicKey  := TLbRSAKey.Create(FKeySize);
  FPrimeTestIterations := cDefIterations;
end;

destructor TLbRSA.Destroy;
begin
  FPrivateKey.Free;
  FPublicKey.Free;

  inherited Destroy;
end;

procedure TLbRSA.DecryptFile(const InFile, OutFile : string);
begin
  RSAEncryptFile(InFile, OutFile, FPrivateKey, False);
end;

procedure TLbRSA.DecryptStream(InStream , OutStream : TStream);
begin
  RSAEncryptStream(InStream, OutStream, FPrivateKey, False);
end;

function TLbRSA.DecryptStringA(const InString : AnsiString) : AnsiString;
begin
  Result := RSAEncryptStringA(InString, FPrivateKey, False);
end;

{$IFDEF UNICODE}
function TLbRSA.DecryptStringW(const InString : UnicodeString) : UnicodeString;
begin
  Result := RSAEncryptStringW(InString, FPrivateKey, False);
end;
{$ENDIF}

procedure TLbRSA.EncryptFile(const InFile, OutFile : string);
begin
  RSAEncryptFile(InFile, OutFile, FPublicKey, True);
end;

procedure TLbRSA.EncryptStream(InStream, OutStream : TStream);
begin
  RSAEncryptStream(InStream, OutStream, FPublicKey, True);
end;

function TLbRSA.EncryptStringA(const InString : AnsiString) : AnsiString;
begin
  Result := RSAEncryptStringA(InString, FPublicKey, True);
end;

{$IFDEF UNICODE}
function TLbRSA.EncryptStringW(const InString : UnicodeString) : UnicodeString;
begin
  Result := RSAEncryptStringW(InString, FPublicKey, True);
end;
{$ENDIF}

procedure TLbRSA.GenerateKeyPair;
begin
  if Assigned(FPrivateKey) then
    FPrivateKey.Free;
  if Assigned(FPublicKey) then
    FPublicKey.Free;
  try
    GenerateRSAKeysEx(FPrivateKey, FPublicKey, FKeySize,
      FPrimeTestIterations, RSACallback);
  except
    raise Exception.Create(sRSAKeyPairErr);
  end;
end;

function TLbRSA.OutBufSizeNeeded(InBufSize : Cardinal) : Cardinal;
var
  BlkCount : Cardinal;
begin
  BlkCount := InBufSize div cRSAPlainBlockSize[FKeySize];
  if (InBufSize mod cRSAPlainBlockSize[FKeySize]) > 0 then
    Inc(BlkCount);
  Result := BlkCount * cRSACipherBlockSize[FKeySize];
end;

procedure TLbRSA.RSACallback(var Abort : Boolean);
begin
  Abort := False;
  if Assigned(FOnProgress) then
    FOnProgress(Self, Abort);
end;

procedure TLbRSA.SetKeySize(Value : TLbAsymKeySize);
begin
  FKeySize := Value;
  FPublicKey.KeySize := FKeySize;
  FPrivateKey.KeySize := FKeySize;
end;

constructor TLbRSASSA.Create(AOwner : TComponent);
begin
  inherited Create(AOwner);

  FPrivateKey := TLbRSAKey.Create(FKeySize);
  FPublicKey  := TLbRSAKey.Create(FKeySize);
  FSignature  := TLbBigInt.Create(cLbAsymKeyBytes[FKeySize]);
  FHashMethod := cDefHashMethod;
  FPrimeTestIterations := cDefIterations;
end;

destructor TLbRSASSA.Destroy;
begin
  FPrivateKey.Free;
  FPublicKey.Free;
  FSignature.Free;

  inherited Destroy;
end;

procedure TLbRSASSA.DoGetSignature;
var
  SigBlock : TRSASignatureBlock;
begin
  if Assigned(FOnGetSignature) then begin
    FillChar(SigBlock, SizeOf(SigBlock), #0);
    FOnGetSignature(Self, SigBlock);
    FSignature.CopyBuffer(SigBlock, cLbAsymKeyBytes[FKeySize]);
    FSignature.Trim;
  end;
end;

procedure TLbRSASSA.GenerateKeyPair;
begin
  if Assigned(FPrivateKey) then
    FPrivateKey.Free;
  if Assigned(FPublicKey) then
    FPublicKey.Free;
  GenerateRSAKeysEx(FPrivateKey, FPublicKey, FKeySize, FPrimeTestIterations,
                    RSACallback);
end;

procedure TLbRSASSA.EncryptHash(const HashDigest; DigestLen : Cardinal);
begin
  if (FPrivateKey.Modulus.Size = 0) then
    raise Exception.Create(sRSAPrivateKeyErr);

  FSignature.CopyBuffer(HashDigest, DigestLen);
  RSAEncryptBigInt(FSignature, FPrivateKey, bt01, True);
end;

procedure TLbRSASSA.DecryptHash(var HashDigest; DigestLen : Cardinal);
var
  biBlock : TLbBigInt;
begin
  if (FPublicKey.Modulus.Size = 0) then
    raise Exception.Create(sRSAPublicKeyErr);

  biBlock := TLbBigInt.Create(cLbAsymKeyBytes[FKeySize]);
  try
    DoGetSignature;
    biBlock.Copy(FSignature);
    RSAEncryptBigInt(biBlock, FPublicKey, bt01, False);
    FillChar(HashDigest, DigestLen, #0);
    if biBlock.Size < Integer(DigestLen) then
      biBlock.ToBuffer(HashDigest, biBlock.Size)
    else
      biBlock.ToBuffer(HashDigest, DigestLen);
  except
  end;
  biBlock.Free;
end;

procedure TLbRSASSA.SignBuffer(const Buf; BufLen : Cardinal);
var
  MD5Digest  : TMD5Digest;
  SHA1Digest : TSHA1Digest;
begin
  case FHashMethod of
    hmMD5  :
      begin
        HashMD5(MD5Digest, Buf, BufLen);
        EncryptHash(MD5Digest, SizeOf(MD5Digest));
      end;
    hmSHA1 :
      begin
        HashSHA1(SHA1Digest, Buf, BufLen);
        EncryptHash(SHA1Digest, SizeOf(SHA1Digest));
      end;
  end;
end;

procedure TLbRSASSA.SignFile(const AFileName : string);
var
  MD5Digest  : TMD5Digest;
  SHA1Digest : TSHA1Digest;
begin
  case FHashMethod of
    hmMD5  :
      begin
        FileHashMD5(MD5Digest, AFileName);
        EncryptHash(MD5Digest, SizeOf(MD5Digest));
      end;
    hmSHA1 :
      begin
        FileHashSHA1(SHA1Digest, AFileName);
        EncryptHash(SHA1Digest, SizeOf(SHA1Digest));
      end;
  end;
end;

procedure TLbRSASSA.SignStream(AStream : TStream);
var
  MD5Digest  : TMD5Digest;
  SHA1Digest : TSHA1Digest;
begin
  case FHashMethod of
    hmMD5  :
      begin
        StreamHashMD5(MD5Digest, AStream);
        EncryptHash(MD5Digest, SizeOf(MD5Digest));
      end;
    hmSHA1 :
      begin
        StreamHashSHA1(SHA1Digest, AStream);
        EncryptHash(SHA1Digest, SizeOf(SHA1Digest));
      end;
  end;
end;

procedure TLbRSASSA.SignStringA(const AStr : AnsiString);
var
  MD5Digest  : TMD5Digest;
  SHA1Digest : TSHA1Digest;
begin
  case FHashMethod of
    hmMD5  :
      begin
        StringHashMD5A(MD5Digest, AStr);
        EncryptHash(MD5Digest, SizeOf(MD5Digest));
      end;
    hmSHA1 :
      begin
        StringHashSHA1A(SHA1Digest, AStr);
        EncryptHash(SHA1Digest, SizeOf(SHA1Digest));
      end;
  end;
end;

{$IFDEF UNICODE}
procedure TLbRSASSA.SignStringW(const AStr : UnicodeString);
var
  MD5Digest  : TMD5Digest;
  SHA1Digest : TSHA1Digest;
begin
  case FHashMethod of
    hmMD5  :
      begin
        StringHashMD5W(MD5Digest, AStr);
        EncryptHash(MD5Digest, SizeOf(MD5Digest));
      end;
    hmSHA1 :
      begin
        StringHashSHA1W(SHA1Digest, AStr);
        EncryptHash(SHA1Digest, SizeOf(SHA1Digest));
      end;
  end;
end;
{$ENDIF}

function TLbRSASSA.VerifyBuffer(const Buf; BufLen : Cardinal) : Boolean;
var
  MD5Digest1  : TMD5Digest;
  MD5Digest2  : TMD5Digest;
  SHA1Digest1 : TSHA1Digest;
  SHA1Digest2 : TSHA1Digest;
begin
  case FHashMethod of
    hmMD5 :
      begin
        DecryptHash(MD5Digest1, SizeOf(TMD5Digest));
        HashMD5(MD5Digest2, Buf, BufLen);
        Result := CompareBuffers(MD5Digest1, MD5Digest2, SizeOf(TMD5Digest));
      end;
    hmSHA1 :
      begin
        DecryptHash(SHA1Digest1, SizeOf(TSHA1Digest));
        HashSHA1(SHA1Digest2, Buf, BufLen);
        Result := CompareBuffers(SHA1Digest1, SHA1Digest2, SizeOf(TSHA1Digest));
      end;
  else
    Result := False;
  end;
end;

function TLbRSASSA.VerifyFile(const AFileName : string) : Boolean;
var
  MD5Digest1  : TMD5Digest;
  MD5Digest2  : TMD5Digest;
  SHA1Digest1 : TSHA1Digest;
  SHA1Digest2 : TSHA1Digest;
begin
  case FHashMethod of
    hmMD5 :
      begin
        DecryptHash(MD5Digest1, SizeOf(TMD5Digest));
        FileHashMD5(MD5Digest2, AFileName);
        Result := CompareBuffers(MD5Digest1, MD5Digest2, SizeOf(TMD5Digest));
      end;
    hmSHA1 :
      begin
        DecryptHash(SHA1Digest1, SizeOf(TSHA1Digest));
        FileHashSHA1(SHA1Digest2, AFileName);
        Result := CompareBuffers(SHA1Digest1, SHA1Digest2, SizeOf(TSHA1Digest));
      end;
  else
    Result := False;
  end;
end;

function TLbRSASSA.VerifyStream(AStream : TStream) : Boolean;
var
  MD5Digest1  : TMD5Digest;
  MD5Digest2  : TMD5Digest;
  SHA1Digest1 : TSHA1Digest;
  SHA1Digest2 : TSHA1Digest;
begin
  case FHashMethod of
    hmMD5 :
      begin
        DecryptHash(MD5Digest1, SizeOf(TMD5Digest));
        StreamHashMD5(MD5Digest2, AStream);
        Result := CompareBuffers(MD5Digest1, MD5Digest2, SizeOf(TMD5Digest));
      end;
    hmSHA1 :
      begin
        DecryptHash(SHA1Digest1, SizeOf(TSHA1Digest));
        StreamHashSHA1(SHA1Digest2, AStream);
        Result := CompareBuffers(SHA1Digest1, SHA1Digest2, SizeOf(TSHA1Digest));
      end;
  else
    Result := False;
  end;
end;

function TLbRSASSA.VerifyStringA(const AStr : AnsiString) : Boolean;
var
  MD5Digest1  : TMD5Digest;
  MD5Digest2  : TMD5Digest;
  SHA1Digest1 : TSHA1Digest;
  SHA1Digest2 : TSHA1Digest;
begin
  case FHashMethod of
    hmMD5 :
      begin
        DecryptHash(MD5Digest1, SizeOf(TMD5Digest));
        StringHashMD5A(MD5Digest2, AStr);
        Result := CompareBuffers(MD5Digest1, MD5Digest2, SizeOf(TMD5Digest));
      end;
    hmSHA1 :
      begin
        DecryptHash(SHA1Digest1, SizeOf(TSHA1Digest));
        StringHashSHA1A(SHA1Digest2, AStr);
        Result := CompareBuffers(SHA1Digest1, SHA1Digest2, SizeOf(TSHA1Digest));
      end;
  else
    Result := False;
  end;
end;

{$IFDEF UNICODE}
function TLbRSASSA.VerifyStringW(const AStr : UnicodeString) : Boolean;
var
  MD5Digest1  : TMD5Digest;
  MD5Digest2  : TMD5Digest;
  SHA1Digest1 : TSHA1Digest;
  SHA1Digest2 : TSHA1Digest;
begin
  case FHashMethod of
    hmMD5 :
      begin
        DecryptHash(MD5Digest1, SizeOf(TMD5Digest));
        StringHashMD5W(MD5Digest2, AStr);
        Result := CompareBuffers(MD5Digest1, MD5Digest2, SizeOf(TMD5Digest));
      end;
    hmSHA1 :
      begin
        DecryptHash(SHA1Digest1, SizeOf(TSHA1Digest));
        StringHashSHA1W(SHA1Digest2, AStr);
        Result := CompareBuffers(SHA1Digest1, SHA1Digest2, SizeOf(TSHA1Digest));
      end;
  else
    Result := False;
  end;
end;
{$ENDIF}

procedure TLbRSASSA.RSACallback(var Abort : Boolean);
begin
  Abort := False;
  if Assigned(FOnProgress) then
    FOnProgress(Self, Abort);
end;

procedure TLbRSASSA.SetKeySize(Value : TLbAsymKeySize);
begin
  if (Ord(Value) < Ord(aks256)) then begin
    if (csDesigning in ComponentState) then
      FKeySize := aks256
    else
      raise Exception.Create('Invalid key size for RSASSA');
  end else
    FKeySize := Value;
  FPublicKey.KeySize := FKeySize;
  FPrivateKey.KeySize := FKeySize;
  FSignature.Free;
  FSignature := TLbBigInt.Create(cLbAsymKeyBytes[FKeySize]);
end;

constructor TLbDSAParameters.Create(aKeySize : TLbAsymKeySize);
begin
  inherited Create(aKeySize);
  FP := TLbBigInt.Create(cLbAsymKeyBytes[FKeySize]);
  FQ := TLbBigInt.Create(SizeOf(TLbDSABlock));
  FG := TLbBigInt.Create(cLbAsymKeyBytes[FKeySize]);
  F2Tog := TLbBigInt.Create(SizeOf(TLbDSABlock));
  F2Tog.CopyByte(1);
  F2Tog.Shl_(SizeOf(TLbDSABlock) * 8);
  FMostLeast := TLbBigInt.Create(SizeOf(TLbDSABlock));
  FMostLeast.Copy(F2Tog);
  FMostLeast.Shr_(1);
  FMostLeast.AddByte(1);
  FPrimeTestIterations := cDefIterations;
end;

destructor TLbDSAParameters.Destroy;
begin
  FP.Free;
  FQ.Free;
  FG.Free;
  F2Tog.Free;
  FMostLeast.Free;
  inherited Destroy;
end;

procedure TLbDSAParameters.Clear;
begin
  FP.Clear;
  FQ.Clear;
  FG.Clear;
end;

procedure TLbDSAParameters.SetKeySize(Value : TLbAsymKeySize);
begin
  if (Value <> FKeySize) then begin
    if (Ord(Value) >= Ord(aks512)) and (Ord(Value) <= Ord(aks1024)) then
      FKeySize := Value
    else
      FKeySize := cLbDefAsymKeySize;
    FP.Clear;
    FQ.Clear;
    FG.Clear;
  end;
end;

function TLbDSAParameters.GetPAsString : string;
begin
  Result := FP.IntStr;
end;

procedure TLbDSAParameters.SetPAsString(const Value : string);
var
  Buf : array[Byte] of Byte;
begin
  FillChar(Buf, SizeOf(Buf), #0);
  HexToBuffer(Value, Buf, cLbAsymKeyBytes[FKeySize]);
  FP.CopyBuffer(Buf, cLbAsymKeyBytes[FKeySize]);
  FP.Trim;
end;

function TLbDSAParameters.GetQAsString : string;
begin
  Result := FQ.IntStr;
end;

procedure TLbDSAParameters.SetQAsString(const Value : string);
var
  Buf : TLbDSABlock;
begin
  FillChar(Buf, SizeOf(Buf), #0);
  HexToBuffer(Value, Buf, SizeOf(Buf));
  FQ.CopyBuffer(Buf, SizeOf(Buf));
  FQ.Trim;
end;

function TLbDSAParameters.GetGAsString : string;
begin
  Result := FG.IntStr;
end;

procedure TLbDSAParameters.SetGAsString(const Value : string);
var
  Buf : array[Byte] of Byte;
begin
  FillChar(Buf, SizeOf(Buf), #0);
  HexToBuffer(Value, Buf, cLbAsymKeyBytes[FKeySize]);
  FG.CopyBuffer(Buf, cLbAsymKeyBytes[FKeySize]);
  FG.Trim;
end;

procedure TLbDSAParameters.CopyDSAParameters(aKey : TLbDSAParameters);
begin
  FP.Copy(aKey.P);
  FQ.Copy(aKey.Q);
  FG.Copy(aKey.G);
end;

function TLbDSAParameters.GenerateDSAParameters(const ASeed : TLbDSABlock) : Boolean;
begin
  Result := GenerateQ(ASeed);
  if Result then
    Result := GenerateP(ASeed);
  if Result then
    Result := GenerateG;
end;

function TLbDSAParameters.GenerateQ(const ASeed : TLbDSABlock) : Boolean;
const
  MaxTries = 4096;
var
  U, SHAseed, SHAseed1 : TLbBigInt;
  Digest : TSHA1Digest;
  Counter : Word;
begin
  U := TLbBigInt.Create(SizeOf(TLbDSABlock));
  SHAseed := TLbBigInt.Create(SizeOf(TLbDSABlock));
  SHAseed1 := TLbBigInt.Create(SizeOf(TLbDSABlock));
  Counter := 0;
  try
    SHAseed.CopyBuffer(ASeed, SizeOf(ASeed));
    repeat
      FQ.Clear;
      HashSHA1(Digest, SHAseed.IntBuf^, SHAseed.Size);
      SHAseed.CopyBuffer(Digest, SizeOf(Digest));
      SHAseed.ReverseBytes;
      SHAseed1.CopyBuffer(ASeed, SizeOf(ASeed));
      SHASeed1.ReverseBytes;
      SHAseed1.AddByte(1);
      SHAseed1.Modulus(F2Tog);
      SHASeed1.ReverseBytes;
      HashSHA1(Digest, SHAseed1.IntBuf^, SHAseed1.Size);
      SHAseed1.CopyBuffer(Digest, SizeOf(Digest));
      SHASeed1.ReverseBytes;
      U.Copy(SHAseed);
      U.XOR_(SHAseed1);
      FQ.Copy(U);
      FQ.OR_(FMostLeast);
      Result := not FQ.IsComposite(FPrimeTestIterations);
      if not Result then begin
        Inc(Counter);
        SHASeed.RandomBytes(SizeOf(TLbDSABlock));
      end;
    until Result or (Counter >= MaxTries);
  finally
    U.Free;
    SHAseed.Free;
    SHAseed1.Free;
  end;
end;

function TLbDSAParameters.GenerateP(const ASeed : TLbDSABlock) : Boolean;
const
  MaxTries = 4096;
var
  V, W, TwoToN, ModN, c, X : TLbBigInt;
  tmp : TLbBigInt;
  Lminus1, Counter : DWord;
  Offset : word;
  k, N, B : Byte;
  Digest : TSHA1Digest;
  Abort : Boolean;
  Prime : Boolean;
begin
  Abort := False;
  Prime := False;
  V      := TLbBigInt.Create(SizeOf(TLbDSABlock));
  W      := TLbBigInt.Create(SizeOf(TLbDSABlock));
  TwoToN := TLbBigInt.Create(SizeOf(TLbDSABlock));
  ModN   := TLbBigInt.Create(SizeOf(TLbDSABlock));
  c      := TLbBigInt.Create(SizeOf(TLbDSABlock));
  X      := TLbBigInt.Create(SizeOf(TLbDSABlock));
  tmp    := TLbBigInt.Create(SizeOf(TLbDSABlock));

  Lminus1 := (cLbAsymKeyBytes[FKeySize] * 8) - 1;
  N := Lminus1 div 160;
  B := Lminus1 mod 160;
  Counter := 0;
  Offset := 2;

  try
    while not (Prime or Abort) or (Counter > MaxTries) do begin
      W.CopyByte(0);

      for k := 0 to n do begin
        V.CopyBuffer(ASeed, SizeOf(ASeed));
        V.ReverseBytes;
        tmp.Clear;
        tmp.CopyDWord(k + Offset);
        V.Add( tmp );
        V.Modulus(F2Tog);
        V.ReverseBytes;
        HashSHA1(Digest, V.IntBuf^, V.Size);
        V.CopyBuffer(Digest, SizeOf(Digest));
        V.ReverseBytes;
        if (k = n) then begin
          ModN.CopyByte( 1 );
          ModN.Shl_( b );
          V.Modulus(ModN);
        end;
        V.Shl_(160 * k);
        W.Add(V);
      end;
      TwoToN.CopyByte(1);
      TwoToN.Shl_(Lminus1);
      X.Copy(W);
      X.Add(TwoToN);
      c.Copy(X);
      ModN.Copy(FQ);
      ModN.Shl_(1);
      c.Modulus(ModN);
      FP.Copy(X);
      FP.Subtract(c);
      FP.AddByte(1);
      if (FP.Compare(TwoToN) <> cLESS_THAN) then
        Prime := not FP.IsComposite(FPrimeTestIterations);

      if not Prime then
        if Assigned(FCallBack) then
          FCallBack(Abort);
      Inc(Counter);
      Inc(Offset, n+1);
    end;
  finally
    V.Free;
    W.Free;
    TwoToN.Free;
    ModN.Free;
    X.Free;
    c.Free;
    tmp.Free;
  end;
  Result := Prime;
end;

function TLbDSAParameters.GenerateG : Boolean;
var
  h, p1q, tmp, c1 : TLbBigInt;
begin
  Result := False;
  if (FP.Size < 2) then
    Exit;

  h   := TLbBigInt.Create(20);
  p1q := TLbBigInt.Create(20);
  tmp := TLbBigInt.Create(20);
  c1 := TLbBigInt.Create(20);
  try
    c1.CopyByte(1);
    p1q.Copy(FP);
    p1q.SubtractByte(1);
    p1q.Divide(FQ);

    h.CopyByte( $01 );
    repeat
      h.AddByte( $01 );
      tmp.Copy(h);
      tmp.PowerAndMod(p1q, FP);
    until (tmp.Compare(c1) = cGREATER_THAN);
    FG.Copy(h);
    FG.PowerAndMod(p1q, FP);
    Result := True;
  finally
    h.Free;
    p1q.Free;
    tmp.Free;
    c1.Free;
  end;
end;

constructor TLbDSAPrivateKey.Create(aKeySize : TLbAsymKeySize);
begin
  inherited Create(aKeySize);
  FX := TLbBigInt.Create(SizeOf(TLbDSABlock));
  FillChar(FXKey, SizeOf(FXKey), #0);
end;

destructor TLbDSAPrivateKey.Destroy;
begin
  FX.Free;
  inherited Destroy;
end;

procedure TLbDSAPrivateKey.Clear;
begin
  inherited Clear;
  FX.Clear;
  FillChar(FXKey, SizeOf(FXKey), #0);
end;

procedure TLbDSAPrivateKey.GenerateX(const AXKey : TLbDSABlock);
var
  XVal : TSHA1Digest;
begin
  Move(AXKey, FXKey, SizeOf(FXKey));
  FillChar(XVal, SizeOf(XVal), #0);
  HashSHA1(XVal, FXKey, SizeOf(FXKey));
  FX.CopyBuffer(XVal, SizeOf(XVal));
  FX.ReverseBytes;
  FX.Modulus(FQ);
end;

function TLbDSAPrivateKey.GetXAsString : string;
begin
  Result := FX.IntStr;
end;

procedure TLbDSAPrivateKey.SetXAsString(const Value : string);
var
  Buf : TLbDSABlock;
begin
  FillChar(Buf, SizeOf(Buf), #0);
  HexToBuffer(Value, Buf, SizeOf(Buf));
  FX.CopyBuffer(Buf, SizeOf(Buf));
  FX.Trim;
end;

function  TLbDSAPrivateKey.CreateASNKey(Input : pByteArray; Length : Integer) : Integer;
const
  TAG30 = $30;
var
  PSize : Integer;
  QSize : Integer;
  GSize : Integer;
  XSize : Integer;
  Total : Integer;
  pInput : PByteArray;
  Max : Integer;
begin
  pInput := Input;
  Max := Length;
  PSize := EncodeASN1(FP, pInput, Max);
  QSize := EncodeASN1(FQ, pInput, Max);
  GSize := EncodeASN1(FG, pInput, Max);
  XSize := EncodeASN1(FX, pInput, Max);
  Total := PSize + QSize + GSize + XSize;
  CreateASN1(Input^, Total, TAG30);
  Result := Total;
end;

function TLbDSAPrivateKey.ParseASNKey(Input : PByte; Length : Integer ) : Boolean;
var
  Tag : Integer;
  Max : Integer;
  pInput : PByte;
begin
  Max := Length;
  pInput := Input;

  Tag := GetASN1StructNum(pInput, Max);
  GetASN1StructLen(pInput, Max);

  if (Tag <> ASN1_TYPE_SEQUENCE) then
    raise Exception.Create(sDSAKeyBadKey);

  ParseASN1(pInput, Max, FP);
  ParseASN1(pInput, Max, FQ);
  ParseASN1(pInput, Max, FG);
  ParseASN1(pInput, Max, FX);

  Result := (Max = 0);
end;

constructor TLbDSAPublicKey.Create(aKeySize : TLbAsymKeySize);
begin
  inherited Create(aKeySize);
  FY := TLbBigInt.Create(cLbAsymKeyBytes[FKeySize]);
end;

destructor TLbDSAPublicKey.Destroy;
begin
  FY.Free;
  inherited Destroy;
end;

procedure TLbDSAPublicKey.Clear;
begin
  inherited Clear;
  FY.Clear;
end;

procedure TLbDSAPublicKey.GenerateY(aX : TLbBigInt);
begin
  FY.Copy(FG);
  FY.PowerAndMod(aX, FP);
end;

function TLbDSAPublicKey.GetYAsString : string;
begin
  Result := FY.IntStr;
end;

procedure TLbDSAPublicKey.SetYAsString(const Value : string);
var
  Buf : array[Byte] of Byte;
begin
  FillChar(Buf, SizeOf(Buf), #0);
  HexToBuffer(Value, Buf, cLbAsymKeyBytes[FKeySize]);
  FY.CopyBuffer(Buf, cLbAsymKeyBytes[FKeySize]);
  FY.Trim;
end;

function  TLbDSAPublicKey.CreateASNKey(Input : pByteArray; Length : Integer) : Integer;
const
  TAG30 = $30;
var
  PSize : Integer;
  QSize : Integer;
  GSize : Integer;
  YSize : Integer;
  Total : Integer;
  pInput : PByteArray;
  Max : Integer;
begin
  pInput := Input;
  Max := Length;
  PSize := EncodeASN1(FP, pInput, Max);
  QSize := EncodeASN1(FQ, pInput, Max);
  GSize := EncodeASN1(FG, pInput, Max);
  YSize := EncodeASN1(FY, pInput, Max);
  Total := PSize + QSize + GSize + YSize;
  CreateASN1(Input^, Total, TAG30);
  Result := Total;
end;

function TLbDSAPublicKey.ParseASNKey(input : pByte; length : Integer) : Boolean;
var
  Tag : Integer;
  Max : Integer;
  pInput : PByte;
begin
  Max := Length;
  pInput := Input;
  Tag := GetASN1StructNum(pInput, Max);
  GetASN1StructLen(pInput, Max);

  if (Tag <> ASN1_TYPE_SEQUENCE) then
    raise Exception.Create(sDSAKeyBadKey);

  ParseASN1(pInput, Max, FP);
  ParseASN1(pInput, Max, FQ);
  ParseASN1(pInput, Max, FG);
  ParseASN1(pInput, Max, FY);

  Result := (Max = 0);
end;

constructor TLbDSA.Create(AOwner : TComponent);
begin
  inherited Create(AOwner);

  FPrivateKey := TLbDSAPrivateKey.Create(FKeySize);
  FPrivateKey.Callback := DSAParameterCallback;
  FPublicKey  := TLbDSAPublicKey.Create(FKeySize);
  FPublicKey.Callback := DSAParameterCallback;
  FSignatureR := TLbBigInt.Create(SizeOf(TLbDSABlock));
  FSignatureS := TLbBigInt.Create(SizeOf(TLbDSABlock));
  FPrimeTestIterations := cDefIterations;
end;

destructor TLbDSA.Destroy;
begin
  FPrivateKey.Free;
  FPublicKey.Free;
  FSignatureR.Free;
  FSignatureS.Free;

  inherited Destroy;
end;

procedure TLbDSA.Clear;
begin
  FPrivateKey.Clear;
  FPublicKey.Clear;
  FSignatureR.Clear;
  FSignatureS.Clear;
end;

procedure TLbDSA.SetKeySize(Value : TLbAsymKeySize);
begin
  if (Value <> FKeySize) then begin
    if (Ord(Value) >= Ord(aks512)) and (Ord(Value) <= Ord(aks1024)) then
      FKeySize := Value
    else
      FKeySize := cLbDefAsymKeySize;
    FPrivateKey.KeySize := FKeySize;
    FPublicKey.KeySize := FKeySize;
  end;
end;

procedure TLbDSA.SetPrimeTestIterations(Value : Byte);
begin
  if (Value <> FPrimeTestIterations) then begin
    FPrimeTestIterations := Value;
    FPrivateKey.PrimeTestIterations := Value;
    FPublicKey.PrimeTestIterations := Value;
  end;
end;

procedure TLbDSA.DSAParameterCallback(var Abort : Boolean);
begin
  Abort := False;
  if Assigned(FOnProgress) then
    FOnProgress(Self, Abort);
end;

procedure TLbDSA.RandomBlock(var ABlock : TLbDSABlock);
begin
  with TLbRandomGenerator.Create do
    try
      RandomBytes(ABlock, SizeOf(ABlock));
    finally
      Free;
    end;
end;

procedure TLbDSA.DoGetSeed(var ASeed : TLbDSABlock);
begin
  FillChar(ASeed, SizeOf(ASeed), #0);
  if Assigned(FOnGetSeed) then
    FOnGetSeed(Self, ASeed);

  if CompareBuffers(ASeed, cZeroBlock, SizeOf(ASeed)) then
    RandomBlock(ASeed);
end;

procedure TLbDSA.DoGetXKey(var AXKey : TLbDSABlock);
begin
  FillChar(AXKey, SizeOf(AXKey), #0);
  if Assigned(FOnGetXKey) then
    FOnGetXKey(Self, AXKey);

  if CompareBuffers(AXKey, cZeroBlock, SizeOf(AXKey)) then
    RandomBlock(AXKey);
end;

procedure TLbDSA.DoGetKKey(var AKKey : TLbDSABlock);
begin
  FillChar(AKKey, SizeOf(AKKey), #0);
  if Assigned(FOnGetKKey) then
    FOnGetKKey(Self, AKKey);

  if CompareBuffers(AKKey, cZeroBlock, SizeOf(AKKey)) then
    RandomBlock(AKKey);
end;

procedure TLbDSA.SHA1KKey(var AKKey : TLbDSABlock);
var
  Context : TSHA1Context;
  Digest : TSHA1Digest;
begin
  Fillchar(Context, SizeOf(Context), #0);
  Context.sdHash[ 0 ] := SHA1_B;
  Context.sdHash[ 1 ] := SHA1_C;
  Context.sdHash[ 2 ] := SHA1_D;
  Context.sdHash[ 3 ] := SHA1_E;
  Context.sdHash[ 4 ] := SHA1_A;

  UpdateSHA1(Context, AKKey, SizeOf(AKKey));
  FinalizeSHA1(Context, Digest);
  Move(Digest, AKKey, SizeOf(AKKey));
end;

procedure TLbDSA.DoGetR;
var
  R : TLbDSABlock;
begin
  FillChar(R, SizeOf(R), #0);
  if Assigned(FOnGetR) then begin
    FOnGetR(Self, R);
    FSignatureR.CopyBuffer(R, SizeOf(R));
  end;
end;

procedure TLbDSA.DoGetS;
var
  S : TLbDSABlock;
begin
  FillChar(S, SizeOf(S), #0);
  if Assigned(FOnGetS) then begin
    FOnGetS(Self, S);
    FSignatureS.CopyBuffer(S, SizeOf(S));
  end;
end;

procedure TLbDSA.GenerateKeyPair;
begin
  GeneratePQG;
  GenerateXY;
end;

function TLbDSA.GeneratePQG : Boolean;
var
  Seed : TLbDSABlock;
begin
  DoGetSeed(Seed);
  try
    Result := FPrivateKey.GenerateDSAParameters(Seed);
    if Result then
      FPublicKey.CopyDSAParameters(FPrivateKey);
  except
    raise Exception.Create(sDSAParametersPQGErr);
  end;
end;

procedure TLbDSA.GenerateXY;
var
  XKey : TLbDSABlock;
begin
  DoGetXKey(XKey);
  try
    FPrivateKey.GenerateX(XKey);
    FPublicKey.GenerateY(FPrivateKey.X);
  except
    raise Exception.Create(sDSAParametersXYErr);
  end;
end;

procedure TLbDSA.SignHash(const ADigest : TSHA1Digest);
var
  K : TLbBigInt;
  XR : TLbBigInt;
  KKey : TLbDSABlock;
begin
  K := TLbBigInt.Create(SizeOf(TLbDSABlock));
  XR := TLbBigInt.Create(SizeOf(TLbDSABlock));
  DoGetKKey(KKey);
  try
    K.CopyBuffer(KKey, SizeOf(KKey));
    K.Modulus(FPrivateKey.Q);
    with FSignatureR do begin
      Copy(FPrivateKey.G);
      PowerAndMod(K, FPrivateKey.P);
      Modulus(FPrivateKey.Q);
      if FSignatureR.IsZero then
        raise Exception.Create(sDSASignatureZeroR);
    end;
    K.ModInv(FPrivateKey.Q);
    XR.Copy(FPrivateKey.X);
    XR.Multiply(FSignatureR);
    with FSignatureS do begin
      CopyBuffer(ADigest, SizeOf(ADigest));
      ReverseBytes;
      Add(XR);
      Multiply(K);
      Modulus(FPrivateKey.Q);
      if FSignatureS.IsZero then
        raise Exception.Create(sDSASignatureZeroS);
    end;
  except
    K.Free;
    XR.Free;
    raise Exception.Create(sDSASignatureErr);
  end;
  K.Free;
  XR.Free;
end;

function TLbDSA.VerifyHash(const ADigest : TSHA1Digest) : Boolean;
var
  W, U1, U2, V, V2 : TLbBigInt;
begin
  W  := TLbBigInt.Create(20);
  U1 := TLbBigInt.Create(20);
  U2 := TLbBigInt.Create(20);
  V  := TLbBigInt.Create(cLbAsymKeyBytes[FKeySize]);
  V2 := TLbBigInt.Create(cLbAsymKeyBytes[FKeySize]);
  DoGetR;
  DoGetS;
  try
    with W do begin
      Copy(FSignatureS);
      ModInv(FPublicKey.Q);
    end;
    with U1 do begin
      CopyBuffer(ADigest, SizeOf(ADigest));
      ReverseBytes;
      Multiply(W);
      Modulus(FPublicKey.Q);
    end;
    with U2 do begin
      Copy(FSignatureR);
      Multiply(W);
      Modulus(FPublicKey.Q);
    end;
    V.Copy(FPublicKey.Y);
    V.PowerAndMod(U2, FPublicKey.P);
    V2.Copy(FPublicKey.G);
    V2.PowerAndMod(U1, FPublicKey.P);
    V.Multiply(V2);
    V.Modulus(FPublicKey.P);
    V.Modulus(FPublicKey.Q);
    Result := V.Compare(FSignatureR) = cEQUAL_TO;
  except
    Result := False;
  end;
  W.Free;
  U1.Free;
  U2.Free;
  V.Free;
  V2.Free;
end;

procedure TLbDSA.SignBuffer(const Buf; BufLen : Cardinal);
var
  Digest : TSHA1Digest;
begin
  HashSHA1(Digest, Buf, BufLen);
  SignHash(Digest);
end;

procedure TLbDSA.SignFile(const AFileName : string);
var
  Digest : TSHA1Digest;
begin
  FileHashSHA1(Digest, AFileName);
  SignHash(Digest);
end;

procedure TLbDSA.SignStream(AStream : TStream);
var
  Digest : TSHA1Digest;
begin
  StreamHashSHA1(Digest, AStream);
  SignHash(Digest);
end;

procedure TLbDSA.SignStringA(const AStr : AnsiString);
var
  Digest : TSHA1Digest;
begin
  StringHashSHA1A(Digest, AStr);
  SignHash(Digest);
end;

{$IFDEF UNICODE}
procedure TLbDSA.SignStringW(const AStr : UnicodeString);
var
  Digest : TSHA1Digest;
begin
  StringHashSHA1W(Digest, AStr);
  SignHash(Digest);
end;
{$ENDIF}

function TLbDSA.VerifyBuffer(const Buf; BufLen : Cardinal) : Boolean;
var
  Digest : TSHA1Digest;
begin
  HashSHA1(Digest, Buf, BufLen);
  Result := VerifyHash(Digest);
end;

function TLbDSA.VerifyFile(const AFileName : string) : Boolean;
var
  Digest : TSHA1Digest;
begin
  FileHashSHA1(Digest, AFileName);
  Result := VerifyHash(Digest);
end;

function TLbDSA.VerifyStream(AStream : TStream) : Boolean;
var
  Digest : TSHA1Digest;
begin
  StreamHashSHA1(Digest, AStream);
  Result := VerifyHash(Digest);
end;

function TLbDSA.VerifyStringA(const AStr : AnsiString) : Boolean;
var
  Digest : TSHA1Digest;
begin
  StringHashSHA1A(Digest, AStr);
  Result := VerifyHash(Digest);
end;

{$IFDEF UNICODE}
function TLbDSA.VerifyStringW(const AStr : UnicodeString) : Boolean;
var
  Digest : TSHA1Digest;
begin
  StringHashSHA1W(Digest, AStr);
  Result := VerifyHash(Digest);
end;
{$ENDIF}

end.
